<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · JAC.jl</title><meta name="title" content="Examples · JAC.jl"/><meta property="og:title" content="Examples · JAC.jl"/><meta property="twitter:title" content="Examples · JAC.jl"/><meta name="description" content="Documentation for JAC.jl."/><meta property="og:description" content="Documentation for JAC.jl."/><meta property="twitter:description" content="Documentation for JAC.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">JAC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="getting-started.html">Getting Started</a></li><li><a class="tocitem" href="demos.html">Demos</a></li><li class="is-active"><a class="tocitem" href="examples.html">Examples</a><ul class="internal"><li><a class="tocitem" href="#Hydrogenic-Computation"><span>Hydrogenic Computation</span></a></li><li><a class="tocitem" href="#Compute-the-low-lying-levels-of-C{2}-1s2-(2s2-2s2p-2p2):-\\;-SCF-and-configuration-interaction-calculations"><span>Compute the low-lying levels of <span>$C^{2+} 1s^2 (2s^2 + 2s2p + 2p^2)$</span>: <span>$\;$</span> SCF and configuration interaction calculations</span></a></li></ul></li><li><a class="tocitem" href="news.html">News</a></li><li><a class="tocitem" href="api-atomic.html">API Atomic computations</a></li><li><a class="tocitem" href="api-processes.html">API Atomic processes</a></li><li><a class="tocitem" href="api-properties.html">API Atomic properties</a></li><li><a class="tocitem" href="api-basics.html">API Basics</a></li><li><a class="tocitem" href="api-cascades.html">API Cascade computations</a></li><li><a class="tocitem" href="api-empirical.html">API Empirical computations</a></li><li><a class="tocitem" href="api-plasma.html">API Plasma computations</a></li><li><a class="tocitem" href="api-racah.html">API Racah algebra</a></li><li><a class="tocitem" href="reference.html">Bibliography to JAC</a></li><li><a class="tocitem" href="getting-involved.html">Getting involved</a></li><li><a class="tocitem" href="contributors.html">Contributors</a></li><li><a class="tocitem" href="license.html">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="examples.html">Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="examples.html">Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/OpenJAC/JAC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/OpenJAC/JAC.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Hydrogenic-Computation"><a class="docs-heading-anchor" href="#Hydrogenic-Computation">Hydrogenic Computation</a><a id="Hydrogenic-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrogenic-Computation" title="Permalink"></a></h2><pre><code class="language-julia hljs">using JAC</code></pre><p>Perhaps, the simplest atomic computations can be made for hydrogenic ions. If we consider, for example, hydrogen-like  argon <span>$(Z=18)$</span>, we can first determine and compare the energies of the <span>$1s$</span> and <span>$2p$</span> levels from the (non-relativistic)  Schroedinger equation with those from Dirac&#39;s relativistic equation by</p><pre><code class="language-julia hljs">Z     = 18.0
e1s   = HydrogenicIon.energy(Shell(&quot;1s&quot;), Z)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-162.0</code></pre><pre><code class="language-julia hljs">e2p   = HydrogenicIon.energy(Shell(&quot;2p&quot;), Z)
e2p_1 = HydrogenicIon.energy(Subshell(&quot;2p_1/2&quot;), Z)
e2p_3 = HydrogenicIon.energy(Subshell(&quot;2p_3/2&quot;), Z)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-40.54376720995463</code></pre><p>While the (one-electron) energies are displayed by the function  <code>HydrogenicIon.energy()</code> in the default units  (presently eV here and as could be overwritten by the user), all <strong>computations are internally performed and  returned always in atomic units</strong>. This applies to all computations if not stated otherwise in the description of  some particular function; indeed, the user-defined units mainly in the tabulation of results but are not <em>returned</em>.  Most of these tabulations are generated by <em>display</em> method which print some table to screen but return <code>nothing</code>  otherwise.</p><p>This clear distinction between the use of <strong>atomic</strong> and <strong>(user-specified) default</strong> units can be seen  easily  from the output of the variables <code>e2p</code>, <code>e2p_1</code>, <code>e2p_3</code> above: </p><pre><code class="language-julia hljs">(e2p, e2p_1, e2p_3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-40.5, -40.720363843040175, -40.54376720995463)</code></pre><p>The units of energies, rates and several other physical properties can be however quite easily converted among each  other, for instance, by:</p><pre><code class="language-julia hljs">e1s_eV = convertUnits(&quot;energy: from atomic to eV&quot;, e1s)
e1s_au = convertUnits(&quot;energy: from eV to atomic&quot;, e1s_eV)
(e1s, e1s_eV, e1s_au)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-162.0, -4408.24453524, -162.0)</code></pre><p>... and similarly also for other energy units as well as for other physical entities; cf. <code>? convertUnits()</code>.</p><p>From these energies, we can easily compute the fine-structure splitting of the <span>$2p$</span> level into the <span>$2p_{1/2}$</span> and  <span>$2p_{3/2}$</span> (fine-structure) levels for hydrogen-like argon from above:</p><pre><code class="language-julia hljs">e13 = e2p_1 - e2p_3
e13_eV = convertUnits(&quot;energy: from atomic to eV&quot;, e13)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-4.805439152723064</code></pre><p>Apart from the (single-electron) energies, we can generate also the radial orbitals, i.e. the <span>$P(r)$</span> in the  non-relativistic theory or  <span>$P(r)$</span> and <span>$Q(r)$</span>  in the relativistic theory. Both, the relativistic and non-relativistic  orbitals, can be calculated by using the general (and analytically well-known) solutions of either the Dirac&#39;s  or Schrödinger&#39;s equation. </p><p>However, since all (radial) orbital functions are represented on some <code>Radial.Grid</code>, special care has to be taken  in order to define a proper grid, and which affects also all subsequent numerical computations as well as the  accuracy that can be obtained. To better understand the definition of the grid, let us ask for:</p><pre><code class="nohighlight hljs">? Radial.Grid</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Radial.Grid-examples" href="#JAC.Radial.Grid-examples"><code>JAC.Radial.Grid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  Radial.Grid</code>  ... defines a type for the radial grid which contains all information about the grid parameters, the genration                              of the B-spline basis as well as for performing radial integrations.</p><pre><code class="nohighlight hljs">** Physical grid parameter **
+ rnt        ::Float64           ... smalles grid point &gt; 0.
+ h          ::Float64           ... stepsize in the construction of the exponential grid.
+ hp         ::Float64           ... asymptotic stepsize of the log-lin grid.
+ NoPoints   ::Int64             ... No. of grid points so that r[NoPoints] coincides also 
                                        with the largest break point of the B-spline knot.
** B-spline grid parameters and break points **
+ tL         ::Array{Float64,1}  ... radial break points for the B-splines of the large c.
+ tS         ::Array{Float64,1}  ... radial break points for the B-splines of the small c.
+ ntL        ::Int64             ... number of break points in the t-grid of the large c.
+ ntS        ::Int64             ... number of break points in the t-grid of the small c.
+ orderL     ::Int64             ... B-spline order of large components.
+ orderS     ::Int64             ... B-spline order of small components.
+ nsL        ::Int64             ... number of B-splines for large components.
+ nsS        ::Int64             ... number of B-splines for small components.
+ orderGL    ::Int64             
    ... order of the Gauss-Lengedre integration if mesh == Radial.MeshGL(); this order also determines
        the (number of) break points by taking the orderGL-th point from the physical grid points.
** Radial mesh points **
+ meshType   ::Radial.AbstractMesh
+ r          ::Array{Float64,1}  ... radial grid points
+ rp         ::Array{Float64,1}  ... derivative of the radial grid at the grid points
+ rpor       ::Array{Float64,1}  ... rp over r
+ wr         ::Array{Float64,1}  
    ... integration weights for all grid points, for instance, GL weights.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>which shows the internal definition and the constructors to define such a grid. In practice, there are three (logical) levels that are considered and realized for each grid: </p><p>(i) The <strong>phenomenological grid</strong> definition that is based on our physics understanding and intuition of which grid is  appropriate to decribe a particular atomic property or process. Two currently implemented grid refers to an <em>exponential</em>  grid (with exponentially increasing stepsize) as appropriate for many bound-state computations and a <em>linear-logarithmic</em> grid that start exponentially but becomes linear in its stepsize for large values of <span>$r$</span>. Such a <em>linear-logarithmic</em>  grid is typically needed to describe electron ionization and capture processes as the incoming or outgoing electron waves  are <em>sinusoidal</em> and should be represented with a proper number of grid points, say 20-30, per period of the electron wave.  In JAC, the <em>phenomenologically</em> part of the grid is chosen (analogue as in GRASP) by the parameters <code>rnt</code>, <code>h</code>, <code>hp</code>  and <code>NoPoints</code> in the definition above. </p><p>(ii) The <em>phenomenological</em> definition of the grid is internally translated into a <strong>sequence of knots</strong> upon which the  B-spline primitives are defined. Here, each <code>nth</code> mesh point from the phenomenological is chosen to keep the number of  B-splines and the corresponding size of matrices (that need to be diagonalized) moderate. These knots are used to  define the B-splines and to determine the eigenvectors of all orbitals (within some given potential) but they are not  applied in order evaluate matrix elements or radial integrals.</p><p>(iii) The <em>phenomenological</em> grid and the definition of the B-splines (knots) are eventually combined into a  <strong>physical grid</strong> upon which all radial functions are represented. This physical grid resembles the phenomenological grid  but with modified grid points in between the <em>knots</em> of the B-spline grid (t-grid). Here the radial points and corresponding  weights are chosen due to a Gauss-Legendre distribution and goal to determine all radial integrals <em>exact</em> up to a  given <em>Gauss-Legendre order</em>.</p><p>The <strong>physical grid</strong> is thus defined by the three arrays <code>r</code> (the mesh points along <span>$r$</span>), <code>rp</code> (the derivatives d <code>r</code>/ dr),  <code>rpor</code> (the values rp / r) as well as <code>w</code> (the corresponding weights). All these arrays are of length  <code>nr</code> <span>$\approx$</span> <code>NoPoints</code> but not necessarely equal as the grid points <code>nr</code> are coupled to the underlying integration,  respectively, interpolation scheme. </p><p>In principle, this physical grid could chosen also on other <em>interpolation/integration</em> formulas, such as Gauss-Laguerre  or others, that have been utilized in atomic physics. All what is needed would be to adapt the intermediate grid point  and weights accordingly.</p><p>The clear distinction between the <strong>phenomenological grid</strong> and the <strong>physical grid</strong> help avoid that every new (radial)  operator as well as particular boundary condition of the radial orbital functions need to be treated independently within  the B-spline basis. Instead, a proper <em>interpolation/integration</em> formula should guarantee that all results are integrated  sufficiently accurate, and this is first of all tested by enlarging the number of grid point <code>NoPoint</code> –&gt; <code>nr</code></p><p>Here, we first apply an <em>exponential grid</em>, and which is appropriate below in order to compute various expectation values:</p><pre><code class="language-julia hljs">grid   = Radial.Grid(true, printout= true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Radial grid:  rnt = 2.0e-6,  h = 0.05,  hp = 0.0,  NoPoints = 392,  ntL = 69,  ntS = 71, orderL = 7,  orderS = 8,  nsL = 62,  nsS = 63,  mesh = JAC.Radial.MeshGL(), ...  
r:    [1.780504510281598e-8, 9.042759120177923e-8, 2.0787030685460475e-7]  ...  [564.4302351890452, 595.097239730825, 614.0606632064549]
wr:   [4.530145586285996e-8, 9.785739473901763e-8, 1.3358660616640612e-7]  ...  [34.882547080539766, 25.552825070730517, 11.829256033233948]
tS:   [0.0, 0.0, 0.0]  ...  [618.7099715607404, 618.7099715607404, 618.7099715607404]</code></pre><p>With this grid, the non-relativistic radial orbitals <span>$P(r)$</span> can be obtained either for a single <span>$r$</span>-value, for a list of  <span>$r$</span>-values as well as for all <span>$r$</span>-values on a given radial grid:</p><pre><code class="language-julia hljs">Pnr_1s = HydrogenicIon.radialOrbital(Shell(&quot;1s&quot;), Z, grid)
Pnr_2p = HydrogenicIon.radialOrbital(Shell(&quot;2p&quot;), Z, grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">392-element Vector{Float64}:
 8.895323125542194e-14
 2.2944426826828984e-12
 1.2124385701573003e-11
 3.434471347946261e-11
 6.787882523004707e-11
 1.0416489853450738e-10
 1.3047592028166753e-10
 1.4891535552172264e-10
 2.0078900763041305e-10
 3.010512642484143e-10
 ⋮
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0</code></pre><p>Here, the exponential tails of the radial orbitals are simply set to zero if <span>$|P| &lt; 1.0e-15$</span> (and similarly for <span>$|Q|$</span>).</p><p>Of course, we could plot the two functions <code>Pnr_1s</code> and <code>Pnr_2p</code> directly by some proper call of <code>PyPlot</code>, and if we give  the correct arrays of radial mesh points from above.</p><pre><code class="language-julia hljs">using Plots
plot(grid.r, [Pnr_1s, Pnr_2p],xlims=(0,1), xlabel = &quot;r (a.u.)&quot;, ylabel=&quot;Amplitude (a.u.)&quot;, label=[&quot;1s&quot; &quot;2p&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">WARNING: using Plots.grid in module Main conflicts with an existing identifier.
GKS: cannot open display - headless operation mode active</code></pre><p><img src="hdy-1.svg" alt/></p><p>We can also make use of this function to visualise the relativistic orbitals if we specify the total angular momentum  and generate the relativistic orbitals, which contain both the large and the small component.</p><pre><code class="language-julia hljs">setDefaults(&quot;standard grid&quot;, grid)
PQr_1s = HydrogenicIon.radialOrbital(Subshell(&quot;1s_1/2&quot;), Z, grid)
PQr_2p1 = HydrogenicIon.radialOrbital(Subshell(&quot;2p_1/2&quot;), Z, grid)
PQr_2p3 = HydrogenicIon.radialOrbital(Subshell(&quot;2p_3/2&quot;), Z, grid)
plot(grid.r, [PQr_1s,PQr_2p1, PQr_2p3],xlims=(0,1), xlabel = &quot;r (a.u.)&quot;, ylabel=&quot;Amplitude (a.u.)&quot;,
     label=[&quot;1s - Large component&quot; &quot;1s - Small component&quot; &quot;2p_1/2 - Large component&quot; &quot;2p_1/2 - Small component&quot; &quot;2p_3/2 - Large component&quot; &quot;2p_3/2 - Small component&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Re-) Define the standard grid with 392 grid points.</code></pre><p><img src="hdy-2.svg" alt/></p><p>In practice, using Pyplot is often quite tedious since all the specification of arrays, axes, labels, etc. need to  be given explicitly. To display the shape of such orbitals, a special plotting method is prepared in JAC that displays  one or several orbitals together. </p><pre><code class="nohighlight hljs">? Basics.plot</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Basics.plot-examples" href="#JAC.Basics.plot-examples"><code>JAC.Basics.plot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Basics.plot()</code>  ... plots various quantities, often in a new window.</p><ul><li><code>(&quot;radial potentials&quot;, potentials::Array{Radial.Potential,1}, grid::Radial.Grid; N::Int64 = 0)</code>     ... to plot one or more radial potentials, and where N::Int64 describes the number of grid points to be considered.       call:  using Plots; pyplot()    ... to access this method by plot(...)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><ul><li><p><code>(&quot;radial orbitals: large&quot;, orbitals::Array{Radial.Orbital,1}, grid::Radial.Grid; N::Int64 = 0)</code>     ... to plot the large component of one or more radial orbitals, and where N::Int64 describes the number of grid        points to be considered.</p></li><li><p><code>(&quot;radial orbitals: small&quot;, orbitals::Array{Radial.Orbital,1}, grid::Radial.Grid; N::Int64 = 0)</code>     ... to plot the small component of one or more radial orbitals.</p></li><li><p><code>(&quot;radial orbitals: both&quot;,  orbitals::Array{Radial.Orbital,1}, grid::Radial.Grid; N::Int64 = 0)</code>     ... to plot the large and small component of one or more radial orbitals.</p><p>call:  using Plots; pyplot()    ... to access this method by plot(...)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><ul><li><p><code>(&quot;spectrum: transition rates over energy&quot;, lines::Array{PhotoEmission.Line,1})</code>     ... to plot the transition rates of all lines as function of their transition energies. The plot is shown in a new        window but nothing is returned otherwise. <strong>Not yet implemented !</strong></p></li><li><p><code>(&quot;spectrum: oscillator strength over energy, emission&quot;, lines::Array{PhotoEmission.Line,1})</code> or   <code>(&quot;spectrum: oscillator strength over energy, absorption&quot;, lines::Array{PhotoEmission.Line,1})</code>    ... to plot the absorption oscillator strength of all lines as function of their transition energies. Again, a new        window is opened but nothing returned by this method. <strong>Not yet implemented !</strong></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><ul><li><code>(&quot;spectrum: transition rates over energy, Gaussian&quot;, lines::Array{PhotoEmission.Line,1}; widths=value::Float64)</code> or   <code>(&quot;spectrum: transition rates over energy, Lorentzian&quot;, lines::Array{PhotoEmission.Line,1}; widths=value::Float64)</code>   ... to plot the transition rates of all lines as function of their transition energies but with a Gaussian or Lorentzian        distribution. Again, a new window is opened but nothing returned by this method. It still need to be decided how        the widths (and, perhaps, other parameters) will be communicated to the method. <strong>Not yet implemented !</strong></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>This <code>Basics.plot</code> function (from the Basics module) accepts for instance a list of (relativistic) radial <code>Orbitals</code>:</p><pre><code class="nohighlight hljs">? Orbital</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Radial.Orbital-examples" href="#JAC.Radial.Orbital-examples"><code>JAC.Radial.Orbital</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  Radial.Orbital</code>       ... defines a type for a single-electron radial orbital function with a large and small component, and which can refer to         either the standard or an explicitly given grid due to the logical flag useStandardGrid. Bound-state orbitals with energy &lt; 0 are          distinguished from free-electron orbitals by the flag isBound.</p><pre><code class="nohighlight hljs">+ subshell        ::Subshell          ... Relativistic subshell.
+ isBound         ::Bool              ... Logical flag to distinguish between bound (true) and free-electron orbitals (false).
+ useStandardGrid ::Bool              ... Logical flag for using the standard grid (true) or an explicitly given grid (false).
+ energy          ::Float64           ... Single-electron energies of bound orbitals are always negative.
+ P               ::Array{Float64,1}  ... Large and ..
+ Q               ::Array{Float64,1}  ... small component of the radial orbital.
+ Pprime          ::Array{Float64,1}  ... dP/dr.
+ Qprime          ::Array{Float64,1}  ... dQ/dr.
+ grid            ::Array{Float64,1}  ... explic. defined radial grid array for P, Q, if StandardGrid = false.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>Of course, the main purpose of this <code>plot</code> method is to display and compare a number of generated orbitals, either for  getting physical insight or just for test purposes. We can make use of the same <code>plot</code> method also for the  non-relativistic  <code>Pnr_1s</code><span>$(r)$</span>  orbital if we assign this array as large component of a relativistic orbital and  specify the additional quantum numbers. Moreover, we here first internally to define a standard grid as well as  such an (instance of the) Orbital by using its standard constructor, and by setting the small  <span>$Q(r)$</span> component  as well as <span>$dP/dr$</span> and <span>$dQ/dr$</span> simply to zero:</p><pre><code class="language-julia hljs">setDefaults(&quot;standard grid&quot;, grid)
Qnr_1s   = Pprime = Qprime = zeros( length(Pnr_1s) )
nrOrb_1s = Orbital( Subshell(&quot;1s_1/2&quot;), true, true, e1s, Pnr_1s, Qnr_1s, Pprime, Qprime, Radial.Grid())
typeof(nrOrb_1s)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Orbital</code></pre><p>We could also compute a relativistic <span>$1s_{1/2}$</span> orbital on the given grid and plot the two <span>$1s$</span>-orbitals together;  while the large components of these orbitals coincide of course, due to its special construction via the non-relativistic  orbitals, the small compoments differ. Note that one need to use the standard REPL in order to display these functions  in some separate window.</p><pre><code class="language-julia hljs">Orb_1s = HydrogenicIon.radialOrbital(Subshell(&quot;1s_1/2&quot;), Z, grid)
e1s_1 = HydrogenicIon.energy(Subshell(&quot;1s_1/2&quot;), Z)
rOrb_1s = Orbital( Subshell(&quot;1s_1/2&quot;), true, true, e1s_1, Orb_1s[1], Orb_1s[2], Pprime, Qprime, Radial.Grid())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Bound-state orbital 1s_1/2 with energy -162.70485811496013 a.u. is defined with 392 (grid) points on the standard grid: 
Large component P: [3.094976712530428e-6, 1.5498862894779233e-5, 3.537189759693442e-5, 5.926504419660713e-5, 8.30717237172039e-5, 0.00010271653265137339, 0.00011484727355055586, 0.0001226242231422872, 0.00014220454983176329, 0.00017382034714231485  …  0.0003400832988479155, 0.0003846215960535446, 0.0004384081093685234, 0.0004921362282859167, 0.0005365367822203975, 0.0005639761006343588, 0.0005802444216048941, 0.000619152996620868, 0.0006820292546595882, 0.0007579783496550785]  ...  [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Small component Q: [2.0415063278116693e-7, 1.0223348868983198e-6, 2.3331985820277163e-6, 3.9092366109110816e-6, 5.479571104502363e-6, 6.7753805878302265e-6, 7.5755476523015185e-6, 8.088530245621624e-6, 9.380086355732164e-6, 1.1465525319036404e-5  …  2.243255026023918e-5, 2.5370382238332118e-5, 2.8918244386660844e-5, 3.246225472790821e-5, 3.5391000894191195e-5, 3.720095125492078e-5, 3.827404108043568e-5, 4.084052572568854e-5, 4.498796496603807e-5, 4.999771374369833e-5]  ...  [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Pprime:            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  ...  [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Qprime:            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  ...  [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Defined on Grid:   [1.780504510281598e-8, 9.042759120177923e-8, 2.0787030685460475e-7]  ...  [527.353759459587, 564.4302351890452, 595.097239730825, 614.0606632064549]
</code></pre><pre><code class="language-julia hljs">plot(&quot;radial orbitals: both&quot;, Orbital[nrOrb_1s, rOrb_1s], grid; N = 230)</code></pre><p><img src="hdy-3.svg" alt/></p><p>We can use these orbitals to quickly evaluate some overlap integrals and <span>$\langle r^k \rangle$</span> expectation values;  for this, we make use of the non-relativistic <span>$2p$</span> radial orbital <code>Pnr_2p</code> from above and compute the normalization   and <span>$\langle r \rangle$</span> expectation values:</p><pre><code class="language-julia hljs">N_1s = RadialIntegrals.overlap(Pnr_1s, Pnr_1s, grid)
N_2p = RadialIntegrals.overlap(Pnr_2p, Pnr_2p, grid)
r_exp_1s = RadialIntegrals.rkDiagonal(1, Pnr_1s, Pnr_1s,grid)
r_exp_2p = RadialIntegrals.rkDiagonal(1, Pnr_2p, Pnr_2p,grid)
println(&quot;N_1s = $(N_1s)&quot;,&quot;\n&quot;,&quot;N_2p = $(N_2p)&quot;,&quot;\n&quot;,&quot;r_exp_1s = $(r_exp_1s)&quot;,&quot;\n&quot;,&quot;r_exp_2p = $(r_exp_2p)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">N_1s = 0.999999999999998
N_2p = 0.9999999999999959
r_exp_1s = 0.08333333333333318
r_exp_2p = 0.2777777777777762</code></pre><p>As we can see the radial orbitals are already normalized by construction and the expectation values match with the  analytic values of <span>$\langle r \rangle_{nl} = \frac{1}{2Z}[3n²-l(l+1)]$</span>. </p><p>For the sake of simplicity, all hydrogenic computations are performed for a point-like nucleus. For many-electron  computations, in constrast, a more realistic nucleus can be taken into accout by selecting a proper nuclear model.  See the tutorial: Define the nuclear model parameters   or   <code>? Nuclear.Model</code>  ... for further details.</p><pre><code class="nohighlight hljs"> ? Nuclear.Model</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Nuclear.Model" href="#JAC.Nuclear.Model"><code>JAC.Nuclear.Model</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  Nuclear.Model</code>  ... defines a type for the nuclear model, i.e. for its form and parameters.</p><pre><code class="nohighlight hljs">+ Z        ::Float64         ... nuclear charge
+ model    ::String          ... identifier of the nuclear model: {&quot;Fermi&quot;, &quot;Point&quot;, &quot;Uniform&quot;}
+ mass     ::Float64         ... atomic mass
+ radius   ::Float64         ... (root-mean square) radius of a uniform or Fermi-distributed nucleus
+ spinI    ::AngularJ64      ... nuclear spin I, must be &gt;= 0
+ mu       ::Float64         ... magnetic dipole moment in Bohr magnetons
+ Q        ::Float64         ... electric quadrupole moment</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>If we would like to compute a relativistic orbital by taking into account the type of the nucleus, we can simply  define a nuclear model: </p><pre><code class="language-julia hljs">Nucleus = Model(Z, &quot;Fermi&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Fermi nuclear model for Z = 18.0 with mass = 37.62, radius R = 3.37121133160794 fm and nuclear spin I = 0, dipole moment mu = 0.0 and quadrupole moment Q = 0.0.</code></pre><p>and set it as an argument value of the radialOrbital-function. By comparing the analytic orbitals which are based on a  point like nucleus and the orbitals taking into account a fermi distributed nucleus one can see, that the influence of  the nucleus is negligible for large r. However by looking at the functions at a closer angle the influence of the nucleus  is well visible for small r. </p><pre><code class="language-julia hljs">nuc_orb_1s = HydrogenicIon.radialOrbital(Subshell(&quot;1s_1/2&quot;),Nucleus, grid)
plot(&quot;radial orbitals: both&quot;, [nuc_orb_1s,rOrb_1s], grid; N = 230)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">orb_dic = Dict{Subshell, Orbital}(1s_1/2 =&gt; Bound-state orbital 1s_1/2 with energy -162.70453750775806 a.u. is defined with 289 (grid) points on the standard grid:
Large component P: [2.998884160041346e-6, 1.4962882223453142e-5, 3.38370070539286e-5, 5.65481667770675e-5, 7.946309099691134e-5, 9.85662540997511e-5, 0.00011041528290382263, 0.00011802306110324472, 0.0001371920208690856, 0.00016811919454262335, 0.00020534330051927548, 0.0002424295975698944, 0.00027306740000979774, 0.00029201893966173054, 0.00030326528206375835, 0.00033020030440592766, 0.0003738464930616773, 0.0004267397052474151, 0.000479704513083628, 0.0005235134981371699, 0.0005505879969653036, 0.0005666374846013176, 0.0006050108590940329, 0.0006669838480358902, 0.000741802522872115]  ...  [-1.2306479945984099e-6, -1.0395998039452091e-6, -9.1013556273329e-7, -5.854329265555748e-7, -1.1027398480626908e-7, 2.698538874352334e-7, 4.251828174170293e-7, 4.286103607930014e-7, 3.951608450789422e-7, 3.6718299926037005e-7, 2.860444090532438e-7]
Small component Q: [8.923831919948077e-5, 0.0002179616113752468, 6.87530227189246e-5, -0.0001225138667608386, -0.00014284564717394866, -7.57569768938641e-5, -2.249154647983172e-5, 1.090373416596715e-5, 8.1016698623069e-5, 0.00013101963498832203, 9.639054032227122e-5, 1.3021928548318662e-5, -5.241345050896145e-5, -8.203917925484463e-5, -9.464570861698413e-5, -0.00010936753377815706, -9.300575326439295e-5, -3.374565272969048e-5, 3.151853289940511e-5, 7.042676981001569e-5, 8.423285917855076e-5, 8.854862343727601e-5, 8.795283489369258e-5, 6.129723333265915e-5, 8.176759502643158e-6]  ...  [-2.3463779897553634e-7, -3.469428222211691e-7, -3.952733742652042e-7, -4.570147647357441e-7, -4.2016618981620537e-7, -2.3710783009964083e-7, -1.6591337983417842e-8, 1.3318702369322605e-7, 1.9923827104065653e-7, 2.2779096238461347e-7, 2.6471979092221065e-7]
Pprime:            [167.5468822873525, 162.50204898766475, 159.74555032610013, 160.5410196543992, 162.183044380288, 163.0309773299256, 163.25221121595385, 163.2939921598198, 163.15273323784984, 162.54108613102338, 161.77839961953515, 161.3748449772077, 161.354430449855, 161.44869539775186, 161.53011686720222, 161.7674751007888, 162.16693000051885, 162.5048714355066, 162.60370379044062, 162.5274232935217, 162.43303676352662, 162.3671539552907, 162.19745124407666, 161.94326782480496, 161.75148811747226]  ...  [2.370577972655382e-6, 3.006602598729128e-6, 3.1988685164532267e-6, 3.242434111717168e-6, 2.5587624095908862e-6, 1.341414117303213e-6, 3.162252199731572e-7, -2.265450264329461e-7, -4.3081671815281183e-7, -5.129109576977325e-7, -6.169463341540413e-7]
Qprime:            [4203.62730243824, -65.60231528398631, -1757.0312305288546, -742.9597026502469, 350.62919878267303, 712.6209939489569, 734.1446106821752, 693.5744465474296, 481.52860499157487, 49.14070803879727, -304.3950250495911, -379.9223990709183, -293.98098519708924, -208.3658037165793, -153.47648159102894, -25.20646411956681, 133.3955269857328, 209.18612389018574, 177.6028629794964, 107.50324427003338, 58.122667557956625, 29.395695178228483, -32.38881073877824, -99.40565745119035, -120.12092023330935]  ...  [-1.8713048953142516e-6, -1.3265830568763783e-6, -9.981770249897033e-7, -2.5860832268965154e-7, 6.441147414173148e-7, 1.129453890717056e-6, 1.065309091112352e-6, 7.740878027574579e-7, 5.512165148783109e-7, 4.1658471039223415e-7, 1.1284508763111432e-7]
Defined on Grid:   [1.780504510281598e-8, 9.042759120177923e-8, 2.0787030685460475e-7]  ...  [3.122781725284572, 3.2222926388844075, 3.2813114308995166, 3.422524139119911]
)</code></pre><p><img src="hdy-4.svg" alt/></p><pre><code class="language-julia hljs">plot(&quot;radial orbitals: both&quot;, [nuc_orb_1s,rOrb_1s], grid; N = 75)</code></pre><h2 id="Compute-the-low-lying-levels-of-C{2}-1s2-(2s2-2s2p-2p2):-\\;-SCF-and-configuration-interaction-calculations"><a class="docs-heading-anchor" href="#Compute-the-low-lying-levels-of-C{2}-1s2-(2s2-2s2p-2p2):-\\;-SCF-and-configuration-interaction-calculations">Compute the low-lying levels of <span>$C^{2+} 1s^2 (2s^2 + 2s2p + 2p^2)$</span>: <span>$\;$</span> SCF and configuration interaction calculations</a><a id="Compute-the-low-lying-levels-of-C{2}-1s2-(2s2-2s2p-2p2):-\\;-SCF-and-configuration-interaction-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-the-low-lying-levels-of-C{2}-1s2-(2s2-2s2p-2p2):-\\;-SCF-and-configuration-interaction-calculations" title="Permalink"></a></h2><pre><code class="language-julia hljs">using JAC</code></pre><p>The low-lying levels (level structure) of beryllium-like ions, and especially of C<span>$^{2+}$</span>, has been calculated in  many case studies in the literature. While the level structure of these ions is still quite simple, it exhibits a  considerable admixture of the <span>$2s^22p^2$</span> configuration already for the <span>$1s^{2}2s^{2}$</span> <span>$^{1}S_{0}$</span> ground level.</p><p>We here show how the low-lying levels of C<span>$^{2+}$</span> can be readily calculated in JAC by either following the default  settings or by specifying further details for both, the SCF and configuration-interaction (CI) computations. As usual,  we first need to specify a radial grid as well as the nuclear model for the subsequent computations:</p><pre><code class="language-julia hljs">grid     = Radial.Grid(true)
nucModel = Nuclear.Model(6., &quot;Fermi&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Fermi nuclear model for Z = 6.0 with mass = 12.18, radius R = 2.4934845703596404 fm and nuclear spin I = 0, dipole moment mu = 0.0 and quadrupole moment Q = 0.0.</code></pre><p>For a <em>quick</em> computation of the ground level of C<span>$^{2+}$</span> ions, we can simply use the <strong>standard settings</strong> as given  by <code>AsfSettings()</code>:</p><pre><code class="language-julia hljs">multiplet     = SelfConsistent.performSCF([Configuration(&quot;1s^2 2s^2&quot;)], nucModel, grid, AsfSettings());</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  -----------------------------------------------------------------------------
   Index    Subshell     Energies [a.u.]    Dirac-E  [a.u.]     Delta-E / |E|
  -----------------------------------------------------------------------------
      1      1s_1/2      -1.80086331e+01    -1.80086350e+01    +1.03994916e-07
      2      2s_1/2      -4.50269964e+00    -4.50269857e+00    -2.38959499e-07
      3      3s_1/2      -2.00098006e+00    -2.00095940e+00    -1.03240049e-05
      4      4s_1/2      -1.12562939e+00    -1.12543844e+00    -1.69632831e-04
      5      5s_1/2      -7.21116908e-01    -7.20234830e-01    -1.22321194e-03
      6      6s_1/2      -5.29936446e-01    -5.00139888e-01    -5.62266634e-02
      7      7s_1/2      -4.90049428e-01    -3.67436826e-01    -2.50204560e-01
      :       :
     61     61s_1/2      +1.07252829e+09    -4.83755953e-03    +1.00000000e+00
     62     62s_1/2      +2.82418557e+09    -4.68276538e-03    +1.00000000e+00
  -----------------------------------------------------------------------------
settings.scField = JAC.Basics.DFSField(1.0)

  Eigenenergies:

  Level  J Parity          Hartrees                    eV                   [eV]

     1    0 +     -3.641932007141357e+01    -9.910201770491686e+02    -9.910201770491686e+02

  Energy of each level relative to lowest level:

  Level  J Parity          Hartrees                    eV                   [eV]</code></pre><p>... and, similarly, also for the 10 lowest levels of C<span>$^{2+}$</span> ions as they arise from the <span>$C^{2+} 1s^2 (2s^2 + 2s2p + 2p^2)$</span> configurations:</p><pre><code class="language-julia hljs">multiplet     = SelfConsistent.performSCF([Configuration(&quot;1s^2 2s^2&quot;), Configuration(&quot;1s^2 2s 2p&quot;), Configuration(&quot;1s^2 2p^2&quot;)],
                              nucModel, grid, AsfSettings());</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  -----------------------------------------------------------------------------
   Index    Subshell     Energies [a.u.]    Dirac-E  [a.u.]     Delta-E / |E|
  -----------------------------------------------------------------------------
      1      1s_1/2      -1.80086331e+01    -1.80086350e+01    +1.03994916e-07
      2      2s_1/2      -4.50269964e+00    -4.50269857e+00    -2.38959499e-07
      3      3s_1/2      -2.00098006e+00    -2.00095940e+00    -1.03240049e-05
      4      4s_1/2      -1.12562939e+00    -1.12543844e+00    -1.69632831e-04
      5      5s_1/2      -7.21116908e-01    -7.20234830e-01    -1.22321194e-03
      6      6s_1/2      -5.29936446e-01    -5.00139888e-01    -5.62266634e-02
      7      7s_1/2      -4.90049428e-01    -3.67436826e-01    -2.50204560e-01
      :       :
     61     61s_1/2      +1.07252829e+09    -4.83755953e-03    +1.00000000e+00
     62     62s_1/2      +2.82418557e+09    -4.68276538e-03    +1.00000000e+00
  -----------------------------------------------------------------------------
  -----------------------------------------------------------------------------
   Index    Subshell     Energies [a.u.]    Dirac-E  [a.u.]     Delta-E / |E|
  -----------------------------------------------------------------------------
      1      2p_1/2      -4.50269888e+00    -4.50269857e+00    -6.91701387e-08
      2      3p_1/2      -2.00096714e+00    -2.00095940e+00    -3.86903735e-06
      3      4p_1/2      -1.12549933e+00    -1.12543844e+00    -5.41023530e-05
      4      5p_1/2      -7.20400487e-01    -7.20234830e-01    -2.29951315e-04
      5      6p_1/2      -5.00841849e-01    -5.00139888e-01    -1.40156319e-03
      6      7p_1/2      -3.91479761e-01    -3.67436826e-01    -6.14155231e-02
      7      8p_1/2      -3.49594545e-01    -2.81311119e-01    -1.95321771e-01
      :       :
     61     62p_1/2      +1.31159793e+09    -4.68276538e-03    +1.00000000e+00
     62     63p_1/2      +6.75311123e+09    -4.53528382e-03    +1.00000000e+00
  -----------------------------------------------------------------------------
  -----------------------------------------------------------------------------
   Index    Subshell     Energies [a.u.]    Dirac-E  [a.u.]     Delta-E / |E|
  -----------------------------------------------------------------------------
      1      2p_3/2      -4.50053984e+00    -4.50053930e+00    -1.19777072e-07
      2      3p_3/2      -2.00033044e+00    -2.00031959e+00    -5.42476571e-06
      3      4p_3/2      -1.12535222e+00    -1.12516853e+00    -1.63226680e-04
      4      5p_3/2      -7.21810564e-01    -7.20096642e-01    -2.37447501e-03
      5      6p_3/2      -5.88521709e-01    -5.00059921e-01    -1.50311851e-01
      6      7p_3/2      -4.94086009e-01    -3.67386470e-01    -2.56432153e-01
      7      8p_3/2      -3.59118075e-01    -2.81277385e-01    -2.16755142e-01
      :       :
     61     62p_3/2      +1.75386123e+09    -4.68269292e-03    +1.00000000e+00
     62     63p_3/2      +6.75822628e+09    -4.53521476e-03    +1.00000000e+00
  -----------------------------------------------------------------------------
settings.scField = JAC.Basics.DFSField(1.0)
&gt;&gt;&gt; Sign changed for orbital 2p_3/2

  Eigenenergies:

  Level  J Parity          Hartrees                    eV                   [eV]

     1    0 +     -3.648596893065901e+01    -9.928337848858889e+02    -9.928337848858889e+02
     2    0 -     -3.624303134670400e+01    -9.862231165101230e+02    -9.862231165101230e+02
     3    1 -     -3.624287306106216e+01    -9.862188093384214e+02    -9.862188093384214e+02
     4    2 -     -3.624255595204814e+01    -9.862101803626306e+02    -9.862101803626306e+02
     5    1 -     -3.597168309684437e+01    -9.788393545373413e+02    -9.788393545373413e+02
     6    0 +     -3.585249805874401e+01    -9.755961644577839e+02    -9.755961644577839e+02
     7    1 +     -3.585234658730297e+01    -9.755920427099306e+02    -9.755920427099306e+02
     8    2 +     -3.585204525341215e+01    -9.755838429971067e+02    -9.755838429971067e+02
     9    2 +     -3.577601908774491e+01    -9.735150656555151e+02    -9.735150656555151e+02
    10    0 +     -3.559491143203561e+01    -9.685868753248319e+02    -9.685868753248319e+02

  Energy of each level relative to lowest level:

  Level  J Parity          Hartrees                    eV                   [eV]

     2    0 -     2.429375839550119e-01    6.610668375765986e+00    6.610668375765986e+00
     3    1 -     2.430958695968570e-01    6.614975547467658e+00    6.614975547467658e+00
     4    2 -     2.434129786108699e-01    6.623604523258383e+00    6.623604523258383e+00
     5    1 -     5.142858338146397e-01    1.399443034854773e+01    1.399443034854773e+01
     6    0 +     6.334708719150015e-01    1.723762042810508e+01    1.723762042810508e+01
     7    1 +     6.336223433560448e-01    1.724174217595832e+01    1.724174217595832e+01
     8    2 +     6.339236772468624e-01    1.724994188878226e+01    1.724994188878226e+01
     9    2 +     7.099498429140993e-01    1.931871923037392e+01    1.931871923037392e+01
    10    0 +     8.910574986234039e-01    2.424690956105706e+01    2.424690956105706e+01</code></pre><p>From the comparison of the two ground-state energies, we see that the admixture of the <span>$2p^2$</span> configuration has lowered  the (total) ground state energy by about 1.8 eV, a rather remarkable admixture, as the <span>$\: ^3P_0$</span> is just 6.6 eV above of the  ground level.</p><p>Further control about these electronic computations can be obtained by modifying the (so-called) <strong>settings</strong>.  In general, all computations of the electronic structure, properties and processes as well as all more advanced computations  can be controlled quite in details by various settings that are associated to the different computational requests.  The SCF and configuration interaction calculations are controlled by <code>AsfSettings</code> that specify all details for the  generation of the ASF. We can first have a look at the internal representation of these settings:</p><pre><code class="nohighlight hljs">? AsfSettings</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.ManyElectron.AsfSettings-examples" href="#JAC.ManyElectron.AsfSettings-examples"><code>JAC.ManyElectron.AsfSettings</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  ManyElectron.AsfSettings</code>       ... a struct for defining the settings for the atomic state functions, i.e. the self-consistent-field (SCF)          and CI computations</p><pre><code class="nohighlight hljs">+ generateScf          ::Bool                   ... True, if a SCF need to be generated, and false otherwise 
                                                    (frozen orbitals).
+ eeInteraction        ::AbstractEeInteraction  ... Specify the e-e interaction to be included into the SCF 
                                                    computations.
+ scField              ::AbstractScField        ... Specify the self-consistent field, for instance, 
                                                    Basics.ALField(), etc.
+ startScfFrom         ::AbstractStartOrbitals  ... Specify the orbitals to start the SCF computations
+ maxIterationsScf     ::Int64                  ... maximum number of SCF iterations
+ accuracyScf          ::Float64                ... convergence criterion for the SCF field.
+ shellSequenceScf     ::Array{Subshell,1}      ... Sequence of subshells to be optimized.
+ frozenSubshells      ::Array{Subshell,1}      ... Sequence of subshells to be kept frozen.

+ eeInteractionCI      ::AbstractEeInteraction  ... Specify the e-e interaction to be included into the 
                                                    CI computations.
+ qedModel             ::AbstractQedModel       ... model for estimating QED corrections {NoneQed(), 
                                                    QedPetersburg(), QedSydney()}.
+ jjLS                 ::LSjjSettings           ... settings to control a jj-LS transformation of atomic 
                                                    level, if requested.
+ levelSelectionCI     ::LevelSelection         ... Specifies the selected levels, if any.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>... as well as how the standard settings are presently defined:</p><pre><code class="language-julia hljs">defaultAsfSettings = AsfSettings()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">generateScf:          true  
eeInteraction:        CoulombInteraction()  
scField:              JAC.Basics.DFSField(1.0)  
startScfFrom:         StartFromHydrogenic()  
maxIterationsScf:     24  
accuracyScf:          1.0e-6  
shellSequenceScf:     Subshell[]  
frozenSubshells:      Subshell[]  
eeInteractionCI:      CoulombInteraction()  
qedModel :            NoneQed()  
jjLS:                 false  
levelSelectionCI:     Inactive LevelSelection.  
</code></pre><p>From this list, we easily see that the self-consistent field is by default based on a <em>(mean) Dirac-Fock-Slater</em>  potential, a choice which we could overwrite by <code>meanCH</code> or any pre-defined potential. At present, however,  no full treatment of the exchange interaction has yet been implemented in this first release of the program.  The standard settings also show that the SCF is usually based on just the lowest level (cf. <code>levelScf</code>) as well as  on the accuracy <code>1.0e-6</code> to terminate the SCF computations. Moreover, the individual orbitals are improved due  to the standard subshell order (cf. <code>shellSequenceScf</code>).</p><p>For the CI parameters, the treatment of the Breit and QED interaction is of particular interest. At present, the  defaults does not included neither Breit interactions nor QED. Such QED estimates can either be neglected (<code>NoneQed()</code>)  or estimated by using an effective Hamiltonian approach due to Shabaev and coworkers  (<code>QedPetersburg()</code>) or  effective potential approach (<code>QedSydney()</code>; Flambaum et al.) However, further tests need to be done to better  understand the reliability of these QED estimates to the level structure and state represetation of the ASF.</p><p>As seen from the settings above, moreover, there are special features in order to <em>select</em> individual levels for  the CI computations, either in terms of their (relative) level No within the given multiplet or in terms of their  <em>level symmetry</em>, i.e. their total angular momentum and parity, respectively. The  <code>levelSelectionCI::LevelSelection</code>  here tells whether (and which) selections were made; apparently, no selection of level numbers of symmetries is  made by default though this can be overwritten. The selection of individual symmetries, in particular, may considerably reduced the computational effort as the Hamiltonian matrix need then to be calculated only for the selected symmetries.</p><p>In principle, these standard settings can be easily <em>re-defined</em> within the code by simply modifying the constructor  <code>AsfSetings()</code> with no additional arguments. Alternatively, we can easily <em>overwrite</em> those parameters in some given  (instance of) <code>AsfSetting</code> which we just wish to modify. This is achieved by</p><pre><code class="language-julia hljs">asfSettings = AsfSettings(defaultAsfSettings; generateScf=true, jjLS=LSjjSettings(true),
              levelSelectionCI=LevelSelection(true, symmetries=[LevelSymmetry(0,&quot;+&quot;), LevelSymmetry(1,&quot;-&quot;)]) )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">generateScf:          true  
eeInteraction:        CoulombInteraction()  
scField:              JAC.Basics.DFSField(1.0)  
startScfFrom:         StartFromHydrogenic()  
maxIterationsScf:     24  
accuracyScf:          1.0e-6  
shellSequenceScf:     Subshell[]  
frozenSubshells:      Subshell[]  
eeInteractionCI:      CoulombInteraction()  
qedModel :            NoneQed()  
jjLS:                 true  
levelSelectionCI:     LevelSelection:  indices = Int64[];    symmetries = LevelSymmetry[0 +, 1 -].  
</code></pre><pre><code class="language-julia hljs">multiplet     = SelfConsistent.performSCF([Configuration(&quot;1s^2 2s^2&quot;), Configuration(&quot;1s^2 2s 2p&quot;),
                               Configuration(&quot;1s^2 2p^2&quot;), Configuration(&quot;1s^2 3s^2&quot;),
                               Configuration(&quot;1s^2 3p^2&quot;)],  nucModel, grid, asfSettings);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  -----------------------------------------------------------------------------
   Index    Subshell     Energies [a.u.]    Dirac-E  [a.u.]     Delta-E / |E|
  -----------------------------------------------------------------------------
      1      1s_1/2      -1.80086331e+01    -1.80086350e+01    +1.03994916e-07
      2      2s_1/2      -4.50269964e+00    -4.50269857e+00    -2.38959499e-07
      3      3s_1/2      -2.00098006e+00    -2.00095940e+00    -1.03240049e-05
      4      4s_1/2      -1.12562939e+00    -1.12543844e+00    -1.69632831e-04
      5      5s_1/2      -7.21116908e-01    -7.20234830e-01    -1.22321194e-03
      6      6s_1/2      -5.29936446e-01    -5.00139888e-01    -5.62266634e-02
      7      7s_1/2      -4.90049428e-01    -3.67436826e-01    -2.50204560e-01
      :       :
     61     61s_1/2      +1.07252829e+09    -4.83755953e-03    +1.00000000e+00
     62     62s_1/2      +2.82418557e+09    -4.68276538e-03    +1.00000000e+00
  -----------------------------------------------------------------------------
  -----------------------------------------------------------------------------
   Index    Subshell     Energies [a.u.]    Dirac-E  [a.u.]     Delta-E / |E|
  -----------------------------------------------------------------------------
      1      2p_1/2      -4.50269888e+00    -4.50269857e+00    -6.91701387e-08
      2      3p_1/2      -2.00096714e+00    -2.00095940e+00    -3.86903735e-06
      3      4p_1/2      -1.12549933e+00    -1.12543844e+00    -5.41023530e-05
      4      5p_1/2      -7.20400487e-01    -7.20234830e-01    -2.29951315e-04
      5      6p_1/2      -5.00841849e-01    -5.00139888e-01    -1.40156319e-03
      6      7p_1/2      -3.91479761e-01    -3.67436826e-01    -6.14155231e-02
      7      8p_1/2      -3.49594545e-01    -2.81311119e-01    -1.95321771e-01
      :       :
     61     62p_1/2      +1.31159793e+09    -4.68276538e-03    +1.00000000e+00
     62     63p_1/2      +6.75311123e+09    -4.53528382e-03    +1.00000000e+00
  -----------------------------------------------------------------------------
  -----------------------------------------------------------------------------
   Index    Subshell     Energies [a.u.]    Dirac-E  [a.u.]     Delta-E / |E|
  -----------------------------------------------------------------------------
      1      2p_3/2      -4.50053984e+00    -4.50053930e+00    -1.19777072e-07
      2      3p_3/2      -2.00033044e+00    -2.00031959e+00    -5.42476571e-06
      3      4p_3/2      -1.12535222e+00    -1.12516853e+00    -1.63226680e-04
      4      5p_3/2      -7.21810564e-01    -7.20096642e-01    -2.37447501e-03
      5      6p_3/2      -5.88521709e-01    -5.00059921e-01    -1.50311851e-01
      6      7p_3/2      -4.94086009e-01    -3.67386470e-01    -2.56432153e-01
      7      8p_3/2      -3.59118075e-01    -2.81277385e-01    -2.16755142e-01
      :       :
     61     62p_3/2      +1.75386123e+09    -4.68269292e-03    +1.00000000e+00
     62     63p_3/2      +6.75822628e+09    -4.53521476e-03    +1.00000000e+00
  -----------------------------------------------------------------------------
settings.scField = JAC.Basics.DFSField(1.0)

  Eigenenergies:

  Level  J Parity          Hartrees                    eV                   [eV]

     1    0 +     -3.648798247813691e+01    -9.928885763035797e+02    -9.928885763035797e+02
     2    1 -     -3.624410615291826e+01    -9.862523634769160e+02    -9.862523634769160e+02
     3    1 -     -3.596230472421729e+01    -9.785841560195463e+02    -9.785841560195463e+02
     4    0 +     -3.584833202046239e+01    -9.754828007819285e+02    -9.754828007819285e+02
     5    0 +     -3.557520093359942e+01    -9.680505253432382e+02    -9.680505253432382e+02
     6    0 +     -3.407634141250472e+01    -9.272644803249779e+02    -9.272644803249779e+02
     7    0 +     -3.390434882134372e+01    -9.225843235343160e+02    -9.225843235343160e+02
     8    0 +     -3.379320402360886e+01    -9.195599195390378e+02    -9.195599195390378e+02

  Energy of each level relative to lowest level:

  Level  J Parity          Hartrees                    eV                   [eV]

     2    1 -     2.438763252186504e-01    6.636212826663757e+00    6.636212826663757e+00
     3    1 -     5.256777539196236e-01    1.430442028403344e+01    1.430442028403344e+01
     4    0 +     6.396504576745272e-01    1.740577552165123e+01    1.740577552165123e+01
     5    0 +     9.127815445374949e-01    2.483805096034160e+01    2.483805096034160e+01
     6    0 +     2.411641065632196e+00    6.562409597860184e+01    6.562409597860184e+01
     7    0 +     2.583633656793189e+00    7.030425276926367e+01    7.030425276926367e+01
     8    0 +     2.694778454528056e+00    7.332865676454193e+01    7.332865676454193e+01</code></pre><p>We finish this (simple) tutorial by enlarging the configuration basis for the low-lying levels but by restricting  the CI computations to the level symmetries <span>$J^P = 0^+$</span> and <span>$1^-$</span>. This is achieved by specifying the settings to:</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="demos.html">« Demos</a><a class="docs-footer-nextpage" href="news.html">News »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 24 April 2025 13:24">Thursday 24 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
