<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Basics · JAC.jl</title><meta name="title" content="API Basics · JAC.jl"/><meta property="og:title" content="API Basics · JAC.jl"/><meta property="twitter:title" content="API Basics · JAC.jl"/><meta name="description" content="Documentation for JAC.jl."/><meta property="og:description" content="Documentation for JAC.jl."/><meta property="twitter:description" content="Documentation for JAC.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">JAC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="getting-started.html">Getting Started</a></li><li><a class="tocitem" href="demos.html">Demos</a></li><li><a class="tocitem" href="examples.html">Examples</a></li><li><a class="tocitem" href="news.html">News</a></li><li><a class="tocitem" href="api-atomic.html">API Atomic computations</a></li><li><a class="tocitem" href="api-processes.html">API Atomic processes</a></li><li><a class="tocitem" href="api-properties.html">API Atomic properties</a></li><li class="is-active"><a class="tocitem" href="api-basics.html">API Basics</a><ul class="internal"><li><a class="tocitem" href="#Angular-momentum"><span>Angular momentum</span></a></li><li><a class="tocitem" href="#Atomic-interaction-strength"><span>Atomic interaction strength</span></a></li><li><a class="tocitem" href="#Basics:-data-types"><span>Basics: data types</span></a></li><li><a class="tocitem" href="#Basics:-functions"><span>Basics: functions</span></a></li><li><a class="tocitem" href="#Basics:-compute-and-generate"><span>Basics: compute &amp; generate</span></a></li><li><a class="tocitem" href="#B-Spline-basis"><span>B-Spline basis</span></a></li><li><a class="tocitem" href="#Electron-continuum"><span>Electron continuum</span></a></li><li><a class="tocitem" href="#Hydrogenic-ions"><span>Hydrogenic ions</span></a></li><li><a class="tocitem" href="#Spin-angular-coefficients"><span>Spin angular coefficients</span></a></li></ul></li><li><a class="tocitem" href="api-cascades.html">API Cascade computations</a></li><li><a class="tocitem" href="api-empirical.html">API Empirical computations</a></li><li><a class="tocitem" href="api-plasma.html">API Plasma computations</a></li><li><a class="tocitem" href="api-racah.html">API Racah algebra</a></li><li><a class="tocitem" href="reference.html">Bibliography to JAC</a></li><li><a class="tocitem" href="getting-involved.html">Getting involved</a></li><li><a class="tocitem" href="contributors.html">Contributors</a></li><li><a class="tocitem" href="license.html">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api-basics.html">API Basics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api-basics.html">API Basics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/OpenJAC/JAC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/OpenJAC/JAC.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Angular-momentum"><a class="docs-heading-anchor" href="#Angular-momentum">Angular momentum</a><a id="Angular-momentum-1"></a><a class="docs-heading-anchor-permalink" href="#Angular-momentum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.CL_reduced_me-Tuple{Subshell, Int64, Subshell}" href="#JAC.AngularMomentum.CL_reduced_me-Tuple{Subshell, Int64, Subshell}"><code>JAC.AngularMomentum.CL_reduced_me</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.CL_reduced_me(suba::Subshell, L::Int64, subb::Subshell)</code>       ... calculates the reduced matrix element of the C^L spherical tensor &lt;suba || C^(L) || subb&gt;; a value::Float64          is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.CL_reduced_me_rb-Tuple{Subshell, Int64, Subshell}" href="#JAC.AngularMomentum.CL_reduced_me_rb-Tuple{Subshell, Int64, Subshell}"><code>JAC.AngularMomentum.CL_reduced_me_rb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.CL_reduced_me_rb(suba::Subshell, L::Int64, subb::Subshell)</code>       ... calculates the reduced matrix element of the C^L spherical tensor &lt;suba || C^(L) || subb&gt;; a value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.CL_reduced_me_sms-Tuple{Subshell, Int64, Subshell}" href="#JAC.AngularMomentum.CL_reduced_me_sms-Tuple{Subshell, Int64, Subshell}"><code>JAC.AngularMomentum.CL_reduced_me_sms</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.CL_reduced_me_sms(suba::Subshell, L::Int64, subb::Subshell)</code>       ... calculates the reduced matrix element of the C^L spherical tensor &lt;suba || C^(L) || subb&gt; for the      specific MS (SMS); a value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.ChengI-Tuple{Int64, AngularM64, Int64, AngularM64, AngularJ64, AngularM64}" href="#JAC.AngularMomentum.ChengI-Tuple{Int64, AngularM64, Int64, AngularM64, AngularJ64, AngularM64}"><code>JAC.AngularMomentum.ChengI</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>`AngularMomentum.ChengI</p><ul><li>(kapa::Int64, ma::AngularM64, kapb::Int64, mb::AngularM64, L::AngularJ64, M::AngularM64)`    ... evaluates the angular I (kappa m, kappa&#39; m&#39;, LM) integral as defined by Cheng, NATO summerschool (198x),        Eq. (A4.5), and including the full magnetic (orientational) dependence. A value::Float64 is returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.ChengI-Tuple{Int64, Int64, AngularJ64}" href="#JAC.AngularMomentum.ChengI-Tuple{Int64, Int64, AngularJ64}"><code>JAC.AngularMomentum.ChengI</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><ul><li>(kapa::Int64, kapb::Int64, L::AngularJ64)`    ... evaluates the same angular I (kappa m, kappa&#39; m&#39;, LM) integral but without the magnetic (orientational) dependence.        A value::Float64 is returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.ClebschGordan-NTuple{6, Any}" href="#JAC.AngularMomentum.ClebschGordan-NTuple{6, Any}"><code>JAC.AngularMomentum.ClebschGordan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.ClebschGordan(ja, ma, jb, mb, Jab, Mab)</code>       ... calculates the Clebsch-Gordan coefficient  &lt;ja, ma, jb, mb; Jab, Mab&gt; for given quantum numbers by          a proper call to a Wigner 3-j symbol. A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.ClebschGordan_old-Tuple{AngularJ64, AngularM64, AngularJ64, AngularM64, AngularJ64, AngularM64}" href="#JAC.AngularMomentum.ClebschGordan_old-Tuple{AngularJ64, AngularM64, AngularJ64, AngularM64, AngularJ64, AngularM64}"><code>JAC.AngularMomentum.ClebschGordan_old</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.ClebschGordan_old(ja::AngularJ64, ma::AngularM64, jb::AngularJ64, mb::AngularM64, Jab::AngularJ64, Mab::AngularM64)</code>       ... calculates the Clebsch-Gordan coefficient  &lt;ja, ma, jb, mb; Jab, Mab&gt; for given quantum numbers by          a proper call to a Wigner 3-j symbol; a value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.JohnsonI-Tuple{Int64, Int64, AngularJ64}" href="#JAC.AngularMomentum.JohnsonI-Tuple{Int64, Int64, AngularJ64}"><code>JAC.AngularMomentum.JohnsonI</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.JohnsonI(kapa::Int64, ma::AngularM64, kapb::Int64, mb::AngularM64, L::AngularJ64, M::AngularM64)</code>      ... evaluates the angular CL (kappa m, kappa&#39; m&#39;, L M) integral as defined in his book. A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.Wigner_3j-NTuple{6, Any}" href="#JAC.AngularMomentum.Wigner_3j-NTuple{6, Any}"><code>JAC.AngularMomentum.Wigner_3j</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.Wigner_3j(a, b, c, m_a, m_b, m_c)</code>       ... calculates the value of a Wigner 3-j symbol for given quantum numbers as displayed in many texts on the theory of          angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981, p. 142);          it calls the corresponding function from the GNU Scientific Library. A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.Wigner_3j_old-Tuple{AngularJ64, AngularJ64, AngularJ64, AngularM64, AngularM64, AngularM64}" href="#JAC.AngularMomentum.Wigner_3j_old-Tuple{AngularJ64, AngularJ64, AngularJ64, AngularM64, AngularM64, AngularM64}"><code>JAC.AngularMomentum.Wigner_3j_old</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.Wigner_3j_old(a::AngularJ64, b::AngularJ64, c::AngularJ64, m_a::AngularM64, m_b::AngularM64, m_c::AngularM64)</code>           ... calculates the value of a Wigner 3-j symbol  for given quantum numbers by its algebraic formulae as displayed in many texts on the              theory of angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981,              p. 142); a value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.Wigner_6j-NTuple{6, Any}" href="#JAC.AngularMomentum.Wigner_6j-NTuple{6, Any}"><code>JAC.AngularMomentum.Wigner_6j</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.Wigner_6j(a, b, c, d, e, f)</code>       ... calculates the value of a Wigner 6-j symbol for given quantum numbers as displayed in many texts on the theory of          angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981, p. 142);          it calls the corresponding function from the GNU Scientific Library. A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.Wigner_6j_old-NTuple{6, AngularJ64}" href="#JAC.AngularMomentum.Wigner_6j_old-NTuple{6, AngularJ64}"><code>JAC.AngularMomentum.Wigner_6j_old</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.Wigner_6j_old(a::AngularJ64, b::AngularJ64, c::AngularJ64, d::AngularJ64, e::AngularJ64, f::AngularJ64)</code>           ... calculates the value of a Wigner 6-j symbol  for given quantum numbers by its algebraic formulae as displayed in many texts on the              theory of angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981,              p. 142); a value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.Wigner_9j-NTuple{9, Any}" href="#JAC.AngularMomentum.Wigner_9j-NTuple{9, Any}"><code>JAC.AngularMomentum.Wigner_9j</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.Wigner_9j(a, b, c, d, e, f, g, h, i)</code>       ... calculates the value of a Wigner 3-j symbol for given quantum numbers as displayed in many texts on the theory of          angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981, p. 142);          it calls the corresponding function from the GNU Scientific Library. A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.Wigner_9j_old-NTuple{9, AngularJ64}" href="#JAC.AngularMomentum.Wigner_9j_old-NTuple{9, AngularJ64}"><code>JAC.AngularMomentum.Wigner_9j_old</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.Wigner_9j_old(a::AngularJ64, b::AngularJ64, c::AngularJ64, d::AngularJ64, e::AngularJ64, f::AngularJ64,                                 g::AngularJ64, h::AngularJ64, i::AngularJ64)</code>           ... calculates the value of a Wigner 6-j symbol  for given quantum numbers by its algebraic formulae as displayed in many texts on the              theory of angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981,              p. 142); a value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.Wigner_DFunction-Tuple{Any, Any, Any, Float64, Float64, Float64}" href="#JAC.AngularMomentum.Wigner_DFunction-Tuple{Any, Any, Any, Float64, Float64, Float64}"><code>JAC.AngularMomentum.Wigner_DFunction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.Wigner_DFunction(j, p, q, alpha::Float64, beta::Float64, gamma::Float64)</code>       ... calculates the value of a Wigner D^j_pq (alpha, beta, gamma) for given quantum numbers and (Euler) angles          (alpha, beta, gamma). It makes use of the small Wigner d(beta) matrix as the key part.         A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.Wigner_dmatrix-Tuple{Any, Any, Any, Float64}" href="#JAC.AngularMomentum.Wigner_dmatrix-Tuple{Any, Any, Any, Float64}"><code>JAC.AngularMomentum.Wigner_dmatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.Wigner_dmatrix(j, mp, m, beta::Float64)</code>       ... calculates the value of the small Wigner d^j_m&#39;,m (beta) for given quantum numbers and the angle beta.         Wigner&#39;s formula is applied to evaluate the small Wigner matrix; a value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.allowedDoubleKappaCouplingSequence-Tuple{LevelSymmetry, LevelSymmetry, Int64}" href="#JAC.AngularMomentum.allowedDoubleKappaCouplingSequence-Tuple{LevelSymmetry, LevelSymmetry, Int64}"><code>JAC.AngularMomentum.allowedDoubleKappaCouplingSequence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.allowedDoubleKappaCouplingSequence(syma::LevelSymmetry, symb::LevelSymmetry, maxKappa::Int64)</code>       ... to determine all allowed coupling sequences that fulfill         syma + (kappa1, symx, kappa2) –&gt; symb  ==  syma + kappa1 –&gt; symx + kappa2 –&gt; symb,         and where kappa1|, |kappa2| &lt;= maxKappa. A list::Array{Tuple{Int64,LevelSymmetry,Int64},1}) of (kappa1, symx, kappa2)         is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.allowedDoubleKappaSymmetries-Tuple{LevelSymmetry, Int64, Int64, LevelSymmetry}" href="#JAC.AngularMomentum.allowedDoubleKappaSymmetries-Tuple{LevelSymmetry, Int64, Int64, LevelSymmetry}"><code>JAC.AngularMomentum.allowedDoubleKappaSymmetries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.allowedDoubleKappaSymmetries(syma::LevelSymmetry, kappa1::Int64, kappa2::Int64, symb::LevelSymmetry)</code>       ... to determine all allowed level symmetries symx that can be coupled to the sequence          syma + kappa1 –&gt; {symx} + kappa2 –&gt; symb. A list::Array{LevelSymmetry,1} of symx is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.allowedDoubleKappas-Tuple{LevelSymmetry, LevelSymmetry, Int64}" href="#JAC.AngularMomentum.allowedDoubleKappas-Tuple{LevelSymmetry, LevelSymmetry, Int64}"><code>JAC.AngularMomentum.allowedDoubleKappas</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.allowedDoubleKappas(syma::LevelSymmetry, symb::LevelSymmetry, maxKappa::Int64)</code>       ... to determine all allowed pairs of kappa that fulfill  syma + (kappa1, kappa2) –&gt; symb,         and where |kappa1|, |kappa2| &lt;= maxKappa. A list::Array{Tuple{Int64,Int64},1}) of (kappa1, kappa2) is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.allowedKappaSymmetries-Tuple{LevelSymmetry, LevelSymmetry}" href="#JAC.AngularMomentum.allowedKappaSymmetries-Tuple{LevelSymmetry, LevelSymmetry}"><code>JAC.AngularMomentum.allowedKappaSymmetries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.allowedKappaSymmetries(syma::LevelSymmetry, symb::LevelSymmetry)</code>       ... to determine all allowed single-electron symmetries/partial waves kappa (l,j) that can be coupled to the given          level symmetries. A list::Array{Int64,1} of kappa-values is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.allowedMultipoleSymmetries-Tuple{LevelSymmetry, EmMultipole}" href="#JAC.AngularMomentum.allowedMultipoleSymmetries-Tuple{LevelSymmetry, EmMultipole}"><code>JAC.AngularMomentum.allowedMultipoleSymmetries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.allowedMultipoleSymmetries(syma::LevelSymmetry, multipole::EmMultipole)</code>       ... to determine all allowed level symmetries for which the given multipole can give rise to a non-zero (transition)          amplitude; a symList::Array{LevelSymmetry,1} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.allowedTotalSymmetries-Tuple{LevelSymmetry, EmMultipole, EmMultipole, LevelSymmetry}" href="#JAC.AngularMomentum.allowedTotalSymmetries-Tuple{LevelSymmetry, EmMultipole, EmMultipole, LevelSymmetry}"><code>JAC.AngularMomentum.allowedTotalSymmetries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.allowedTotalSymmetries(symf::LevelSymmetry, mp2::EmMultipole, mp1::EmMultipole, symi::LevelSymmetry)</code>       ... to determine all allowed total symmetries J^P that can be constructed by coupling a multipole wave mp1 to the          initial symmetry symi, and which can be further coupled with mp2 to the final symmetry symf.          A list::Array{LevelSymmetry,1} of total symmetries is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.allowedTotalSymmetries-Tuple{LevelSymmetry, Int64}" href="#JAC.AngularMomentum.allowedTotalSymmetries-Tuple{LevelSymmetry, Int64}"><code>JAC.AngularMomentum.allowedTotalSymmetries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.allowedTotalSymmetries(syma::LevelSymmetry, kappa::Int64)</code>       ... to determine all allowed total symmetries J^P that can be constructed by coupling a partial wave kappa (l,j)          to the given level symmetry syma. A list::Array{LevelSymmetry,1} of total symmetries is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.bracket-Tuple{Vector{AngularJ64}}" href="#JAC.AngularMomentum.bracket-Tuple{Vector{AngularJ64}}"><code>JAC.AngularMomentum.bracket</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.bracket(jList::Array{AngularJ64,1})</code>       ... to compute the bracket [a, b, c, ... ] = (2a+1) * (2b+1) * (2b+1) * ... of the given angular momenta.          A value::Int64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.isAllowedMultipole-Tuple{LevelSymmetry, EmMultipole, LevelSymmetry}" href="#JAC.AngularMomentum.isAllowedMultipole-Tuple{LevelSymmetry, EmMultipole, LevelSymmetry}"><code>JAC.AngularMomentum.isAllowedMultipole</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.isAllowedMultipole(syma::LevelSymmetry, multipole::EmMultipole, symb::LevelSymmetry)</code>       ... evaluates to true if the given multipole may connect the two level symmetries, and false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.isTriangle-Tuple{AngularJ64, AngularJ64, AngularJ64}" href="#JAC.AngularMomentum.isTriangle-Tuple{AngularJ64, AngularJ64, AngularJ64}"><code>JAC.AngularMomentum.isTriangle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.isTriangle(ja::AngularJ64, jb::AngularJ64, jc::AngularJ64)</code>       ... evaluates to true if Delta(ja,jb,jc) = 1, ie. if the angular momenta ja, jb and jc can couple to each other,          and false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.isTriangle-Tuple{Int64, Int64, Int64}" href="#JAC.AngularMomentum.isTriangle-Tuple{Int64, Int64, Int64}"><code>JAC.AngularMomentum.isTriangle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.isTriangle(ja::Int64, jb::Int64, jc::Int64)</code>       ... evaluates to true if Delta(ja,jb,jc) = 1, ie. if the three integer (length) ja, jb and jc can form a triangle,          and false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.kappa_j-Tuple{Int64}" href="#JAC.AngularMomentum.kappa_j-Tuple{Int64}"><code>JAC.AngularMomentum.kappa_j</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.kappa_j(kappa::Int64)</code>  ... calculates the j::AngularJ64 value of a given kappa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.kappa_l-Tuple{Int64}" href="#JAC.AngularMomentum.kappa_l-Tuple{Int64}"><code>JAC.AngularMomentum.kappa_l</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.kappa_l(kappa::Int64)</code>  ... calculates the l::AngularJ64 value of a given kappa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.m_values-Tuple{AngularJ64}" href="#JAC.AngularMomentum.m_values-Tuple{AngularJ64}"><code>JAC.AngularMomentum.m_values</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.m_values(j::AngularJ64)</code>  ... returns a list of m-values for given j::AngularJ64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.oneJ-Tuple{AngularJ64}" href="#JAC.AngularMomentum.oneJ-Tuple{AngularJ64}"><code>JAC.AngularMomentum.oneJ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.oneJ(ja::AngularJ64)</code>  ... calculates ja; a (positive) value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.parityEmMultipolePi-Tuple{Parity, EmMultipole, Parity}" href="#JAC.AngularMomentum.parityEmMultipolePi-Tuple{Parity, EmMultipole, Parity}"><code>JAC.AngularMomentum.parityEmMultipolePi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.parityEmMultipolePi(pa::Parity, multipole::EmMultipole, pb::Parity)</code>       ... evaluates to true if the given multipole fullfills the parity selection rule pi(a, multipole, b) = 1,          and false otherwise. This includes a proper test for both, electric and magnetic multipoles, based on          multipole.electric.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.phaseFactor-Tuple{Vector{Any}}" href="#JAC.AngularMomentum.phaseFactor-Tuple{Vector{Any}}"><code>JAC.AngularMomentum.phaseFactor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.phaseFactor(list::Array{Any,1})</code>      ... checks and calculates the phase factor (-1)^(ja + mb -jc ...) that occur frequently in angular momentum theory;          a value +1. or -1. is returned. Use phaseFactor([ja::Union{AngularJ64,AngularM64), -1, mb::Union{AngularJ64,AngularM64),          ..., 1, jc::Union{AngularJ64,AngularM64)]) to specify the phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.phaseMultipole-Tuple{ComplexF64, EmMultipole}" href="#JAC.AngularMomentum.phaseMultipole-Tuple{ComplexF64, EmMultipole}"><code>JAC.AngularMomentum.phaseMultipole</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.phaseMultipole(x::ComplexF64, mp::EmMultipole)</code>       ... calculates (x)^p   with   mp = (L,p) and p = 0 (magnetic), p = 1 (electric).         A  wa ::ComplexF64  is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.sigma_reduced_me-Tuple{Subshell, Subshell}" href="#JAC.AngularMomentum.sigma_reduced_me-Tuple{Subshell, Subshell}"><code>JAC.AngularMomentum.sigma_reduced_me</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.sigma_reduced_me(suba::Subshell, subb::Subshell)</code>       ... calculates the reduced matrix element of the sigma^(1) spherical tensor &lt;suba || sigma^(1) || subb&gt;;          a value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.sphericalYlm-Tuple{Int64, Int64, Float64, Float64}" href="#JAC.AngularMomentum.sphericalYlm-Tuple{Int64, Int64, Float64, Float64}"><code>JAC.AngularMomentum.sphericalYlm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.sphericalYlm(l::Int64, m::Int64, theta::Float64, phi::Float64)</code>       ... calculates the spherical harmonics for low l-values explicitly. A value::Complex{Float64} is returned.         Ylm = sqrt( (2<em>l+1) / (two</em>two*pi) ) * spherical_Clm(l,m,theta,phi).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.triangularDelta-Tuple{AngularJ64, AngularJ64, AngularJ64}" href="#JAC.AngularMomentum.triangularDelta-Tuple{AngularJ64, AngularJ64, AngularJ64}"><code>JAC.AngularMomentum.triangularDelta</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.triangularDelta(ja::AngularJ64, jb::AngularJ64, jc::AngularJ64)</code>       ... calculates the tringular Delta(ja,jb,jc). The result is 0 if the triangular condition failes and 1 otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.AngularMomentum.triangularDelta-Tuple{Int64, Int64, Int64}" href="#JAC.AngularMomentum.triangularDelta-Tuple{Int64, Int64, Int64}"><code>JAC.AngularMomentum.triangularDelta</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AngularMomentum.triangularDelta(ia2::Int64, ib2::Int64, ic2::Int64)</code>       ... calculates the tringular Delta(ja,jb,jc). The arguments in this integer function are i2a = 2*ja+1, ...          The result is 0 if the triangular condition failes and 1 otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><h2 id="Atomic-interaction-strength"><a class="docs-heading-anchor" href="#Atomic-interaction-strength">Atomic interaction strength</a><a id="Atomic-interaction-strength-1"></a><a class="docs-heading-anchor-permalink" href="#Atomic-interaction-strength" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XLCoefficient" href="#JAC.InteractionStrength.XLCoefficient"><code>JAC.InteractionStrength.XLCoefficient</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  InteractionStrength.XLCoefficient</code>  ... defines a type for coefficients of the two-electron (Breit) interaction</p><pre><code class="nohighlight hljs">+ kind      ::Char       ... Kind of integral, either &#39;S&#39; or &#39;T&#39;
+ nu        ::Int64      ... Rank of the integral.
+ a         ::Orbital    ... Orbitals a, b, c, d.
+ b         ::Orbital
+ c         ::Orbital
+ d         ::Orbital
+ coeff     ::Float64    ... corresponding coefficient.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.MabEmissionJohnsony-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.MabEmissionJohnsony-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.MabEmissionJohnsony</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.MabEmissionJohnsony(mp::EmMultipole, gauge::EmGauge, omega::Float64, a::Orbital, b::Orbital, grid::Radial.Grid)</code>     ... to compute the (single-electron reduced matrix element) interaction strength &lt;a || O^(Mp,emission) || b&gt;          for the interaction with the Mp multipole component of the radiation field and the transition frequency omega, and          within the given gauge. A value::Float64 is returned. This procedure has been re-worked due to the book by Johnson (2007). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.MbaAbsorptionCheng-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.MbaAbsorptionCheng-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.MbaAbsorptionCheng</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.MbaAbsorptionCheng(mp::EmMultipole, gauge::EmGauge, omega::Float64, b::Orbital, a::Orbital, grid::Radial.Grid)</code>     ... to compute the (single-electron reduced matrix element) interaction strength &lt;b || O^(Mp, absorption) || a&gt;          for the interaction with the Mp multipole component of the radiation field and the transition frequency omega, and          within the given gauge. A value::Float64 is returned.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.MbaEmissionAndreyOld-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.MbaEmissionAndreyOld-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.MbaEmissionAndreyOld</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.MbaEmissionAndrey(mp::EmMultipole, gauge::EmGauge, omega::Float64, b::Orbital, a::Orbital, grid::Radial.Grid)</code>       ... to compute the (single-electron reduced matrix element) interaction strength &lt;b || O^(Mp, emission) || a&gt;           for the interaction with the Mp multipole component of the radiation field and the transition frequency omega,         and within the given gauge. A value::Float64 is returned. At present, only the magnetic matrix elements are          implemented.          This procedure has been worked out with Andrey but is currently not in use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.MbaEmissionCheng-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.MbaEmissionCheng-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.MbaEmissionCheng</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.MbaEmissionCheng(mp::EmMultipole, gauge::EmGauge, omega::Float64, b::Orbital, a::Orbital, grid::Radial.Grid)</code>     ... to compute the (single-electron reduced matrix element) interaction strength &lt;b || O^(Mp,emission) || a&gt;          for the interaction with the Mp multipole component of the radiation field and the transition frequency omega, and          within the given gauge. A value::Float64 is returned.           This procedure has been first worked out with Andrey; in this case, however, the phases are not under good control,         and this gives rise to wrong amplitudes and rates. The procedure is currently not in use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.MbaEmissionJohnsonx-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.MbaEmissionJohnsonx-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.MbaEmissionJohnsonx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.MbaEmissionJohnsonx(mp::EmMultipole, gauge::EmGauge, omega::Float64, b::Orbital, a::Orbital, grid::Radial.Grid)</code>     ... to compute the (single-electron reduced matrix element) interaction strength &lt;b || O^(Mp,emission) || a&gt;          for the interaction with the Mp multipole component of the radiation field and the transition frequency omega, and          within the given gauge. A value::Float64 is returned.           This procedure has been adapted from Jiri&#39;s work but modified for the Coulomb gauge which was apparently wrong following         some former implementation with RATIP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.MbaEmissionMigdalek-Tuple{CorePolarization, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.MbaEmissionMigdalek-Tuple{CorePolarization, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.MbaEmissionMigdalek</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.MbaEmissionMigdalek(cp::CorePolarization, a::Orbital, b::Orbital, grid::Radial.Grid)</code>       ... to compute the (single-electron reduced matrix element) interaction strength &lt;b || O^(E1, emission with core-polarization) || a&gt;           in length gauge. A value::Float64 is returned. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XL_Breit-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid, Union{CoulombGaunt, BreitInteraction, CoulombBreit}}" href="#JAC.InteractionStrength.XL_Breit-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid, Union{CoulombGaunt, BreitInteraction, CoulombBreit}}"><code>JAC.InteractionStrength.XL_Breit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.XL_Breit(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid,                                 eeint::Union{BreitInteraction, CoulombBreit, CoulombGaunt}; keep::Bool=false)</code>       ... computes the the effective Breit interaction strengths X^L<em>Breit (abcd) or Gaunt interaction strengths          X^L</em>Gaunt (abcd) for given rank L and orbital functions a, b, c and d  at the given grid.          For keep=true, the procedure looks up the (global) directory GBL<em>Storage</em>XL_Coulomb         and returns the corresponding value without re-calculation of the interaction strength; it also &#39;stores&#39; the calculated         value if not yet included. For keep=false, the interaction strength is always computed on-fly. A value::Float64 is returned.          At present, only the zero-frequency Breit or Gaunt interaction is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XL_BreitDamped-Tuple{Float64, Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.XL_BreitDamped-Tuple{Float64, Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.XL_BreitDamped</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.XL_BreitDamped(tau::Float64, L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid)</code>       ... computes the the effective Breit interaction strengths X^L_Breit (abcd) for given rank L and orbital functions          a, b, c and d  at the given grid. A value::Float64 is returned. At present, only the zero-frequency Breit          interaction is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XL_Breit_coefficients-Tuple{Int64, Vararg{Orbital, 4}}" href="#JAC.InteractionStrength.XL_Breit_coefficients-Tuple{Int64, Vararg{Orbital, 4}}"><code>JAC.InteractionStrength.XL_Breit_coefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.XL_Breit_coefficients(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital; onlyGaunt::Bool=false)</code>       ... evaluates the combinations and pre-coefficients for the zero-frequency Breit interaction           X^L_Breit (omega=0.; abcd) for given rank L and orbital functions a, b, c and d. A list of coefficients          xcList::Array{XLCoefficient,1} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XL_Breit_densities-Tuple{Vector{JAC.InteractionStrength.XLCoefficient}, Float64, JAC.Radial.Grid}" href="#JAC.InteractionStrength.XL_Breit_densities-Tuple{Vector{JAC.InteractionStrength.XLCoefficient}, Float64, JAC.Radial.Grid}"><code>JAC.InteractionStrength.XL_Breit_densities</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.XL_Breit_densities(xcList::Array{XLCoefficient,1}, factor::Float64, grid::Radial.Grid)</code>       ... computes the the effective Breit interaction strengths X^L,0_Breit (abcd) for given rank L and a list of          orbital functions a, b, c, d and angular coefficients at the given grid. A value::Float64 is returned.          At present, only the zero-frequency Breit interaction is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XL_Breit_reset_storage-Tuple{Bool}" href="#JAC.InteractionStrength.XL_Breit_reset_storage-Tuple{Bool}"><code>JAC.InteractionStrength.XL_Breit_reset_storage</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.XL_Breit_reset_storage(keep::Bool; printout::Bool=false)</code>       ... resets the global storage of XL_Breit interaction strength; nothing is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XL_Coulomb-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.XL_Coulomb-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.XL_Coulomb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.XL_Coulomb(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid; keep::Bool=false)</code>       ... computes the the effective Coulomb interaction strengths X^L<em>Coulomb (abcd) for given rank L and orbital functions          a, b, c and d at the given grid. For keep=true, the procedure looks up the (global) directory GBL</em>Storage<em>XL</em>Coulomb         and returns the corresponding value without re-calculation of the interaction strength; it also &#39;stores&#39; the calculated         value if not yet included. For keep=false, the interaction strength is always computed on-fly. A value::Float64 is          returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XL_CoulombDamped-Tuple{Float64, Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.XL_CoulombDamped-Tuple{Float64, Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.XL_CoulombDamped</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.XL_CoulombDamped(tau::Float64, L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid)</code>       ... computes the the effective Coulomb interaction strengths X^L_Coulomb (abcd) for given rank L and orbital functions          a, b, c and d at the given grid. A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XL_Coulomb_DH-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid, Float64}" href="#JAC.InteractionStrength.XL_Coulomb_DH-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid, Float64}"><code>JAC.InteractionStrength.XL_Coulomb_DH</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.XL_Coulomb_DH(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid, lambda::Float64)</code>       ... computes the the effective Coulomb-Debye-Hückel interaction strengths X^L<em>Coulomb</em>DH (abcd) for given rank L and          orbital functions a, b, c and d at the given grid and for the given screening parameter lambda. A value::Float64 is          returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XL_Coulomb_WO-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.XL_Coulomb_WO-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.XL_Coulomb_WO</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.XL_Coulomb_WO(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid)</code>       ... computes the the effective Coulomb interaction strengths X^L_Coulomb (abcd) for given rank L and orbital functions          a, b, c and d at the given grid but without optimization. A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XL_Coulomb_reset_storage-Tuple{Bool}" href="#JAC.InteractionStrength.XL_Coulomb_reset_storage-Tuple{Bool}"><code>JAC.InteractionStrength.XL_Coulomb_reset_storage</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.XL_Coulomb_reset_storage(keep::Bool; printout::Bool=false)</code>       ... resets the global storage of XL_Coulomb interaction strength; nothing is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.XL_plasma_ionSphere-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, Float64}" href="#JAC.InteractionStrength.XL_plasma_ionSphere-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, Float64}"><code>JAC.InteractionStrength.XL_plasma_ionSphere</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.XL_plasma_ionSphere(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, lambda::Float64)</code>       ... computes the effective interaction strengths X^L_ion-sphere (abcd) for given rank L and orbital functions          a, b, c and d and for the plasma parameter lambda. A value::Float64 is returned.  <strong>Not yet implemented !</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.X_smsA-Tuple{Orbital, Orbital, Orbital, Orbital, Model, JAC.Radial.Grid}" href="#JAC.InteractionStrength.X_smsA-Tuple{Orbital, Orbital, Orbital, Orbital, Model, JAC.Radial.Grid}"><code>JAC.InteractionStrength.X_smsA</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.X_smsA(a::Orbital, b::Orbital, c::Orbital, d::Orbital, nm::Nuclear.Model, grid::Radial.Grid)</code>       ... computes the the effective interaction strengths X^1_sms,A (abcd) for fixed rank 1 and orbital functions          a, b, c and d at the given grid. A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.X_smsB-Tuple{Orbital, Orbital, Orbital, Orbital, Model, JAC.Radial.Grid}" href="#JAC.InteractionStrength.X_smsB-Tuple{Orbital, Orbital, Orbital, Orbital, Model, JAC.Radial.Grid}"><code>JAC.InteractionStrength.X_smsB</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.X_smsB(a::Orbital, b::Orbital, c::Orbital, d::Orbital, nm::Nuclear.Model, grid::Radial.Grid)</code>       ... computes the the effective interaction strengths X^1_sms,B (abcd) for fixed rank 1 and orbital functions          a, b, c and d at the given grid. A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.X_smsC-Tuple{Orbital, Orbital, Orbital, Orbital, Model, JAC.Radial.Grid}" href="#JAC.InteractionStrength.X_smsC-Tuple{Orbital, Orbital, Orbital, Orbital, Model, JAC.Radial.Grid}"><code>JAC.InteractionStrength.X_smsC</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.X_smsC(a::Orbital, b::Orbital, c::Orbital, d::Orbital, nm::Nuclear.Model, grid::Radial.Grid)</code>      ... computes the the effective interaction strengths X^1_sms,C (abcd) for fixed rank 1 and orbital functions          a, b, c and d at the given grid. A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.bosonShift-Tuple{Orbital, Orbital, Vector{Float64}, JAC.Radial.Grid}" href="#JAC.InteractionStrength.bosonShift-Tuple{Orbital, Orbital, Vector{Float64}, JAC.Radial.Grid}"><code>JAC.InteractionStrength.bosonShift</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.bosonShift(a::Orbital, b::Orbital, potential::Array{Float64,1}, grid::Radial.Grid)</code>       ... computes the  &lt;a|| h^(boson-field) ||b&gt;  reduced matrix element of the boson-field shift Hamiltonian for orbital          functions a, b. This boson-field shift Hamiltonian just refers to the effective potential of the given          isotope due to the (assumed) boson mass. A value::Float64 is returned.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.dipole-Tuple{Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.dipole-Tuple{Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.dipole</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.dipole(a::Orbital, b::Orbital, grid::Radial.Grid)</code>       ... computes the  &lt;a|| d ||b&gt;  reduced matrix element of the dipole operator for orbital functions a, b.          A value::Float64 is returned. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.eMultipole-Tuple{Int64, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.eMultipole-Tuple{Int64, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.eMultipole</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.eMultipole(k::Int64, a::Orbital, b::Orbital, grid::Radial.Grid)</code>       ... computes the  &lt;a|| t^(Ek) ||b&gt;  reduced matrix element of the dipole operator for orbital functions a, b.          A value::Float64 is returned. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.fieldShift-Tuple{Orbital, Orbital, Vector{Float64}, JAC.Radial.Grid}" href="#JAC.InteractionStrength.fieldShift-Tuple{Orbital, Orbital, Vector{Float64}, JAC.Radial.Grid}"><code>JAC.InteractionStrength.fieldShift</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.fieldShift(a::Orbital, b::Orbital, deltaPotential::Array{Float64,1}, grid::Radial.Grid)</code>       ... computes the  &lt;a|| h^(field-shift) ||b&gt;  reduced matrix element of the field-shift Hamiltonian for orbital          functions a, b. This field-shift Hamiltonian just refers to the difference of the nuclear potential          deltaPotential of two isotopes, and which is already divided by the difference of the mean-square radii.          A value::Float64 is returned.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.hamiltonian_nms-Tuple{Orbital, Orbital, Model, JAC.Radial.Grid}" href="#JAC.InteractionStrength.hamiltonian_nms-Tuple{Orbital, Orbital, Model, JAC.Radial.Grid}"><code>JAC.InteractionStrength.hamiltonian_nms</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.hamiltonian_nms(a::Orbital, b::Orbital, nm::Nuclear.Model, grid::Radial.Grid)</code>       ... computes the  &lt;a|| h_nms ||b&gt;  reduced matrix element of the normal-mass-shift Hamiltonian for orbital          functions a, b. A value::Float64 is returned.  For details, see Naze et al., CPC 184 (2013) 2187, Eq. (37).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.hfs_t1-Tuple{Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.hfs_t1-Tuple{Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.hfs_t1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.hfs_t1(a::Orbital, b::Orbital, grid::Radial.Grid)</code>       ... computes the &lt;a|| t^(1) ||b&gt; reduced matrix element for the HFS coupling to the magnetic-dipole moment          of the nucleus for orbital functions a, b. A value::Float64 is returned.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.hfs_t2-Tuple{Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.hfs_t2-Tuple{Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.hfs_t2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.hfs_t2(a::Orbital, b::Orbital, grid::Radial.Grid)</code>       ... computes the &lt;a|| t^(2) ||b&gt; reduced matrix element for the HFS coupling to the electric-quadrupole moment of          the nucleus for orbital functions a, b. A value::Float64 is returned.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.matrixL_Coulomb-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Bsplines.Primitives}" href="#JAC.InteractionStrength.matrixL_Coulomb-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Bsplines.Primitives}"><code>JAC.InteractionStrength.matrixL_Coulomb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.matrixL_Coulomb(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, primitives::Bsplines.Primitives)</code>       ... computes the partly-contracted (effective) Coulomb interaction matrices M^L_Coulomb (abcd) for given rank L and orbital functions          a, b, c and d at the given grid. The matrix M^L is defined for the primitives and contracted over the two orbitals         b, d (for a=c) or  b, c (for a=d).  An error message is issued if a != c &amp;&amp; a != d. A matrix::Array{Float64,2} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.multipoleTransition-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.multipoleTransition-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.multipoleTransition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.multipoleTransition(mp::EmMultipole, gauge::EmGauge, omega::Float64, b::Orbital, a::Orbital, grid::Radial.Grid)</code>     ... to compute the (single-electron reduced matrix element) multipole-transition interaction strength          &lt;b || T^(Mp, absorption) || a&gt; due to Johnson (2007) for the interaction with the Mp multipole component of the         radiation field and the transition frequency omega, and within the given gauge. A value::Float64 is returned.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.schiffMoment-Tuple{Orbital, Orbital, Model, JAC.Radial.Grid}" href="#JAC.InteractionStrength.schiffMoment-Tuple{Orbital, Orbital, Model, JAC.Radial.Grid}"><code>JAC.InteractionStrength.schiffMoment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.schiffMoment(a::Orbital, b::Orbital, nm::Nuclear.Model, grid::Radial.Grid)</code>       ... computes the  &lt;a|| h^(Schiff-moment) ||b&gt;  reduced matrix element of the Schiff-moment Hamiltonian for orbital          functions a, b and for the nuclear density as given by the nuclear model. A value::Float64 is returned.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.weakCharge-Tuple{Orbital, Orbital, Model, JAC.Radial.Grid}" href="#JAC.InteractionStrength.weakCharge-Tuple{Orbital, Orbital, Model, JAC.Radial.Grid}"><code>JAC.InteractionStrength.weakCharge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.weakCharge(a::Orbital, b::Orbital, nm::Nuclear.Model, grid::Radial.Grid)</code>       ... computes the  &lt;a|| h^(weak-charge) ||b&gt;  reduced matrix element of the weak-charge Hamiltonian for orbital functions          a, b and for the nuclear density as given by the nuclear model. A value::Float64 is returned.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.zeeman_Delta_n1-Tuple{Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.zeeman_Delta_n1-Tuple{Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.zeeman_Delta_n1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.zeeman_Delta_n1(a::Orbital, b::Orbital, grid::Radial.Grid)</code>       ... computes the &lt;a|| Delta n^(1) ||b&gt; reduced matrix element for the Zeeman-Schwinger contribution to the coupling          to an external magnetic field for orbital functions a, b. A value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.InteractionStrength.zeeman_n1-Tuple{Orbital, Orbital, JAC.Radial.Grid}" href="#JAC.InteractionStrength.zeeman_n1-Tuple{Orbital, Orbital, JAC.Radial.Grid}"><code>JAC.InteractionStrength.zeeman_n1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>InteractionStrength.zeeman_n1(a::Orbital, b::Orbital, grid::Radial.Grid)</code>       ... computes the &lt;a|| n^(1) ||b&gt; reduced matrix element for the Zeeman coupling to an external magnetic field for          orbital functions a, b. A value::Float64 is returned. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><h2 id="Basics:-data-types"><a class="docs-heading-anchor" href="#Basics:-data-types">Basics: data types</a><a id="Basics:-data-types-1"></a><a class="docs-heading-anchor-permalink" href="#Basics:-data-types" title="Permalink"></a></h2><h2 id="Basics:-functions"><a class="docs-heading-anchor" href="#Basics:-functions">Basics: functions</a><a id="Basics:-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Basics:-functions" title="Permalink"></a></h2><h2 id="Basics:-compute-and-generate"><a class="docs-heading-anchor" href="#Basics:-compute-and-generate">Basics: compute &amp; generate</a><a id="Basics:-compute-and-generate-1"></a><a class="docs-heading-anchor-permalink" href="#Basics:-compute-and-generate" title="Permalink"></a></h2><h2 id="B-Spline-basis"><a class="docs-heading-anchor" href="#B-Spline-basis">B-Spline basis</a><a id="B-Spline-basis-1"></a><a class="docs-heading-anchor-permalink" href="#B-Spline-basis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.Bspline" href="#JAC.BsplinesN.Bspline"><code>JAC.BsplinesN.Bspline</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  BsplinesN.Bspline</code>       ... defines a type for a (single) B-spline that is defined on a given radial grid from r[lower:upper].         Note that only the non-zero values are specified for the B-spline function and its derivative.</p><pre><code class="nohighlight hljs">+ lower        ::Int64               ... lower radial index (on the radial grid.r) from where the functions is nonzero.
+ upper        ::Int64               ... upper radial index up to which the functions is nonzero.
+ bs           ::Array{Float64,1}    ... radial B-spline functions as defined on the predefined grid.r[lower:upper]
+ bp           ::Array{Float64,1}    ... derivative of bs on the predefined grid grid.r[lower:upper]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.Primitives" href="#JAC.BsplinesN.Primitives"><code>JAC.BsplinesN.Primitives</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  BsplinesN.Primitives</code>  ... defines a type for a set of primitive functions which typically belongs to a well-defined grid.</p><pre><code class="nohighlight hljs">+ grid         ::Radial.Grid         ... radial grid on which the states are represented.
+ bsplinesL    ::Array{Bspline,1}    ... set of B-splines for the large components on the given radial grid.
+ bsplinesS    ::Array{Bspline,1}    ... set of B-splines for the small components on the given radial grid.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.computeNondiagonalD-Tuple{Int64, Int64, JAC.BsplinesN.Bspline, JAC.BsplinesN.Bspline, JAC.Radial.Grid}" href="#JAC.BsplinesN.computeNondiagonalD-Tuple{Int64, Int64, JAC.BsplinesN.Bspline, JAC.BsplinesN.Bspline, JAC.Radial.Grid}"><code>JAC.BsplinesN.computeNondiagonalD</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BsplinesN.computeNondiagonalD(pm::Int64, kappa::Int64, bspline1::BsplinesN.Bspline, bspline2::BsplinesN.Bspline, grid::Radial.Grid)</code>       ... computes the (radial and non-diagonal) D_kappa^+/- integral two the bsplines, all defined on grid         &lt;bspline1| +/- d/dr + kappa/r | bspline2&gt;. – pm = +1/-1 provides the phase for taking the derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.computeOverlap-Tuple{JAC.BsplinesN.Bspline, JAC.BsplinesN.Bspline, JAC.Radial.Grid}" href="#JAC.BsplinesN.computeOverlap-Tuple{JAC.BsplinesN.Bspline, JAC.BsplinesN.Bspline, JAC.Radial.Grid}"><code>JAC.BsplinesN.computeOverlap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BsplinesN.computeOverlap(bspline1::BsplinesN.Bspline, bspline2::BsplinesN.Bspline, grid::Radial.Grid)</code>       ... computes the (radial) overlap integral &lt;bspline1|bsplines&gt;  for two bpslines as defined on grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.computeVlocal-Tuple{JAC.BsplinesN.Bspline, JAC.BsplinesN.Bspline, JAC.Radial.Potential, JAC.Radial.Grid}" href="#JAC.BsplinesN.computeVlocal-Tuple{JAC.BsplinesN.Bspline, JAC.BsplinesN.Bspline, JAC.Radial.Potential, JAC.Radial.Grid}"><code>JAC.BsplinesN.computeVlocal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BsplinesN.computeVlocal(bspline1::BsplinesN.Bspline, bspline2::BsplinesN.Bspline, pot::Radial.Potential, grid::Radial.Grid)</code>       ... computes the (radial) integral &lt;bspline1| V_pot |bsplines&gt;  for two bpslines and the given radial potential          as defined on grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.extractBsplineCoefficients-Tuple{Subshell, JAC.Basics.Eigen, JAC.Radial.Grid}" href="#JAC.BsplinesN.extractBsplineCoefficients-Tuple{Subshell, JAC.Basics.Eigen, JAC.Radial.Grid}"><code>JAC.BsplinesN.extractBsplineCoefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BsplinesN.extractBsplineCoefficients(sh::Subshell, wc::Basics.Eigen, grid::Radial.Grid)</code>       ... Here, it is assumed that the matrix wc contains the (column) eigenvectors as associated with a single-electron Dirac          Hamiltonian matrix for symmetry kappa in Subshell(n, kappa). The procedure then extracts the (full) vector of B-spline         coefficients for the radial orbital of subshell sh by applying the standard rules of atomic physics for the principal         quantum number n.  A  vector::Array{Float64,1}  is returned, whose length is nsL+nsS in the original basis of B-spline          functions/primitives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.generateGalerkinMatrix-Tuple{Subshell, Float64, JAC.Radial.Potential, JAC.BsplinesN.Primitives}" href="#JAC.BsplinesN.generateGalerkinMatrix-Tuple{Subshell, Float64, JAC.Radial.Potential, JAC.BsplinesN.Primitives}"><code>JAC.BsplinesN.generateGalerkinMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BsplinesN.generateGalerkinMatrix(sh::Subshell, energy::Float64, pot::Radial.Potential, primitives::BsplinesN.Primitives)</code>       ... generates the Galerkin-A matrix for the given potential and B-spline primitives; a matrix::Array{Float64,2} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.generateOrbitalFromPrimitives-Tuple{Subshell, Float64, Int64, Vector{Float64}, JAC.BsplinesN.Primitives}" href="#JAC.BsplinesN.generateOrbitalFromPrimitives-Tuple{Subshell, Float64, Int64, Vector{Float64}, JAC.BsplinesN.Primitives}"><code>JAC.BsplinesN.generateOrbitalFromPrimitives</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BsplinesN.generateOrbitalFromPrimitives(sh::Subshell, energy::Float64, mtp::Int64, ev::Array{Float64,1}, primitives::BsplinesN.Primitives)</code>       ... generates the large and small components of a (relativistic) orbital for the subshell sh from the given primitives and the          eigenvector ev. A (non-normalized) orbital::Orbital is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.generateOrbitalFromPrimitives-Tuple{Subshell, JAC.Basics.Eigen, JAC.BsplinesN.Primitives}" href="#JAC.BsplinesN.generateOrbitalFromPrimitives-Tuple{Subshell, JAC.Basics.Eigen, JAC.BsplinesN.Primitives}"><code>JAC.BsplinesN.generateOrbitalFromPrimitives</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BsplinesN.generateOrbitalFromPrimitives(sh::Subshell, wc::Basics.Eigen, primitives::BsplinesN.Primitives)</code>       ... generates the large and small components for the subshell sh from the primitives and their eigenvalues &amp; eigenvectors.          A (normalized) orbital::Orbital is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.generateOrbitals-Tuple{Vector{Subshell}, JAC.Radial.Potential, Model, JAC.BsplinesN.Primitives}" href="#JAC.BsplinesN.generateOrbitals-Tuple{Vector{Subshell}, JAC.Radial.Potential, Model, JAC.BsplinesN.Primitives}"><code>JAC.BsplinesN.generateOrbitals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BsplinesN.generateOrbitals(subshells::Array{Subshell,1}, pot::Radial.Potential, nm::Nuclear.Model,                              primitives::BsplinesN.Primitives; printout::Bool=true)</code>       ... generates all single-electron orbitals from subshell list for the radial potential pot.          A set of orbitals::Dict{Subshell, Orbital} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.generateOrbitalsHydrogenic-Tuple{Vector{Subshell}, Model, JAC.BsplinesN.Primitives}" href="#JAC.BsplinesN.generateOrbitalsHydrogenic-Tuple{Vector{Subshell}, Model, JAC.BsplinesN.Primitives}"><code>JAC.BsplinesN.generateOrbitalsHydrogenic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BsplinesN.generateOrbitalsHydrogenic(subshells::Array{Subshell,1}, nm::Nuclear.Model, primitives::BsplinesN.Primitives; printout::Bool=true)</code>       ... generates all single-electron orbitals from subshell list for the nuclear potential as specified by nm.         A set of orbitals::Dict{Subshell, Orbital} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.generatePrimitives-Tuple{JAC.Radial.Grid}" href="#JAC.BsplinesN.generatePrimitives-Tuple{JAC.Radial.Grid}"><code>JAC.BsplinesN.generatePrimitives</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BsplinesN.generatePrimitives(grid::Radial.Grid)</code>       ... generates the breaks, knots and the B-spline primitives of order k, both for the large and small components.          The function applies the given grid parameters; no primitive is defined beyond grid[n_max]. The definition of          the primitives follow the work of Zatsarinny and Froese Fischer, CPC 202 (2016) 287. –- A (set of)          primitives::BsplinesN.Primitives is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.generateTTpMatrix!-Tuple{String, Int64, JAC.BsplinesN.Primitives, Dict{String, Matrix{Float64}}}" href="#JAC.BsplinesN.generateTTpMatrix!-Tuple{String, Int64, JAC.BsplinesN.Primitives, Dict{String, Matrix{Float64}}}"><code>JAC.BsplinesN.generateTTpMatrix!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BsplinesN.generateTTpMatrix!(TTp::String, kappa::Int64, primitives::BsplinesN.Primitives, storage::Dict{String,Array{Float64,2}})</code>       ... returns the TTp block of the (single-electron) Dirac Hamiltonian matrix for an electron with symmetry kappa         without any potential. The following TTp strings are allowed: [&quot;LL-overlap&quot;, &quot;SS-overlap&quot;, &quot;LS-D<em>kappa^-&quot;, &quot;LS-D</em>kappa^+&quot;].</p><pre><code class="nohighlight hljs">    Two modes are distinguished owing to the values that are available in the storage (Dict).
        * The TTp matrix block from the storage is returned, if an entry is known; it is assumed that this matrix
          block belong to the given set of primitives.
        * The TTp matrix is computed and set to the storage otherwise; from the TTp string, the key string
          key = string(kappa) * &quot;:&quot; * TTp is generated an applied in the storage dictionary.
          
    All B-splines are supposed to be defined for the same (radial) grid; a  matrix::Array{Float64,2}  is returned which 
    is quadratic for &#39;LL-overlap&#39; and &#39;SS-overlap&#39; and whose dimension depends on the number of B-splines for the large 
    and small component, otherwise.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.BsplinesN.setupLocalMatrix-Tuple{Int64, JAC.BsplinesN.Primitives, JAC.Radial.Potential, Dict{String, Matrix{Float64}}}" href="#JAC.BsplinesN.setupLocalMatrix-Tuple{Int64, JAC.BsplinesN.Primitives, JAC.Radial.Potential, Dict{String, Matrix{Float64}}}"><code>JAC.BsplinesN.setupLocalMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>`BsplinesN.setupLocalMatrix(kappa::Int64, primitives::BsplinesN.Primitives, pot::Radial.Potential, storage::Dict{String,Array{Float64,2}})          ...set-up the local parts of the generalized eigenvalue problem for the symmetry block kappa and the given (local) potential pot.          The B-spline (basis) functions are defined by primitivesL for the large component and primitivesS for the small one, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><h2 id="Electron-continuum"><a class="docs-heading-anchor" href="#Electron-continuum">Electron continuum</a><a id="Electron-continuum-1"></a><a class="docs-heading-anchor-permalink" href="#Electron-continuum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.Settings" href="#JAC.Continuum.Settings"><code>JAC.Continuum.Settings</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  Continuum.Settings</code>  ... defines a type for the parameters for computing continuum orbitals.</p><pre><code class="nohighlight hljs">+ includeExchange         ::Bool    ... True, if the exchange is to be included and false otherwise.
+ mtp                     ::Int64   ... No of grid points for which the continuum orbital(s) are to be computed.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.generateOrbitalAsymptoticCoulomb-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}" href="#JAC.Continuum.generateOrbitalAsymptoticCoulomb-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}"><code>JAC.Continuum.generateOrbitalAsymptoticCoulomb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.generateOrbitalAsymptoticCoulomb(energy::Float64, sh::Subshell, pot::Radial.Potential, settings::Continuum.Settings)</code>        ... to generate a simple relativistic and non-normalized continuum orbital but by assuming an asymptotic sin/cos behaviour          for both components at all mesh points. For this behaviour, both components and their derivatives can be calculated          analytically. The effective charge Zbar is determined for the given potential and the non-Coulombic phase shifts is set          to zero. An non-normalized cOrbital::Orbital is returned.</p><pre><code class="nohighlight hljs">    Warning: At present, only the real part eta.re is taken into account; check for consistency !!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.generateOrbitalBessel-Tuple{Float64, Subshell, JAC.Radial.Grid, JAC.Continuum.Settings}" href="#JAC.Continuum.generateOrbitalBessel-Tuple{Float64, Subshell, JAC.Radial.Grid, JAC.Continuum.Settings}"><code>JAC.Continuum.generateOrbitalBessel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.generateOrbitalBessel(energy::Float64, sh::Subshell, grid::Radial.Grid, settings::Continuum.Settings)</code>        ... to generate a simple, non-relativistic and non-normalized Bessel wave for the large component of the continuum         orbital and a small component due to the kinetic-balance condition. A (non-normalized) orbital::Orbital is returned.         While Pprime is obtained from the analytical expression of the large component, Qprime is set to zero here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.generateOrbitalForLevel-Tuple{Float64, Subshell, Level, Model, JAC.Radial.Grid, JAC.Continuum.Settings}" href="#JAC.Continuum.generateOrbitalForLevel-Tuple{Float64, Subshell, Level, Model, JAC.Radial.Grid, JAC.Continuum.Settings}"><code>JAC.Continuum.generateOrbitalForLevel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.generateOrbitalForLevel(energy::Float64, sh::Subshell, level::Level, nm::Nuclear.Model, grid::Radial.Grid, basis::Basis,                                     settings::Continuum.Settings)</code>        ... to generate a continuum orbital for the (continuum) subshell sh, the energy and the effective charge within the given          potential. The continuum orbital is generated orthogonal with regard to all subshells of the same symmetry in the basis.          All further specifications about this generations are made by proper settings. A tupel of a (continuum)          (orbital::Orbital, phase::Float64) is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.generateOrbitalGalerkin-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}" href="#JAC.Continuum.generateOrbitalGalerkin-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}"><code>JAC.Continuum.generateOrbitalGalerkin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.generateOrbitalGalerkin(energy::Float64, sh::Subshell, pot::Radial.Potential, settings::Continuum.Settings)</code>        ... to generate a non-normalized continuum orbital within the given local potential by using the Galerkin method and a          given B-spline basis. A (non-normalized) orbital::Orbital is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.generateOrbitalLocalPotential-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}" href="#JAC.Continuum.generateOrbitalLocalPotential-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}"><code>JAC.Continuum.generateOrbitalLocalPotential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.generateOrbitalLocalPotential(energy::Float64, sh::Subshell, pot::Radial.Potential, settings::Continuum.Settings)</code>        ... to generate a continuum orbital for the (continuum) subshell sh, the energy and the given potential. The effective          charge for the normalization of the continuum orbital is derived from the potential. All further specifications about          this generations are made by proper settings; however, the function termintates if the settings.includeExchange = true.          A tupel of a (continuum) (orbital::Orbital, phase::Float64, normFactor::Float64) is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.generateOrbitalNonrelativisticCoulomb-Tuple{Float64, Subshell, Float64, JAC.Radial.Grid, JAC.Continuum.Settings}" href="#JAC.Continuum.generateOrbitalNonrelativisticCoulomb-Tuple{Float64, Subshell, Float64, JAC.Radial.Grid, JAC.Continuum.Settings}"><code>JAC.Continuum.generateOrbitalNonrelativisticCoulomb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.generateOrbitalNonrelativisticCoulomb(energy::Float64, sh::Subshell, Zeff::Float64, grid::Radial.Grid,                                                      settings::Continuum.Settings)</code>        ... to generate a simple, non-relativistic and non-normalized Coulomb wave for the (continuum) subshell sh,          the small component is simply obtained by the kinetic-balance condition. A orbital::Orbital is returned.         *****         This function does not yet work because there is no Julia implementation of the hypergeometric function with          complex arguments available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.generateOrbitalNonrelativisticCoulomb-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}" href="#JAC.Continuum.generateOrbitalNonrelativisticCoulomb-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}"><code>JAC.Continuum.generateOrbitalNonrelativisticCoulomb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><ul><li><code>(energy::Float64, sh::Subshell, pot::Radial.Potential, settings::Continuum.Settings)</code>      ... to generate a simple, non-relativistic and non-normalized Coulomb wave for the (continuum) subshell sh,        the small component is simply obtained by the kinetic-balance condition. A orbital::Orbital is returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.generateOrbitalPureSine-Tuple{Float64, Subshell, JAC.Radial.Grid, JAC.Continuum.Settings}" href="#JAC.Continuum.generateOrbitalPureSine-Tuple{Float64, Subshell, JAC.Radial.Grid, JAC.Continuum.Settings}"><code>JAC.Continuum.generateOrbitalPureSine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.generateOrbitalPureSine(energy::Float64, sh::Subshell, grid::Radial.Grid, settings::Continuum.Settings)</code>        ... to generate a simple, non-relativistic and non-normalized Bessel wave for the large component of the continuum         orbital and a small component due to the kinetic-balance condition. A (non-normalized) orbital::Orbital is returned.         While Pprime is obtained from the analytical expression of the large component, Qprime is set to zero here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.gridConsistency-Tuple{Float64, JAC.Radial.Grid}" href="#JAC.Continuum.gridConsistency-Tuple{Float64, JAC.Radial.Grid}"><code>JAC.Continuum.gridConsistency</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.gridConsistency(maxEnergy::Float64, grid::Radial.Grid)</code>        ... to check the consistency of the given grid with the maximum energy of the required continuum electrons;          an error message is issued if the grid.hp = 0.   or  15 * grid.hp &lt; wavelength(maxEnergy)   or  if the grid has          less than 600 grid points. The function also returns the recommended grid point where the normalization and phase          is to be determined. This number is currently set to nrContinuum = grid.NoPoints - 200  ... to correct for the wrong          &#39;phase behaviour&#39; at large r-values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.normalizeOrbitalAlok-Tuple{Orbital, JAC.Radial.Potential, JAC.Continuum.Settings}" href="#JAC.Continuum.normalizeOrbitalAlok-Tuple{Orbital, JAC.Radial.Potential, JAC.Continuum.Settings}"><code>JAC.Continuum.normalizeOrbitalAlok</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.normalizeOrbitalAlok(cOrbital::Orbital, pot::Radial.Potential, settings::Continuum.Settings)</code>        ... to normalize the given continuum orbital with regard to a (asymptotic) wave function as per Salvat Code.          The orbitasl are normalized to unit amplitude.         An ( orbital::Orbital, (δ + Δ)::Float64, N::Float64 ) is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.normalizeOrbitalCoulombSine-Tuple{Orbital, JAC.Radial.Potential, JAC.Continuum.Settings}" href="#JAC.Continuum.normalizeOrbitalCoulombSine-Tuple{Orbital, JAC.Radial.Potential, JAC.Continuum.Settings}"><code>JAC.Continuum.normalizeOrbitalCoulombSine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.normalizeOrbitalCoulombSine(cOrbital::Orbital, pot::Radial.Potential, settings::Continuum.Settings)</code>        ... to normalize the given continuum orbital with regard to a (asymptotic) pure sine-function.          An (on-energy-scale-normalized) orbital::Orbital is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.normalizeOrbitalOngRussek-Tuple{Orbital, JAC.Radial.Potential, JAC.Continuum.Settings}" href="#JAC.Continuum.normalizeOrbitalOngRussek-Tuple{Orbital, JAC.Radial.Potential, JAC.Continuum.Settings}"><code>JAC.Continuum.normalizeOrbitalOngRussek</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.normalizeOrbitalOngRussek(cOrbital::Orbital, pot::Radial.Potential, settings::Continuum.Settings)</code>        ... to normalize the given continuum orbital with regard to a (asymptotic) pure sine-function.          An (on-energy-scale-normalized) orbital::Orbital is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.normalizeOrbitalPureSine-Tuple{Orbital, JAC.Radial.Grid, JAC.Continuum.Settings}" href="#JAC.Continuum.normalizeOrbitalPureSine-Tuple{Orbital, JAC.Radial.Grid, JAC.Continuum.Settings}"><code>JAC.Continuum.normalizeOrbitalPureSine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Continuum.normalizeOrbitalPureSine(cOrbital::Orbital, grid::Radial.Grid, settings::Continuum.Settings)</code>        ... to normalize the given continuum orbital with regard to a (asymptotic) pure sine-function.          An (on-energy-scale-normalized) orbital::Orbital and its relative phase phi w.r.t.  sin(kr + phi) is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Continuum.twoFzero-Tuple{ComplexF64, ComplexF64, ComplexF64}" href="#JAC.Continuum.twoFzero-Tuple{ComplexF64, ComplexF64, ComplexF64}"><code>JAC.Continuum.twoFzero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>function twoFzero(CA::ComplexF64, CB::ComplexF64, CZ::ComplexF64)</code>     ... Calculates the Hypergeometric function 2F0(CA,CB;1/CZ) hypergeometric asymptotic series.         Taken from Radial package by Salvat et al.         A ComplexF64 value is returned.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><h2 id="Hydrogenic-ions"><a class="docs-heading-anchor" href="#Hydrogenic-ions">Hydrogenic ions</a><a id="Hydrogenic-ions-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrogenic-ions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.energy-Tuple{Shell, Float64}" href="#JAC.HydrogenicIon.energy-Tuple{Shell, Float64}"><code>JAC.HydrogenicIon.energy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.energy(sh::Shell, Z::Float64)</code>      ... to compute the (non-relativistic) energy for the given shell and for a point-like nuclear charge Z; the energy is          printed in the current energy units to screen but is returned in Hartree. A energy::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.energy-Tuple{Subshell, Float64}" href="#JAC.HydrogenicIon.energy-Tuple{Subshell, Float64}"><code>JAC.HydrogenicIon.energy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.energy(sh::Subshell, Z::Float64)</code>      ... to computes the Dirac energy for the hydrogenic subshell sh and for point-like nucleus with nuclear charge Z;          a energy::Float64 in atomic units and without the rest energy of the electron is returned. That is the binding          energy of a 1s_1/2 electron for Z=1 is -0.50000665.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.orbital-Tuple{Subshell, Model, JAC.Radial.Grid}" href="#JAC.HydrogenicIon.orbital-Tuple{Subshell, Model, JAC.Radial.Grid}"><code>JAC.HydrogenicIon.orbital</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.orbital(sh::Subshell, nm::Nuclear.Model, grid::Radial.Grid)</code>     ... to compute a relativstic hydrogenic Dirac orbital for the given nuclear model by using an explicit diagonalization          of the Dirac Hamiltonian in a B-spline basis; an orbital::Radial.Orbital is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.radialOrbital-Tuple{Shell, Float64, Float64}" href="#JAC.HydrogenicIon.radialOrbital-Tuple{Shell, Float64, Float64}"><code>JAC.HydrogenicIon.radialOrbital</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.radialOrbital(sh::Shell, Z::Float64, r::Float64)</code>     ... to compute the (non-relativistic) orbital function P(r) for the given shell and nuclear charge Z;          a value::Float64 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.radialOrbital-Tuple{Shell, Float64, JAC.Radial.Grid}" href="#JAC.HydrogenicIon.radialOrbital-Tuple{Shell, Float64, JAC.Radial.Grid}"><code>JAC.HydrogenicIon.radialOrbital</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.radialOrbital(sh::Shell, Z::Float64, grid::Radial.Grid)</code>     ... to compute the same but for all r-values as specified by the given grid; a PList::Array{Float64,1} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.radialOrbital-Tuple{Shell, Float64, Vector{Float64}}" href="#JAC.HydrogenicIon.radialOrbital-Tuple{Shell, Float64, Vector{Float64}}"><code>JAC.HydrogenicIon.radialOrbital</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.radialOrbital(sh::Shell, Z::Float64, rlist::Array{Float64,1})</code>     ... to compute the same but for an array of r-values [r<em>1, r</em>2, ...]; a PList::Array{Float64,1} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.radialOrbital-Tuple{Subshell, Float64, Float64}" href="#JAC.HydrogenicIon.radialOrbital-Tuple{Subshell, Float64, Float64}"><code>JAC.HydrogenicIon.radialOrbital</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.radialOrbital(sh::Subshell, Z::Float64, r::Float64)</code>     ... to compute a relativistic hydrogenic Dirac orbital for the given subshell and nuclear charge Z;          a value::Float64 is returned; contributed by C Naumann (2022).         Implementation of the analytical solution of the Dirac equation for a point-like nucleus following the book by         Johnson: Atomic Structure Theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.radialOrbital-Tuple{Subshell, Float64, JAC.Radial.Grid}" href="#JAC.HydrogenicIon.radialOrbital-Tuple{Subshell, Float64, JAC.Radial.Grid}"><code>JAC.HydrogenicIon.radialOrbital</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.radialOrbital(sh::Subshell, Z::Float64, grid::Radial.Grid)</code>     ... to compute a relativistic hydrogenic Dirac orbital on the given grid;          an Array with the large and small component is returned; contributed by C Naumann (2022).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.radialOrbital-Tuple{Subshell, Model, JAC.Radial.Grid}" href="#JAC.HydrogenicIon.radialOrbital-Tuple{Subshell, Model, JAC.Radial.Grid}"><code>JAC.HydrogenicIon.radialOrbital</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.radialOrbital(sh::Subshell, nm::Nuclear.Model, grid::Radial.Grid)</code>     ... to compute a relativstic hydrogenic Dirac orbital for the given nuclear model by using an explicit diagonalization          of the Dirac Hamiltonian in a B-spline basis; an orbital::Radial.Orbital is returned; contributed by C Naumann (2022).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.radialOrbital_old2022-Tuple{Subshell, Float64, JAC.Radial.Grid}" href="#JAC.HydrogenicIon.radialOrbital_old2022-Tuple{Subshell, Float64, JAC.Radial.Grid}"><code>JAC.HydrogenicIon.radialOrbital_old2022</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.radialOrbital_old2022(sh::Subshell, Z::Float64, grid::Radial.Grid)</code>     ... to compute a relativstic hydrogenic Dirac orbital on the given grid by applying the kinetic-balance to a          corresponding non-relavistic orbital; an orbital::Radial.Orbital is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.radialOrbital_old2022-Tuple{Subshell, Model, JAC.Radial.Grid}" href="#JAC.HydrogenicIon.radialOrbital_old2022-Tuple{Subshell, Model, JAC.Radial.Grid}"><code>JAC.HydrogenicIon.radialOrbital_old2022</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.radialOrbital_old2022(sh::Subshell, nm::Nuclear.Model, grid::Radial.Grid)</code>     ... to compute a relativstic hydrogenic Dirac orbital for the given nuclear model by using an explicit diagonalization         of the Dirac Hamiltonian in a B-spline basis; an orbital::Radial.Orbital is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.HydrogenicIon.rkExpectation-Tuple{String, Shell, Float64}" href="#JAC.HydrogenicIon.rkExpectation-Tuple{String, Shell, Float64}"><code>JAC.HydrogenicIon.rkExpectation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HydrogenicIon.rkExpectation(srk::String, sh::Shell, Z::Float64)</code>     ... to compute the (non-relativistic) r^k expectation value for the shell sh of an ion with charge Z;         a value::Float64 [in a_o^k] is returned. The string can takes values srk = [&quot;r&quot;, &quot;r^2&quot;, &quot;1/r&quot;]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><h2 id="Spin-angular-coefficients"><a class="docs-heading-anchor" href="#Spin-angular-coefficients">Spin angular coefficients</a><a id="Spin-angular-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Spin-angular-coefficients" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.SpinAngular.AbstractAngularType" href="#JAC.SpinAngular.AbstractAngularType"><code>JAC.SpinAngular.AbstractAngularType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>abstract type SpinAngular.AbstractAngularType</code>      ... defines an abstract type and a number of data types to work with one- and two-particle operators of given rank, see also:</p><pre><code class="nohighlight hljs">+ struct OneParticleOperator    ... to represent a single-particle operator with well-defined spherical tensor rank.
+ struct TwoParticleOperator    ... to represent a two-particle operator with well-defined spherical tensor rank.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.SpinAngular.Coefficient1p" href="#JAC.SpinAngular.Coefficient1p"><code>JAC.SpinAngular.Coefficient1p</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  SpinAngular.Coefficient1p</code>       ... a struct for defining a single spin-angular coefficient for a reduced one-particle matrix element &lt;a || o^(L) || b&gt;.</p><pre><code class="nohighlight hljs">+ nu       ::Int64             ... Rank (L or nu) of the single-particle interaction strength.
+ a        ::Subshell          ... Left-hand subshell (orbital).
+ b        ::Subshell          ... Right-hand subshell (orbital).
+ T        ::Float64           ... (Value of) spin-angular coefficient.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.SpinAngular.Coefficient2p" href="#JAC.SpinAngular.Coefficient2p"><code>JAC.SpinAngular.Coefficient2p</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  SpinAngular.Coefficient2p</code>       ... a struct for defining a single spin-angular coefficient for a reduced two-particle matrix element &lt;ab || o^(L) || cd&gt;,         such as the Coulomb interaction strength.</p><pre><code class="nohighlight hljs">+ nu       ::Int64             ... Rank (L or nu) of the single-particle interaction strength.
+ a        ::Subshell          ... Left-hand subshell (orbital).
+ b        ::Subshell          ... Left-hand subshell (orbital).
+ c        ::Subshell          ... Right-hand subshell (orbital).
+ d        ::Subshell          ... Right-hand subshell (orbital).
+ V        ::Float64           ... (Value of) spin-angular coefficient.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.SpinAngular.DiagramC01" href="#JAC.SpinAngular.DiagramC01"><code>JAC.SpinAngular.DiagramC01</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  SpinAngular.Diagram</code>       ... to defines various singleton() structs in order to distinguish between different coupling schemes of the          matrix elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.SpinAngular.OneParticleOperator" href="#JAC.SpinAngular.OneParticleOperator"><code>JAC.SpinAngular.OneParticleOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  SpinAngular.OneParticleOperator  &lt;:  AbstractAngularType</code>       ... a struct for defining the spherial tensor structure of a single-particle operator.</p><pre><code class="nohighlight hljs">+ rank            ::Int64             ... Rank of the operator.
+ parity          ::Basics.Parity     ... Parity of the operator (if needed ??)
+ sameOrbitalSet  ::Bool              ... True if orbitals for both CSF are taken from the same orbital set (if needed ??)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.SpinAngular.OneParticleOperator-Tuple{}" href="#JAC.SpinAngular.OneParticleOperator-Tuple{}"><code>JAC.SpinAngular.OneParticleOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>SpinAngular.OneParticleOperator()</code>  ... constructor for setting the default values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.SpinAngular.QspaceTerm" href="#JAC.SpinAngular.QspaceTerm"><code>JAC.SpinAngular.QspaceTerm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  SpinAngular.QspaceTerm</code>       ... a struct for defining a subshell term/state  |j (nu) alpha Q J&gt; == |j (nu) Q J Nr&gt; for a subshell with well-defined j.</p><pre><code class="nohighlight hljs">+ j        ::AngularJ64   ... subshell j
+ Q        ::AngularJ64   ... quasi-spin
+ J        ::AngularJ64   ... total J of subshell term
+ Nr       ::Int64        ... Additional quantum number Nr = 0,1,2.
+ min_odd  ::Int64        ... the minimal limits of the subshell terms for odd number operators in second quantization
+ max_odd  ::Int64        ... the maximal limits of the subshell terms for odd number operators in second quantization
+ min_even ::Int64        ... the minimal limits of the subshell terms for even number operators in second quantization
+ max_even ::Int64        ... the maximal limits of the subshell terms for even number operators in second quantization</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.SpinAngular.SchemeEta_a" href="#JAC.SpinAngular.SchemeEta_a"><code>JAC.SpinAngular.SchemeEta_a</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  SpinAngular.SchemeEta</code>       ... to define various singleton structs in order to distinguish between different irreducible tensors          and matrix elements.</p><pre><code class="nohighlight hljs">+ Eta_a         ... a^(qj)_mq
+ Eta_W         ... W^(k_12) = [a x a]
+ Eta_aW        ... W^(k_12, k_2) = [a1 x [a2 x a3]]
+ Eta_Wa        ... W^(k_12, k_2) = [[a1 x a2] x a3]
+ Eta_WW        ... W^(kk0) = [[a1 x a2]^k x [a3 x a4]^k]^0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.SpinAngular.TwoParticleOperator" href="#JAC.SpinAngular.TwoParticleOperator"><code>JAC.SpinAngular.TwoParticleOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  SpinAngular.TwoParticleOperator</code>       ... a struct for defining the spherial tensor structure of a two-particle operator.</p><pre><code class="nohighlight hljs">+ rank            ::Int64             ... Rank of the operator (if needed ??).
+ parity          ::Basics.Parity     ... Parity of the operator (if needed ??)
+ sameOrbitalSet  ::Bool              ... True if orbitals for both CSF are taken from the same orbital set (if needed ??)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.SpinAngular.TwoParticleOperator-Tuple{}" href="#JAC.SpinAngular.TwoParticleOperator-Tuple{}"><code>JAC.SpinAngular.TwoParticleOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>SpinAngular.TwoParticleOperator()</code>  ... constructor for setting the default values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="api-properties.html">« API Atomic properties</a><a class="docs-footer-nextpage" href="api-cascades.html">API Cascade computations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 24 April 2025 13:16">Thursday 24 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
