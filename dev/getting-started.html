<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · JAC.jl</title><meta name="title" content="Getting Started · JAC.jl"/><meta property="og:title" content="Getting Started · JAC.jl"/><meta property="twitter:title" content="Getting Started · JAC.jl"/><meta name="description" content="Documentation for JAC.jl."/><meta property="og:description" content="Documentation for JAC.jl."/><meta property="twitter:description" content="Documentation for JAC.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">JAC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="getting-started.html">Getting Started</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#...-with-Julia-(in-REPL)"><span>... with Julia (in REPL)</span></a></li><li class="toplevel"><a class="tocitem" href="#...-with-JAC-(in-REPL)"><span>... with JAC (in REPL)</span></a></li></ul></li><li><a class="tocitem" href="demos.html">Demos</a></li><li><a class="tocitem" href="examples.html">Examples</a></li><li><a class="tocitem" href="news.html">News</a></li><li><a class="tocitem" href="api-atomic.html">API Atomic computations</a></li><li><a class="tocitem" href="api-processes.html">API Atomic processes</a></li><li><a class="tocitem" href="api-properties.html">API Atomic properties</a></li><li><a class="tocitem" href="api-basics.html">API Basics</a></li><li><a class="tocitem" href="api-cascades.html">API Cascade computations</a></li><li><a class="tocitem" href="api-empirical.html">API Empirical computations</a></li><li><a class="tocitem" href="api-plasma.html">API Plasma computations</a></li><li><a class="tocitem" href="api-racah.html">API Racah algebra</a></li><li><a class="tocitem" href="reference.html">Bibliography to JAC</a></li><li><a class="tocitem" href="getting-involved.html">Getting involved</a></li><li><a class="tocitem" href="contributors.html">Contributors</a></li><li><a class="tocitem" href="license.html">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="getting-started.html">Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="getting-started.html">Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/OpenJAC/JAC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/OpenJAC/JAC.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h1><h1 id="...-with-Julia-(in-REPL)"><a class="docs-heading-anchor" href="#...-with-Julia-(in-REPL)">... with Julia (in REPL)</a><a id="...-with-Julia-(in-REPL)-1"></a><a class="docs-heading-anchor-permalink" href="#...-with-Julia-(in-REPL)" title="Permalink"></a></h1><p>Getting started with Julia (in REPL)</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Link to the Pluto jl and direct start with  example...</p></div></div><p>Here, we shall <strong>not introduce</strong> Julia&#39;s syntax and concepts for which many tutorials are available on the web.  Instead, we just wish to remind and highlight some simple (syntax) features that help to go easier around with JAC, and  especially for occasional users from experiment or teaching. This reminder aims to lower the initial <em>threshold</em> for users  that have been trained on other languages in the past. Here, we shall <em>pick up</em> some issues whose physics background  is explained only later in other tutorial. Obviously, however, Julia is a very rich and powerful language with many  features that go well beyond of what is (and will ever) needed for JAC.</p><p>In brief, JAC provides tools for performing atomic (structure) calculations of different kind and complexity, and for  which further details are given in the tutorials below. To see anything from JAC, we shall first invoke the tools by:</p><pre><code class="language-julia hljs">using JAC</code></pre><p>a line that will appear at the beginning of all subsequent tutorials. – A first powerful and frequently needed feature  refers to Julia&#39;s help pages or just the &quot;?&quot;. By typing, for instance, atom or computation</p><pre><code class="nohighlight hljs">? atom</code></pre><pre><code class="nohighlight hljs">search: atomic Atomic AtomicState AtomicCompass AtomicStructure @atomic @atomicswap @atomicreplace

Couldn&#39;t find atom
Perhaps you meant atomic, atan, acot, acos, htol, hton, ltoh, ntoh, Atomic, @atomic, pathof, atand, atanh, cat, 
match, catch, stat, acotd, acoth, add, ans, abs, abs2, acosd, acosh, acsc, all, all!, any, any!, asec, asin, axes, 
as, tan or Beam
No documentation found.

Binding atom does not exist.</code></pre><p>we see, that <code>atom</code> itself is not a well-defined term in the JAC toolbox but that there exists a number of related  terms, such as <code>Atomic</code>, <code>AtomicState</code> (two modules of JAC) and others. We shall not enter here the modular structure  of the JAC toolbox but start much simpler with: </p><pre><code class="nohighlight hljs">? Orbital</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Radial.Orbital-getting-started" href="#JAC.Radial.Orbital-getting-started"><code>JAC.Radial.Orbital</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  Radial.Orbital</code>       ... defines a type for a single-electron radial orbital function with a large and small component, and which can refer to         either the standard or an explicitly given grid due to the logical flag useStandardGrid. Bound-state orbitals with energy &lt; 0 are          distinguished from free-electron orbitals by the flag isBound.</p><pre><code class="nohighlight hljs">+ subshell        ::Subshell          ... Relativistic subshell.
+ isBound         ::Bool              ... Logical flag to distinguish between bound (true) and free-electron orbitals (false).
+ useStandardGrid ::Bool              ... Logical flag for using the standard grid (true) or an explicitly given grid (false).
+ energy          ::Float64           ... Single-electron energies of bound orbitals are always negative.
+ P               ::Array{Float64,1}  ... Large and ..
+ Q               ::Array{Float64,1}  ... small component of the radial orbital.
+ Pprime          ::Array{Float64,1}  ... dP/dr.
+ Qprime          ::Array{Float64,1}  ... dQ/dr.
+ grid            ::Array{Float64,1}  ... explic. defined radial grid array for P, Q, if StandardGrid = false.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>which, apart from its formal meaning, is a particular data structure (<code>struct</code>) of JAC and which represents a  relativistic orbital (function) including additional information that appears helpful in the given implementation. There  are very many (say, more than 300) of such data struct&#39;s specified in the JAC toolbox, and thus quite obvious that nobody will remember the details of all these definitions. Indeed, the &quot;?&quot; is the right and a powerful means to remind  yourself and make use of these data structures whenever necessary. Special care has been taken that all data structures  and functions/methods comes with a reasonable explanation (docstring) in order to work efficiently with JAC.</p><p>For instance, we might ask of what can be <em>added</em> to each other in JAC:</p><pre><code class="nohighlight hljs">? add</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Basics.add-getting-started" href="#JAC.Basics.add-getting-started"><code>JAC.Basics.add</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Basics.add(pota::Radial.Potential, potb::Radial.Potential)</code>       ... to add two radial potentials together that are defined on the same grid. A potential::RadialPotential is returned          that inherits its radial size from the potential that is defined in a larger range of r-values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.add(ma::AngularM64, mb::AngularM64)</code>       ... adds the projections of the angular momenta ma + mb and returns a mc::AngularM64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>Apart from a short explanation, these docstring always tell the user (i) in which module the method is defined;  (ii) which arguments it takes, including Julia&#39;s <em>multiple dispatch</em> feature as well as (iii) the type of the return  value. All these information are typically relevant to the user, especially if some input or output does not behave as  it should. Indeed, the complexity can grow quite rapidly, for instance, if we ask for help of what we can <code>generate</code>:</p><pre><code class="nohighlight hljs">? generate</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Basics.generate-getting-started" href="#JAC.Basics.generate-getting-started"><code>JAC.Basics.generate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Basics.generate(representation::AtomicState.Representation)</code>       ... to generate an atomic representation as specified by the representation.repType::AbstractRepresentationType.         All relevant intermediate and final results are printed to screen (stdout). Nothing is returned.</p><p><code>Basics.perform(representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.MeanFieldBasis, representation::AtomicState.Representation)</code>       ... to generate a mean-field basis (representation) for a set of reference configurations; all relevant intermediate          and final results are printed to screen (stdout). Nothing is returned.</p><p><code>Basics.generate(repType::AtomicState.MeanFieldBasis, representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.MeanFieldMultiplet, representation::AtomicState.Representation)</code>       ... to generate a mean-field basis (representation) for a set of reference configurations; all relevant intermediate          and final results are printed to screen (stdout). Nothing is returned.</p><p><code>Basics.generate(repType::AtomicState.MeanFieldMultiplet, representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.OneElectronSpectrum, representation::AtomicState.Representation)</code>       ... to generate a one-electron spectrum for the atomic potential from the (given) levels, based on a set of reference          configurations as well as for given settings. Relevant intermediate and final results are printed to screen (stdout).          Nothing is returned in this case.</p><pre><code class="nohighlight hljs">+ `(repType::AtomicState.OneElectronSpectrum, representation::AtomicState.Representation; output=true)`  
... to generate the same but to return the complete output in a orbitals::Dict{Subshell, Orbital}.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.CiExpansion, representation::AtomicState.Representation)</code>       ... to generate a configuration-interaction expansion for a single level symmetry and based on a set of reference configurations         and a number of pre-specified steps. All relevant intermediate and final results are printed to screen (stdout).          Nothing is returned.</p><p><code>Basics.generate(repType::AtomicState.CiExpansion, representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the computations but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.RasExpansion, representation::AtomicState.Representation)</code>       ... to generate a restricted active-space expansion for a single level symmetry and based on a set of reference configurations         and a number of pre-specified steps. All relevant intermediate and final results are printed to screen (stdout).          Nothing is returned.</p><p><code>Basics.generate(repType::AtomicState.RasExpansion, representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the computations but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.GreenExpansion, representation::AtomicState.Representation)</code>       ... to generate a Green (function) expansion for a given approach and excitation scheme of the electron,         based on a set of reference configurations, a list of level symmetries as well as for given settings.         All relevant intermediate and final results are printed to screen (stdout). Nothing is returned.</p><p><code>Basics.generate(repType::AtomicState.GreenExpansion, representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;condensed multiplet: by single weight&quot;, multiplet::Multiplet)</code>       ... to condense/reduce the number of CSF in the basis of the given multiplet due to a single &#39;weight&#39;;          a multiplet::Multiplet is returned.  <strong>Not yet implemented !</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;configuration list: NR, from basis&quot;, basis::Basis)</code>       ... to (re-) generate the list of NR configurations from the given basis; a confList::Array{Configuration,1} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;configuration list: NR, single-configuration&quot;, refConf::Configuration, NoExcitations::Int64, fromShells::Array{Shell,1},</code>                     toShells::Array{Shell,1})       ... to generate a non-relativistic configuration list, including the given reference configuration (refConf) and with          all configurations that differ by NoExcitations from the fromShells into the toShells; an Array{Configuration,1}          is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;shells: ordered list for NR configurations&quot;, confs::Array{Configuration,1})</code>       ... to generate for confs, i.e. all the given (non-relativistic) configurations, a common and ordered shell list;          a list::Array{Shell,1} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;subshells: ordered list for two bases&quot;, basisA::Basis,  basisB::Basis)</code>       ... to generate common and ordered subshell list for the two basis A and B; a list::Array{Subshell,1} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;single-electron spectrum: STO&quot;, N::Int64, potential::Radial.Potential, grid::Radial.Grid; N_0::Int64=30, alpha_0::Float64=1.0,                     beta_0::Float64=1.1)</code>      ... to generate a complete one-electron spectrum with N positive and N negative states, and by using even-tempered Slater-type          orbitals (STO) with parameters <span>$lpha_i = lpha_0 eta_0^i$</span>; a spectrum::SingleElecSpectrum is returned where just          N0 positive and N_0 negative are kept for later use.  <strong>Not yet implemented !</strong></p><p><code>Basics.generate(&quot;single-electron spectrum: STO, positive&quot;, N::Int64, potential::Radial.Potential, grid::Radial.Grid; N_0::Int64=30, alpha_0::Float64=1.0,                     beta_0::Float64=1.1)</code>       ... to generate the same but to return only the N_0 positive states.  <strong>Not yet implemented !</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>Well, this is quite a lot, and we shall explain some of these methods below; a similar or even larger output, you can  generate by <code>? perform</code> as well as few other terms that are central to the implementation of JAC.</p><p><strong>Constructors &amp; program control:<span>$\quad$</span></strong> Another frequent use of the (help) &quot;?&quot; concerns the data flow and control of  almost all computations. In JAC, we often make use of (so-called) <code>Settings</code> that enable the user to overwrite default  values or to <em>control</em> the computation to the extent, he or she wishes to have control. These <code>Settings</code> are context  dependent and are different for each atomic property or process that can be computed by the JAC toolbox. They are defined  in the various modules and need to be specified accordingly. For instance, to control the computation of transition  probabilities for the (fine-structure) levels between given initial- and final-state configuration, one has to overwrite  the (defaults) settings:</p><pre><code class="nohighlight hljs">? PhotoEmission.Settings</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.PhotoEmission.Settings-getting-started" href="#JAC.PhotoEmission.Settings-getting-started"><code>JAC.PhotoEmission.Settings</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  PhotoEmission.Settings  &lt;:  AbstractProcessSettings</code>       ... defines a type for the details and parameters of computing radiative lines.</p><pre><code class="nohighlight hljs">+ multipoles              ::Array{EmMultipoles}     ... Specifies the (radiat. field) multipoles to be included.
+ gauges                  ::Array{UseGauge}         ... Gauges to be included into the computations.
+ calcAnisotropy          ::Bool                    ... True, if the anisotropy (structure) functions are to be 
                                                        calculated and false otherwise 
+ printBefore             ::Bool                    ... True, if all energies and lines are printed before comput.
+ corePolarization        ::CorePolarization        ... Parametrization of the core-polarization potential/contribution.
+ lineSelection           ::LineSelection           ... Specifies the selected levels, if any.
+ photonEnergyShift       ::Float64                 ... An overall energy shift for all photon energies.
+ mimimumPhotonEnergy     ::Float64                 ... minimum transition energy for which (photon) transitions 
                                                        are included into the computation.
+ maximumPhotonEnergy     ::Float64                 ... maximum transition energy for which (photon) transitions 
                                                        are included.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>We shall meet these and (many) other settings quite often in the tutorials below. –- Beside of Julia&#39;s help features (?), however, it is sometimes difficult to remember the right term or function name. In this case, it easy to make a &lt;double-tab&gt;  after the dot (notation) or to make use of the (Unix/Linux) <code>grep</code> command within the <code>JAC/src</code> directly. Similar  line-search commands will exist also at other platforms. In particular, for those of you who wishes to support and extend  the JAC toolbox, the dot expansion and the <code>grep</code> command will be found very helpful, perhaps more than other search tools.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Users can also refer to the API Reference section that provides a comprehensive list of JAC declared <code>Type</code>s and <code>Function</code>s  for selected atomic processes.</p></div></div><p><strong>Use of constructors:<span>$\quad$</span></strong> Another Julia feature, that is frequently applied in JAC, is the successive definition of  constructors in order to set-up complex data structures. This features is applied, for instance, in order to define an  <code>Atomic.Computation</code> or a <code>Cascade.Computation</code> as a whole. We shall explain these rather complex data types below in  different tutorials. The same issue appears however already at a much simpler level. For example, if we wish to select  (specify) a number of levels from a multiplet prior to some particular – configuration interaction – computation,  we can make use of a</p><pre><code class="nohighlight hljs">? LevelSelection</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Basics.LevelSelection-getting-started" href="#JAC.Basics.LevelSelection-getting-started"><code>JAC.Basics.LevelSelection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  Basics.LevelSelection  &lt;  Basics.AbstractSelection</code>       ... defines a struct to specify a list of levels by means of their (level) indices or level symmetries.</p><pre><code class="nohighlight hljs">+ active       ::Bool                     ... true, if some selection has been made.
+ indices      ::Array{Int64,1}           ... List of selected indices.
+ symmetries   ::Array{LevelSymmetry,1}   ... List of selected symmetries</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>Apart from the logical flag <code>active</code>, such a level selection requires to either specify a list of level numbers (indices)  or <em>level symmetries</em></p><pre><code class="language-julia hljs">LevelSelection(true, indices= [i for i in 1:11])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LevelSelection:  indices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];    symmetries = LevelSymmetry[].</code></pre><pre><code class="language-julia hljs">LevelSelection(true, symmetries= [LevelSymmetry(1//2, Basics.plus)])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LevelSelection:  indices = Int64[];    symmetries = LevelSymmetry[1/2 +].</code></pre><p>Here, we made use of a LevelSymmetry to specify the overall rotational <span>$J^P$</span> symmetry of atomic levels.</p><pre><code class="nohighlight hljs">? LevelSymmetry</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Basics.LevelSymmetry-getting-started" href="#JAC.Basics.LevelSymmetry-getting-started"><code>JAC.Basics.LevelSymmetry</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  Basics.LevelSymmetry  &lt;  AbstractAngularMomentum</code>  ... defines a struct for defining the overall J^P symmetry of a level.</p><pre><code class="nohighlight hljs">+ J          ::AngularJ64  ... total angular momentum of a level
+ parity     ::Parity      ... total parity of the level</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>As seen from this definition, the level symmetry just comprises the total angular momentum (of type <code>AngularJ64</code>) and  the parity of the level (of type <code>Parity</code>). Therefore, the specification of a list of level symmetries in <code>LevelSelection</code>  already requires to nest four constructors in order make the level selection explicit: (i) For the angular momentum,  (ii) the parity, (iii) the level symmetry and (iv) to create a list (array) of such level symmetries. All the constructors  can be specified and built together also in subsequent steps, such as:</p><pre><code class="language-julia hljs">J1    = AngularJ64(1//2);           J2 = AngularJ64(5//2)
pl    = Basics.plus;                mn = Basics.minus
lsym1 = LevelSymmetry(J1, pl);      lsym2 = LevelSymmetry(J2, mn)
levelsyms = [lsym1, lsym2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{LevelSymmetry}:
 1/2 +
 5/2 -</code></pre><p>or simply by <em>nesting</em> all the information within a single step</p><pre><code class="language-julia hljs">levelsyms = [LevelSymmetry(AngularJ64(1//2), Basics.plus), LevelSymmetry(AngularJ64(5//2), Basics.minus)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{LevelSymmetry}:
 1/2 +
 5/2 -</code></pre><p>Both way have their pros and cons, and often some <em>mixture</em> is applied where complex constructors are first assigned to  some variables, and which are later utilized to built up constructors of higher complexity. –- To finally specify aǹ  instance of a <code>LevelSelection</code>, we use (onc more) its second constructor above:</p><pre><code class="language-julia hljs">LevelSelection(true, indices=[1,2,3], symmetries=levelsyms)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LevelSelection:  indices = [1, 2, 3];    symmetries = LevelSymmetry[1/2 +, 5/2 -].</code></pre><p>and which will tell the JAC program to compute the lowest three levels (1, 2, 3) as well as all levels with 1/2+ and 5/2-  symmetry. Apart from the selection of individual levels, it is often helpful for the computation of atomic processes to  make a prior <code>LineSelection</code> and in some cases even a <code>PathwaySelection</code> as, for instance, for dielectronic recombination  processes. Some of these features will be explained below in subsequent tutorials of JAC:</p><p><strong>Functions &amp; methods:<span>$\quad$</span></strong> Like most other languages, Julia is based on the successive work through functions and  methods; a <strong>function</strong> is first of all specified by its name and it maps a tuple of argument values upon a return value.  For instance, the function</p><pre><code class="language-julia hljs">function addSomething(a, b)
    c = a + b
end
addSomething(3.1, 5//2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.6</code></pre><p>can be used to <em>add</em> two numbers, rather independent of their particular type, and which are <em>infered</em> here automatically.  However, additional type declarations might help to <em>specialize</em> a function and to ensure <strong>type stability</strong>:</p><pre><code class="language-julia hljs">function addSomething(a::Int64, b::Int64, c::Int64)
    d = a + b + c
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">addSomething (generic function with 2 methods)</code></pre><p>While the function name is the same in both of these examples above, Julia carefully distinguishes between these two  <strong>methods</strong> of the function <code>addSomething</code> that may differ by the type <em>and/or</em> the number of arguments. This multiple  <em>use</em> <strong>(dispatch)</strong> of function name enables the user to write highly specialized code. Although a proper (and specialized)  definition of functions is often very important for the performance of the program, we shall not discuss such technical  issues here. Let us just mention, that a function/method may also return <code>nothing</code>:</p><pre><code class="language-julia hljs">typeof(nothing)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Nothing</code></pre><p>In JAC, the value <code>nothing</code> is usually returned by all <em>display</em> functions that print some selected data or tabulation  to screen or elsewhere but does not return a value otherwise.</p><p><strong>Code failures:<span>$\quad$</span></strong> Beside of its large flexibility and user-friendliness, JAC might terminate from time to time  for <em>non-obvious</em> reasons. Since JAC is first of all a <em>physics code</em>, no attempt has been made that all possible errors  are fully captured and recovered by the program. Wrong input parameters or an inappropriate use of contructors will often  lead to errors that cannot be resolved by the program. While some of this input can be readily recognized as wrong, and  then lead to a proper error message, other wrong data may appear dynamically and cannot be captured with a reasonable  overhead of the code.  In JAC, therefore, several conditional <code>if ... elseif ... else ... end</code> blocks include an additional  clause <code>error(&quot;stop a&quot;)</code> or similar; these are clauses, which due to a first design of a function should never be entered,  but this appears not to be true in all cases. The use of these (fully) <em>non-instructive</em> error message have still a great  advantage due to Julia: If not switched-off explicitly, Julia always reports for all program failures the hierarchy of  call&#39;s, that are made before the error occurs, and lists these calls together with the file and line number of source code. For this reason, an <code>error(&quot;stop a&quot;)</code> readily shows the position where something unexpected occurs. A short inspection of  the corresponding (line of the) source code often help to understand of what went wrong internally.</p><p><strong>Julia macros:<span>$\quad$</span></strong>  What can one do, if the (source) code itself does not tell so much about the problem ? –-  In this case, it is often useful to include some additional <strong>printouts</strong>  near to the line in question into the code  and to re-run it again. There are different ways (<code>@show</code>, <code>print()</code>, <code>println()</code>) to place printout in the code;  cf. https://julialang.org/learning/  A particular quick and useful way makes use of the Julia macro:</p><pre><code class="language-julia hljs">@show levelsyms</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{LevelSymmetry}:
 1/2 +
 5/2 -</code></pre><p>which simply repeats the <em>names</em> of the variables together with their values. Of course, the values of several such  variables can be shown within the same call:</p><pre><code class="language-julia hljs">wa = 5;   wb = [2.0, pi];   wc = ones(3)
@show wa, wb, wc</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(5, [2.0, 3.141592653589793], [1.0, 1.0, 1.0])</code></pre><p>Indeed, this <code>@show</code> macro makes printout very easy. There are many macros (all starting with <code>@</code>) in Julia which need  not to be considered here. We just mention that <code>@time</code> in front of a Julia command (block) will take and display the CPU  time that is necessary to run this line(s):</p><pre><code class="language-julia hljs">@time rand(50000)   ;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">50000-element Vector{Float64}:
 0.9646589793164261
 0.3049627534154046
 0.6092853528495603
 0.8134357590161992
 0.7676248867570503
 0.7736349503192512
 0.07588129390500442
 0.12439875813667256
 0.697884307743819
 0.5379800940847542
 ⋮
 0.8696604102015049
 0.8984235370987562
 0.42920434110584793
 0.5211026295399492
 0.4338150961708591
 0.8015313516504852
 0.28564996409860033
 0.39285484995102127
 0.4423019955325588</code></pre><h1 id="...-with-JAC-(in-REPL)"><a class="docs-heading-anchor" href="#...-with-JAC-(in-REPL)">... with JAC (in REPL)</a><a id="...-with-JAC-(in-REPL)-1"></a><a class="docs-heading-anchor-permalink" href="#...-with-JAC-(in-REPL)" title="Permalink"></a></h1><p>Getting started with JAC (in REPL)</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>JAC user guide pdf .... link</p></div></div><pre><code class="language-julia hljs">using JAC</code></pre><h3 id="Welcome-to-**JAC**,-the-**Jena-Atomic-Calculator**"><a class="docs-heading-anchor" href="#Welcome-to-**JAC**,-the-**Jena-Atomic-Calculator**">Welcome to <strong>JAC</strong>, the <strong>Jena Atomic Calculator</strong></a><a id="Welcome-to-**JAC**,-the-**Jena-Atomic-Calculator**-1"></a><a class="docs-heading-anchor-permalink" href="#Welcome-to-**JAC**,-the-**Jena-Atomic-Calculator**" title="Permalink"></a></h3><p>... that provides various tools for performing atomic (structure) calculations of different kinds and complexities.  Apart from the computation of atomic (many-electron) amplitudes, properties and processes, <strong>JAC supports interactive,  restricted-active space (RAS) and cascade computations</strong>. It also help perform a few simple <em>hydrogenic</em> and  <em>semi-empirical</em> estimates as well as simplify symbolic expressions from Racah&#39;s algebra. –-  Let&#39;s first use  <code>? JAC</code> in order to obtain more information about this toolbox:</p><pre><code class="nohighlight hljs">? JAC</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC-getting-started" href="#JAC-getting-started"><code>JAC</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>module JAC</code>       ... Jena Atomic Calculator (JAC) provides tools for performing atomic (structure) calculations at various degrees of complexity          and sophistication. It has been designed to not only calculate atomic level structures and properties [such as g-factors or         hyperfine and isotope-shift parameters] but also transition amplitudes between bound-state levels [for the anapole moment, dipole          operator, electron electric-dipole moment, parity non-conservation, etc.] and, in particular, (atomic) transition probabilities,          Auger rates, photoionization cross sections, radiative and dielectronic recombination rates as well as cross sections for many          other (elementary) processes. JAC also facilitates interactive computations, the simulation of atomic cascades, the time-evolution          of statistical tensors, a few semi-empirical estimates of atomic properties as well as the simplification of symbolic expressions         from Racah&#39;s algebra. – In addition, the JAC module supports the display of level energies, electron and photon spectra,          radial orbitals and other atomic data.</p><p><strong><code>Perform (atomic) computations of different complexity:</code></strong>       JAC will eventually support <strong>ten kinds</strong> of computations which can be summarized as follows:</p><ul><li>Atomic computations, based on explicitly specified electron configurations.</li><li>Restricted active-space computations (RAS).</li><li>Interactive computations.</li><li>Atomic cascade computations (partly implemented).</li><li>Atomic representations (Green and close-coupling functions, complex rotation; partly implemented).</li><li>Atomic responses (partly implemented).</li><li>Atomic descriptors for machine learning algorithms (not yet implemented).</li><li>Time-evolution of statistical tensors in (intense) light pusles (not yet implemented).</li><li>Semi-empirical estimates of cross sections, etc. (partly implemented).</li><li>Symbolic evaluation of expressions from Racah&#39;s algebra, etc.</li></ul><p><strong><code>Further details and information</code></strong></p><pre><code class="nohighlight hljs">    + Kinds of atomic implementation                                       [cf. ? Details.kindsOfComputation]
    + Atomic amplitudes (partly) implemented in JAC                        [cf. ? Details.amplitudes]
    + Atomic level properties (partly) implemented in JAC                  [cf. ? Details.properties]
    + Atomic processes (partly) implemented in JAC                         [cf. ? Details.processes]
    + Interactive use of JAC procedures                                    [cf. ? Details.interactive]
    + Design principles and limitations of the JAC program                 [cf. ? Details.design]
    + Data types, structs and name conventions of the JAC module           [cf. ? Details.datatypes]
    + Atomic cascade computations and approximations                       [cf. ? Details.decayCascades]
    + Use of (em) light pulses in the time evolution of statist. tensors   [cf. ? Details.pulses]
    + Why Julia ?                                                          [cf. ? Details.whyJulia]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>H&#39;m, this tells us a lot of details which we still need to better understand. To quickly list the atomic properties,  that have been (partly) considered in JAC, we can use <code>? Details.properties</code>   or some other of the listed calls:</p><pre><code class="nohighlight hljs">? Details.properties</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Details.properties-getting-started" href="#JAC.Details.properties-getting-started"><code>JAC.Details.properties</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong><code>Atomic properties</code></strong></p><p>Apart from approximate level energies and eigenvectors, JAC (will) support the computation of the following level properties:</p><ul><li>AlphaX        ... alpha variations; differential sensitivity parameters.</li><li>Einstein      ... Einstein A, B coefficients and oscillator strength; although these coefficients are not an                    original level property, the Einstein module treats these computations within a single                    basis/multiplet and, hence, cannot include relaxation effects, etc. The Einstein                    feature of JAC can be used, however, for a quick overview to transition probabilities                    or in order to simplify cascade computations.</li><li>FormF         ... Standard and modified atomic form factors.</li><li>Greens        ... Greens function of an atomic level.</li><li>HFS           ... Hyperfine A and B parameters.</li><li>Isotope       ... Isotope shift M and F parameters.</li><li>LandeJ        ... Lande g_J factors.</li><li>LandeF        ... Lande g_F factors.</li><li>Polarity      ... Static and dynamic polarizibilities of atomic levels.</li><li>Plasma        ... CI computations including interactions from various plasma models.</li><li>Yields        ... Fluoerescence and Auger yields of atomic levels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>In the design of JAC, we first of all <strong>aim for a precise language</strong> that (i) is simple enough for both, seldom  and a more frequent use of this package, (ii) highlights the underlying physics and (iii) avoids most technical  slang that is often unnecessary but quite common to many other codes. An intuitive picture about the level or hyperfine  structure of an atom, its properties as well as possible excitation and/or decay processes should (always) come first  in order to generate the desired data: By making use of suitable data types (<code>struct</code>), <strong>we indeed wish to  introduce a language close to the underlying formalism.</strong> –- While JAC is overall based on a rather large  number <span>$(&gt; 300)$</span> of such types, a few simple examples are:</p><ul><li>(atomic) <code>Shell</code>:                 <span>$\quad$</span>1s, 2s, 2p, ...</li><li><code>Subshell</code>:                       <span>$\quad$</span>1s<em>1/2, 2s</em>1/2, 2p<em>1/2, 2p</em>3/2, ...</li><li>(electron) <code>Configuration</code>:       <span>$\quad$</span>1s^2 2s^2 2p^6 3s <span>$\quad$</span>  or <span>$\quad$</span>  [Ne] 3s, ...</li><li><code>Level</code>:                          <span>$\quad$</span>1s^2 2s^2  ^1S_0, ...</li></ul><p>and many other terms (types) that we shall explain later.  </p><p>Let us simply start, for instance, with specifying and assigning the <span>$1s$</span> and <span>$2p$</span> shells:</p><pre><code class="language-julia hljs">w1s = Shell(&quot;1s&quot;)
w2p = Shell(&quot;2p&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2p</code></pre><p>Similarly, we can readily specify and assign any (relativistic) subshell:</p><pre><code class="language-julia hljs">Subshell(&quot;2p_1/2&quot;),   Subshell(&quot;2p_3/2&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2p_1/2, 2p_3/2)</code></pre><p>In JAC, we make use of these <code>Shell</code>&#39;s and <code>Subshell</code>&#39;s whenever they will naturally occur in describing the level  structure or the excitation, decay or occupation of an atom, and this both at input and output. If you have  <em>forgotten</em> how to specify such a subshell (constructor), simply <em>ask</em>:</p><pre><code class="nohighlight hljs">? Subshell</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Basics.Subshell-getting-started" href="#JAC.Basics.Subshell-getting-started"><code>JAC.Basics.Subshell</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  Basics.Subshell</code>  ... defines a type for the allowed values of a relativistic subhell.  </p><pre><code class="nohighlight hljs">+ n        ::Int64  ... principal quantum number 
+ kappa    ::Int64  ... relativistic angular quantum number</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>Of course, we can interactively also specify any electron configuration:</p><pre><code class="nohighlight hljs">? Configuration</code></pre><pre><code class="language-julia hljs">wc1 = Configuration(&quot;1s^2 2s^2 2p^5&quot;)
wc2 = Configuration(&quot;[Ar] 4s^2 3d^5&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Configuration: 1s^2 2s^2 2p^6 3s^2 3p^6 3d^5 4s^2 </code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For specific processes users can find the list of types and functions in the API Reference</p></div></div><p>This input just shows three (very) simple examples and how the details of some computation can be readily specified  in line with our basic understanding of the atomic shell model. One can use  <code>? Details.datatypes</code>  in order to see a  more complete list of most data structures that are speficic to the JAC module ... and which will give you a very  <strong>first impression about the size of the JAC program</strong>.</p><pre><code class="nohighlight hljs">? Details.datatypes</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Details.datatypes-getting-started" href="#JAC.Details.datatypes-getting-started"><code>JAC.Details.datatypes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong><code>Data types, structs and name conventions of the JAC module</code></strong></p><p>The use of a proper terminology and data structures has been found essential for developing the JAC module. Below, we list and briefly explain these data types and how they appear in atomic theory. Although we presently support just a (small) number of frequently requested <em>tasks</em> in  atomic structure and collision theory, we tried to define data types that are flexible enough to further extend these tools in the future. Following the Julia&#39;s standard conventions, all types (struct) are named in CamelCase notation.</p><p><strong><code>Abstract data types</code></strong></p><ul><li>AbstractExcitationScheme     ... supports the selection of various (singleton) excitation schemes.</li><li>AbstractQedModel             ... supports the selection of various (singleton) QED models.</li></ul><p><strong><code>Basic data types</code></strong></p><ul><li>AngularJ64                   ... (positive, half-integer) angular momentum, j = 0, 1/2, 1, 3/2, ... .</li><li>AngularM64                   ... (half-integer) projection of ang. momentum, m = -1/2, 0, 1/2, ... can be initialized also                                   w.r.t AngularJ64().</li><li>CartesianVector              ... Cartesian vector of given type.</li><li>ContinuumNormalization       ... method for dealing with the normalization of continuum orbitals.</li><li>ContinuumPhase               ... method for determining the phase of continuum orbitals.</li><li>ContinuumSolutions           ... method for solving continuum orbitals.</li><li>Eigen                        ... represents eigenvalues and eigenvectors if different diagonalization procedures are used.</li><li>EmMultipole                  ... a multipole of the em field.</li><li>EmGauge                      ... an allowed gauge form for the em field, for instance, Coulomb, Babushkin, Magnetic, ...</li><li>EmProperty                   ... a given property in Coulomb (velocity) as well as Babushkin (length) gauge.</li><li>EmStokes                     ... (computed) Stokes parameter for the polarization of emitted radiation.</li><li>ExpStokes                    ... (experimentally) given Stokes parameter for the polarization of incoming radiation.</li><li>Guint                        ... specifier for dealing with graphical user interfaces (GUI).</li><li>LevelKey                     ... data type for identifying a level by its symmetry, energy, etc.</li><li>LevelSymmetry                ... total level symmetry (J, parity).</li><li>LineKey                      ..  data type for identifying a line by the keys of the initial and final level, ...</li><li>Model                        ... to keep the all nuclear parameters.</li><li>Parity                       ... standard parity values</li><li>Shell                        ... a non-relativistic shell.</li><li>SolidAngle`                  ... defines a type for a solid angle Omega = (theta, phi).</li><li>Subshell                     ... a relativistic subshell.</li><li>SubshellStateR               ... a relativistic antisymmetric subshell state within the seniority scheme.</li><li>TensorComp                   ... component of the statistical tensor as associated with an atomic level. </li><li>UseGauge                     ... an allowed gauge form requested for explicit computations: UseCoulomb or UseBabushkin.</li><li>Warnings                     ... for dealing with warnings that are made during a run or REPL session.</li><li>WeightedCartesian            ... Cartesian vector with weight factor of given type.</li></ul><p><strong><code>Data types from many-electron theory</code></strong></p><ul><li>AsfSettings                  ... settings for SCF and CI computations.</li><li>Atomic.Computation           ... atomic computation of a multiplet, including the SCF, CI and transition properties.</li><li>Basis                        ... (relativistic) atomic basis, including the configuration space and radial orbitals.</li><li>Bspline                      ... set of B-splines.</li><li>Configuration                ... (non-relativistic) electron configuration as specified by its shells and their occupation.</li><li>ConfigurationR               ... (relativistic) electron configuration as specified by its subshells and their occupation.</li><li>Level                        ... atomic level in terms of its quantum number, energy and a (possible) representation.</li><li>Multiplet                    ... an ordered list of atomic levels with a name.</li><li>Orbital                      ... (relativistic) radial orbital function that appears as &#39;building block&#39; to define many-electron                                    states; more often than not, it just occurs as radial orbital on a given (radial) grid while the                                    angular dependence is given by the subshell label.</li><li>QedPetersburg                ... singleton data type for selecting QED calculations a la St. Petersburg.</li><li>QedSydney                    ... singleton data type for selecting QED calculations a la Sydney.</li><li>NoneQed                      ... singleton data type if no QED corrections are to be calculated.                 </li><li>Radial.Grid                  ... radial grid to represent the (radial) orbitals.</li><li>Radial.Potential             ... radial potential function.</li><li>Radial.Primitives            ... a list of radial functions, that may serve as a set of primitives in SCF computations, together                                    with several parameters for its definition.</li><li>Radial.SingleSymOrbitals     ... a list of radial orbitals with large and small component but of the same symmetry (kappa); such a                                    list may serves as (complete) single-electron basis to deal with second- and higher-order processes.</li></ul><p><strong><code>Data types calculating level properties</code></strong></p><ul><li>AbstractLevelProperty        ... an atomic level property that is supported by the JAC module, such as HFS, IsotopeShift, ....</li><li>Einstein.Settings            ... settings for Einstein A and B coefficients, calculated within a single given Multiplet.</li><li>Einstein.Outcome             ... (results of the) Einstein A and B coefficients for a single line.</li><li>Hfs.Settings                 ... settings for HFS A and B coefficients.</li><li>Hfs.Outcome                  ... (results of the) HFS A and B coefficients for a single level.</li><li>IsotopeShift.Outcome         ... (results of the) M and F isotope-shift parameters for a single level.</li><li>IsotopeShift.Settings        ... settings for the M and F isotope-shift parameters.</li><li>LandeZeeman.sublevelJ        ... specifies a magnetic sublevel with well-defined J.</li><li>LandeZeeman.sublevelF        ... specifies a magnetic hyperfine sublevel with well-defined F, M_f.</li><li>LandeZeeman.Outcome          ... (results of the) Lande factors and Zeeman splittings for a single level.</li><li>LandeZeeman.Settings         ... settings for the Lande factors and Zeeman splitting in an external magnetic field.</li></ul><p><strong><code>Data types for calculating (time-independent) atomic processes</code></strong></p><ul><li>AtomicProcess                     ... an atomic process that is supported by the JAC module, such as Auger, photo, ....</li><li>AlphaVariation.Outcome            ... outcome of a alpha-variation computation, such as the K enhancement.</li><li>AlphaVariation.Settings           ... seetings for computing alpha variation parameters.</li><li>Auger.Channel                     ... Auger channel of well-defined energy and partial outgoing wave.</li><li>Auger.Line                        ... Auger line between (two) specified initial- and final-state levels and with (possible) subchannels.</li><li>Auger.Settings                    ... settings for computing Auger lines.</li><li>CoulombExcitation.Channel         ... Coulomb excitation channel of well-defined energy and partial wave.</li><li>CoulombExcitation.Line            ... Coulomb excitation line with (possible) subchannels.</li><li>CoulombExcitation.Settings        ... settings for computing Coulomb excitation  lines.</li><li>CoulombIonization.Channel         ... Coulomb ionization channel of well-defined energy and partial wave.</li><li>CoulombIonization.Line            ... Coulomb ionization line with (possible) subchannels.</li><li>CoulombIonization.Settings        ... settings for computing Coulomb ionization  lines.</li><li>Dielectronic.Channel              ... dielectronic-recombination channel of well-defined multipolarity and gauge as well as energy and                                        partial incoming wave.</li><li>Dielectronic.Line                 ... dielectronic recombination line between (three) specified initial-, intermediate and final-state                                        levels and with (possible) subchannels.</li><li>Dielectronic.Resonance            ... single dielectronic resonance that summarizes all Dielectronic.Line&#39;s for some fixed intermediate                                       level within the continuum. </li><li>Dielectronic.Settings             ... settings for computing dielectronic recombination lines.</li><li>DecayYield.Outcome                ... outcome of a decay yield computation.</li><li>DecayYield.Settings               ... settings for computing decay yields lines.</li><li>DoubleAutoIonization.Channel      ... DoubleAutoIonization channel of two partial outgoing waves with well-defined energy.</li><li>DoubleAutoIonization.Line         ... DoubleAutoIonization line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.</li><li>DoubleAutoIonization.Settings     ... settings for computing DoubleAutoIonization lines.</li><li>DoublePhotoIonization.Channel     ... DoublePhotoIonization channel of two partial outgoing waves with well-defined energy.</li><li>DoublePhotoIonization.Line        ... DoublePhotoIonization line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.</li><li>DoublePhotoIonization.Settings    ... settings for computing DoublePhotoIonization lines.</li><li>ImpactExcitation.Channel          ... electron-impact excitation channel of well-defined energies. partial waves and phases of the                                        incoming and outgoing electrons.</li><li>ImpactExcitation.Line             ... electron-impact excitation line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.</li><li>ImpactExcitation.Settings         ... settings for computing electron-impact excitation lines.</li><li>ImpactExcitationAutoion.Channel   ... electron-impact excitation channel of well-defined energies, partial waves and phases of the                                        incoming and outgoing electrons.</li><li>ImpactExcitationAutoion.Pathway   ... electron-impact excitation line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.</li><li>ImpactExcitationAutoion.Settings  ... settings for computing electron-impact excitation lines.</li><li>ImpactIonization.Channel          ... electron-impact ionization channel of well-defined energies, partial waves and phases of the                                        incoming and outgoing electrons.</li><li>ImpactIonization.Line             ... electron-impact ionization line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.</li><li>ImpactIonization.Settings         ... settings for computing electron-impact ionization lines.</li><li>MultiPhotonDeExcitation.Channel   ... multi-photon excitation or decay channel with well-defined multipolarities and gauge.</li><li>MultiPhotonDeExcitation.Line      ... multi-photon excitation or decay line between (two) specified initial- and final-state levels                                        and with (possible) subchannels.</li><li>MultiPhotonDeExcitation.Settings  ... settings for computing multi-photon excitation or decay lines.</li><li>MultiPhotonIonization.Channel     ... multi-photon ionization channel with well-defined multipolarities, gauge as well as energy and                                        partial wave of the outgoing electron.</li><li>MultiPhotonIonization.Line        ... multi-photon ionization line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.</li><li>MultiPhotonIonization.Settings    ... settings for computing multi-photon ionization lines.</li><li>MultiPhotonDoubleIon.Channel      ... multi-photon double ionization channel with well-defined multipolarities, gauge as well as energy                                       and partial waves of the (two) outgoing electrons.</li><li>MultiPhotonDoubleIon.Line         ... multi-photon double ionization line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.</li><li>MultiPhotonDoubleIon.Settings     ... settings for computing multi-photon double ionization lines.</li><li>PairAnnihilation1Photon.Channel   ... positron-bound-electron pair annihilation (PEPA) with single-photon emission channel of                                        well-defined multipolarity, gauge as well as energy and partial incoming (positron) wave.</li><li>PairAnnihilation1Photon.Line      ... PEPA with single-photon emission line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.</li><li>PairAnnihilation1Photon.Settings  ... settings for computing PEPA with single-photon emission lines.</li><li>PairAnnihilation2Photon.Channel   ... positron-bound-electron pair annihilation (PEPA) with two-photon emission channel of well-defined                                        multipolarities, gauge as well as energy and partial incoming (positron) wave.</li><li>PairAnnihilation2Photon.Line      ... PEPA with two-photon emission line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.</li><li>PairAnnihilation2Photon.Settings  ... settings for computing PEPA with two-photon emission lines.</li><li>PairProduction.Channel            ... positron-bound-electron pair production (PEPP) by single-photon absorption channel of well-defined                                        multipolarity, gauge as well as energy and partial outgoing (positron) wave.</li><li>PairProduction.Line               ... PEPP by single-photon absorption line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.</li><li>PairProduction.Settings           ... settings for computing PEPP lines.</li><li>PhotoExcitation.Line              ... photoexcitation line between (two) specified initial- and final- state levels and with (possible                                       JAC.PhotoEmission.Channel) subchannels.</li><li>PhotoExcitation.Settings          ... settings for computing photoexcitation lines.</li><li>PhotoExcitationAutoion.Channel    ... photo-excitation autoionization channel of well-defined energies of the incoming photon as well as                                        the partial wave and phase of the outgoing electron.</li><li>PhotoExcitationAutoion.Pathway    ... photo-excitation autoionization pathways between (three) specified initial-, intermediate and                                        final-state levels and with (possible) subchannels.</li><li>PhotoExcitationAutoion.Settings   ... settings for computing photo-excitation autoionization pathways.</li><li>PhotoIonization.Channel           ... photoionization channel of well-defined multipolarity, gauge as well as energy and partial                                        outgoing wave.</li><li>PhotoIonization.Line              ... photoionization line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.</li><li>PhotoIonization.Settings          ... settings for computing photoionization lines.</li><li>PhotoRecombination.Channel        ... Rec channel of well-defined multipolarity and gauge as well as energy and partial incoming wave.</li><li>PhotoRecombination.Line           ... radiative electron capture line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.</li><li>PhotoRecombination.Settings       ... settings for computing radiative electron capture lines.</li><li>PhotoEmission.Channel                 ... radiative channel of well-defined multipolarity and gauge.</li><li>PhotoEmission.Line                    ... radiative line between (two) specified initial- and final-state levels and with (possible) sublines.</li><li>PhotoEmission.Settings                ... settings for computing radiative lines.</li><li>RadiativeAuger.Channel            ... RadiativeAuger channel of a partial outgoing waves and one photon with well-defined energy.</li><li>RadiativeAuger.Line               ... RadiativeAuger line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.</li><li>RadiativeAuger.Settings           ... settings for computing RadiativeAuger lines.</li><li>Radiative.Settings                ... settings for computing radiative lines.</li><li>RayleighCompton.Channel           ... RayleighCompton channel of an incoming and outgoing photon with well-defined energy.</li><li>RayleighCompton.Line              ... RayleighCompton line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.</li><li>RayleighCompton.Settings          ... settings for computing RayleighCompton lines.</li><li>REDA.Channel                      ... resonant electron-excitation (sequential) double-autoionization (REDA) channel of well-defined                                        energies, partial waves and phases of the incoming and outgoing electrons.</li><li>REDA.Pathway                      ... resonant electron-excitation (sequential) double-autoionization (REDA) pathways.between (four)                                        specified initial-, (two) intrmediate and final-state levels and with (possible) subchannels.</li><li>REDA.Settings                     ... settings for computing resonant electron-excitation (sequential) double-autoionization (REDA)                                        pathways.</li></ul><p><strong><code>Data types for calculating (time-dependent) atomic processes</code></strong></p><ul><li>Pulse.Envelope                       ... defines a type for the envelope (function) of an em pulse with well-defined time delay,                                            amplitude and (normalized) shape function.</li><li>Pulse.ExperimentalCharacterization   ... to characterized an experimental or physically described em pulse in terms of its                                            propagation direction, frequency, maximum intensity, pulse length or No. of cycles, time-delay,                                            polarization, etc., i.e. of what is easily accesssible by an experiment.</li><li>Pulse.Gaussian                       ... a Gaussian light pulse that is used for evaluating time-dependent statistical tensors.</li><li>Pulse.Polarization                   ... defines the polarization of an em pulse in terms of its linear and circular degrees, the                                            direction of the polarization vector or some generalized polarization coefficients.</li><li>Pulse.PolarizationType               ... defines the polarization of an experimentally described light pulse as linear, left-circular, ..</li><li>Pulse.Shape                          ... defines a shape of a general em pulse as Gaussian, SineSquared, etc.</li><li>Pulse.SineSquared                    ... a SinSquared light pulse that is used for evaluating time-dependent statistical tensors.</li></ul><p><strong><code>Data types for dealing wiht (time-dependent) statistical tensors</code></strong></p><ul><li>Statistical.ResonanceR      ... a resonance state in the continuum with a well-defined bound-ionic core, one or several electrons                                    in the continuum, a widths as well as a loss rate due to <em>additional</em> decay processes that cannot be                                    accounted for explicitly.</li><li>Statistical.Tensor          ... represents a statistical tensor of given rank k, projection q and which generally depends upon two                                    resonances.</li></ul><p><strong><code>Data types for advanced computations</code></strong></p><ul><li><p>Atomic.CasComputation          ... an individual or a series of systematically enlarged SCF computations.</p></li><li><p>Atomic.CasStep                 ... single-step in an (systematically enlarged) SCF calculation.</p></li><li><p>Atomic.CasSettings             ... settings for CAS computation.</p></li><li><p>Cascade.Approach               ... a particular (computational) approach in which a cascade is considered.</p></li><li><p>Cascade.Block                  ... a block of configurations that are treatet together within a given cascade. </p></li><li><p>Cascade.Data                   ... all transition data of a cascade as given by a list of lines (of different type).</p></li><li><p>Cascade.Computation            ... definition of an atomic exciation/decay cascade from which the actual computations can be derived.</p></li><li><p>Cascade.Level (mutable)        ... defines a level specification for dealing with cascade transitions.</p></li><li><p>Cascade.LineIndex              ... defines a line index with regard to the various lineLists of data::Cascade.Data.</p></li><li><p>Cascade.Step                   ... an individual step of a Cascade.Computation that generally combines two ionization states of ions.</p></li><li><p>Cascade.Simulation             ... simulation of cascade data.</p></li><li><p>Cascade.SimulationSettings     ... defines settings for performing the simulation of some cascade (data).</p></li><li><p>Cascade.Settings               ... settings for cascade computations (not yet).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>This list gives further details why Julia (and JAC) is a very suitable and powerful framework for running  – many-electron – atomic computations. </p><p>Of course, there are many other features that make Julia &amp; JAC as powerful as it is: For example, the user may pre-define  and overwrite the <strong>units</strong> in which he wishes to communicate with JAC. These units determine how (most of) the input  data are interpreted as well as output data are displayed in tabulations or to screen. The current defaults settings  for the units can be seen by typing:</p><pre><code class="language-julia hljs">Basics.display(&quot;settings&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Current settings of the JAC module:
-----------------------------------

  + Framework:                              relativistic
  + Energy unit:                            eV
  + Rate and transition probability unit:   1/s
  + Cross section unit:                     barn
  + Time unit:                              sec

  + A standard grid has been defined; cf. Defaults.getDefaults()</code></pre><p>which show that energies are taken/printed in eV, rates in 1/s, etc. Apart from modifying these defaults directly in the  source code, the can be <em>overwritten</em> by the user at any time of the program executation. This is done by means of  the function</p><pre><code class="nohighlight hljs">? Defaults.setDefaults</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Defaults.setDefaults" href="#JAC.Defaults.setDefaults"><code>JAC.Defaults.setDefaults</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Defaults.setDefaults()</code>       ... (re-) defines some &#39;standard&#39; settings which are common to all the computations with the JAC module, and which can          be &#39;overwritten&#39; by the user. –- An improper setting of some variable may lead to an error message, if recognized         immediately. The following defaults apply if not specified otherwise by the user: the framework is &#39;relativistic&#39;,          energies are given in eV and cross sections in barn. Note that, internally, atomic units are used throughout for          all the computations within the program. nothing is returned if not indicated otherwise.</p><p><strong>+ <code>(&quot;framework: relativistic&quot;)</code>  or  <code>(&quot;framework: non-relativistic&quot;)</code></strong></p><p><strong>... to define a relativistic or non-relativistic framework for all subsequent computations.</strong></p><ul><li><p><code>(&quot;method: continuum, spherical Bessel&quot;)</code>  or  <code>(&quot;method: continuum, pure sine&quot;)</code>  or     <code>(&quot;method: continuum, asymptotic Coulomb&quot;)</code>  or  <code>(&quot;method: continuum, nonrelativistic Coulomb&quot;)</code>  or     <code>(&quot;method: continuum, Galerkin&quot;)</code>     ... to define a a method for the generation of the continuum orbitals as (pure) spherical Bessel, pure sine,       asymptotic Coulomb, nonrelativistic Coulomb orbital or by means of the B-spline-Galerkin method.</p></li><li><p><code>(&quot;method: normalization, pure sine&quot;)</code>  or  <code>(&quot;method: normalization, pure Coulomb&quot;)</code>  or  <code>(&quot;method: normalization, Ong-Russek&quot;)</code>      ... to define a method for the normalization of the continuum orbitals as asymptotically (pure) sine or Coulomb        functions, or following the procedure by Ong &amp; Russek (1978).</p></li><li><p><code>(&quot;QED model: Petersburg&quot;)</code>  or  <code>(&quot;QED model: Sydney&quot;)</code>      ... to define a model for the computation of the QED corrections following the work by Shabaev et al. (2011; Petersburg)        or Flambaum and Ginges (2004; Syney).</p></li><li><p><code>(&quot;unit: energy&quot;, &quot;eV&quot;)</code>  or  <code>(&quot;unit: energy&quot;, &quot;Kayser&quot;)</code>  or  <code>(&quot;unit: energy&quot;, &quot;Hartree&quot;)</code>  or     <code>(&quot;unit: energy&quot;, &quot;Hz&quot;)</code>  or  <code>(&quot;unit: energy&quot;, &quot;Hz&quot;)</code>     ... to (pre-) define the energy units for all further printouts and communications with the JAC module.</p></li><li><p><code>(&quot;unit: cross section&quot;, &quot;a.u.&quot;)</code>  or  <code>(&quot;unit: cross section&quot;, &quot;barn&quot;)</code>  or  <code>(&quot;unit: cross section&quot;, &quot;Mbarn&quot;)</code>     ... to (pre-) define the unit for the printout of cross sections.</p></li><li><p><code>(&quot;unit: rate&quot;, &quot;a.u.&quot;)</code>  or  <code>(&quot;unit: rate&quot;, &quot;1/s&quot;)</code>  ... to (pre-) define the unit for the printout of rates.</p></li><li><p><code>(&quot;unit: resonance strength&quot;, &quot;a.u.&quot;)</code>  or  <code>(&quot;unit: resonance strength&quot;, &quot;barn eV&quot;)</code>  or     <code>(&quot;unit: resonance strength&quot;, &quot;cm^2 eV&quot;)</code>  ... to (pre-) define the unit for the printout of resonance strengths.</p></li><li><p><code>(&quot;unit: time&quot;, &quot;a.u.&quot;)</code>  or  <code>(&quot;unit: time&quot;, &quot;sec&quot;)</code>  or  <code>(&quot;unit: time&quot;, &quot;fs&quot;)</code>  or  <code>(&quot;unit: time&quot;, &quot;as&quot;)</code>     ... to (pre-) define the unit for the printout and communications of times with the JAC module.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><ul><li><code>(&quot;relativistic subshell list&quot;, subshells::Array{Subshell,1}; printout::Bool=true)</code>     ... to (pre-) define internally the standard relativistic subshell list on which the standard order of orbitals is based.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><ul><li><code>(&quot;standard grid&quot;, grid::Radial.Grid; printout::Bool=true)</code>     ... to (pre-) define internally the standard radial grid which is used to represent most orbitals.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><ul><li><code>(&quot;continuum: potential&quot;, scField::Basics.AbstractScField)</code>     ... to (re-) define the potential that is applied for the generation of the continuum orbitals.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><ul><li><code>(&quot;QED: damped-hydrogenic&quot;, Znuc::Float64, wa::Array{Float64,1})</code>     ... to (re-) define the lambda-C damped overlap integrals of the lowest kappa-orbitals        [ wa<em>1s</em>1/2, wa<em>2p</em>1/2, wa<em>2p</em>3/2, wa<em>3d</em>3/2, wa<em>3d</em>5/2 ] for the (new) nuclear charge Znuc;        nothing is returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>which enables one to re-define various <strong>global values</strong> of JAC. If we wish to enter/display energies in <strong>Kaysers</strong> or  cross sections in atomic units, we can simply type:</p><pre><code class="language-julia hljs">Defaults.setDefaults(&quot;unit: energy&quot;, &quot;Kayser&quot;)
Defaults.setDefaults(&quot;unit: cross section&quot;, &quot;a.u.&quot;)</code></pre><p>Here, again <code>nothing</code> is returned but the corresponding global constants are now changed.</p><pre><code class="language-julia hljs">Basics.display(&quot;settings&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Current settings of the JAC module:
-----------------------------------

  + Framework:                              relativistic
  + Energy unit:                            Kayser
  + Rate and transition probability unit:   1/s
  + Cross section unit:                     a.u.
  + Time unit:                              sec

  + A standard grid has been defined; cf. Defaults.getDefaults()</code></pre><p>Apart from the default units, one can similarly <em>overwrite</em> the method that is use for the generation and normalization  of continuum orbitals and several others. Although called <em>global</em>, the corresponding values can be accesses just in  two ways. (i) The <strong>global constants</strong>, such as the electron mass, the speed of light, the fine-structure constant <span>$\alpha$</span>,  etc., are accessed via the function:</p><pre><code class="nohighlight hljs">? Defaults.getDefaults</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Defaults.getDefaults" href="#JAC.Defaults.getDefaults"><code>JAC.Defaults.getDefaults</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Defaults.getDefaults()</code>       ... gives/supplies different information about the (present) framework of the computation or about some          given data; cf. Defaults.setDefaults(). </p><ul><li><p><code>(&quot;alpha&quot;)</code>  or  <code>(&quot;fine-structure constant alpha&quot;)</code>      ... to get the (current) value::Float64 of the fine-structure constant alpha.</p></li><li><p><code>(&quot;electron mass: kg&quot;)</code>  or  <code>(&quot;electron mass: amu&quot;)</code>     ... to get the (current) value::Float64 of the electron mass in the specified unit.</p></li><li><p><code>(&quot;framework&quot;)</code>  ... to give the (current) setting::String  of the overall framework.</p></li><li><p><code>(&quot;electron rest energy&quot;)</code>  or  <code>(&quot;mc^2&quot;)</code>  ... to get the electron rest energy.</p></li><li><p><code>(&quot;electron g-factor&quot;)</code>  ... to give the electron g-factor g_s = 2.00232.</p></li><li><p><code>(&quot;unit: energy&quot;)</code>  or  <code>(&quot;unit: cross section&quot;)</code>  or  <code>(&quot;unit: rate&quot;)</code>  or  <code>(&quot;unit: strength&quot;)</code>  or  <code>(&quot;unit: time&quot;)</code>     ... to get the corresponding (user-defined) unit::String for the current computations.</p></li><li><p><code>(&quot;standard grid&quot;)</code>     ... to get the (current standard) grid::Array{Float64,1} to which all radial orbital functions usually refer.</p></li><li><p><code>(&quot;speed of light: c&quot;)</code>  ... to get the speed of light in atomic units.</p></li><li><p><code>(&quot;summary flag/stream&quot;)</code>     ... to get the logical flag and stream for printing a summary file; a tupel (flag, iostream) is returned.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><ul><li><code>(&quot;ordered shell list: non-relativistic&quot;, n_max::Int64)</code>     ... to give an ordered list of non-relativistic shells::Array{Shell,1} up to the (maximum) principal number n_max.</li><li><code>(&quot;ordered subshell list: relativistic&quot;, n_max::Int64)</code>      ... to give an ordered list of relativistic subshells::Array{Subshell,1} up to the (maximum) principal number n_max.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><pre><code class="language-julia hljs">Defaults.getDefaults(&quot;alpha&quot;)
Defaults.getDefaults(&quot;electron rest energy&quot;)
Defaults.getDefaults(&quot;unit: energy&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Kayser&quot;</code></pre><p>(ii) These <strong>global values</strong> are frequently applied in order to – internally or externally – convert physical numbers  into units of the same dimension. This is done by the function:</p><pre><code class="nohighlight hljs">? Defaults.convertUnits</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Defaults.convertUnits" href="#JAC.Defaults.convertUnits"><code>JAC.Defaults.convertUnits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Defaults.convertUnits()</code>       ... converts some data from one format/unit into another one; cf. the supported keystrings and return values.</p><ul><li><p><code>(&quot;cross section: from atomic to predefined unit&quot;, value::Float64)</code>  or  <code>(&quot;cross section: from atomic&quot;, value::Float64)</code>     ... to convert an cross section value from atomic to the predefined cross section unit; a Float64 is returned.</p></li><li><p><code>(&quot;cross section: from barn to atomic unit&quot;, value::Float64)</code>    ... to convert an cross section value from barn atomic section unit; a Float64 is returned.</p></li><li><p><code>(&quot;cross section: from atomic to barn&quot;, value::Float64)</code>  or  <code>(&quot;cross section: from atomic to Mbarn&quot;, value::Float64)</code>  or   <code>(&quot;cross section: from atomic to cm^2&quot;, value::Float64)</code>    ... to convert an energy value from atomic to the speficied cross section unit; a Float64 is returned.</p></li><li><p><code>(&quot;cross section: from predefined to atomic unit&quot;, value::Float64)</code>  or  <code>(&quot;cross section: to atomic&quot;, value::Float64)</code>   ... to convert a cross section value from the predefined to the atomic cross section unit; a Float64 is returned.</p></li><li><p><code>(&quot;einstein B: from atomic&quot;, value::Float64)</code>     ... to convert a Einstein B coefficient from atomic to the speficied energy units; a Float64 is returned.</p></li><li><p><code>(&quot;density: from [g/cm^3] to atomic&quot;, value::Float64)</code>     ... to convert a mass density from [g/cm^3] to atomic units [u/a_o^3]; a Float64 is returned.</p></li><li><p><code>(&quot;energy-diff. cross section: from atomic to predefined unit&quot;, value::Float64)</code>  or     <code>(&quot;energy-diff. cross section: from atomic&quot;, value::Float64)</code>     ... to convert an energy-diff. cross section value from atomic to the predefined energy-diff. cross section unit;        a Float64 is returned.</p></li><li><p><code>(&quot;energy: from atomic to eV&quot;, value::Float64)</code>  or  <code>(&quot;energy: from atomic to Kayser&quot;, value::Float64)</code>    or   <code>(&quot;energy: from atomic to Hz&quot;, value::Float64)</code>  or  <code>(&quot;energy: from atomic to Angstrom&quot;, value::Float64)</code>  or   <code>(&quot;energy: from atomic to Ws&quot;, value::Float64)</code>   ... to convert an energy value from atomic to the speficied energy unit; a Float64 is returned.</p></li><li><p><code>(&quot;energy: from predefined to atomic unit&quot;, value::Float64)</code>  or  <code>(&quot;energy: to atomic&quot;, value::Float64)</code>... to convert an energy value                                                from the predefined to the atomic energy unit; a Float64 is returned.</p></li><li><p><code>(&quot;energy: from eV to atomic&quot;, value::Float64)</code> ... to convert an energy value from eV to the atomic energy unit; a Float64 is returned.</p></li><li><p><code>(&quot;energy: from wavelength [nm] to atomic&quot;, value::Float64)</code> ... to convert a wavelength [nm] to the atomic energy unit; a Float64 is returned.</p></li><li><p><code>(&quot;intensity: from W/cm^2 to atomic&quot;, value::Float64)</code> ... to convert the intensity [in W/cm^2] to the atomic intensity unit; a Float64 is returned.</p></li><li><p><code>(&quot;kinetic energy to wave number: atomic units&quot;, value::Float64)</code>  ... to convert a kinetic energy value (in a.u.) into a wave number                                               k (a.u.); a Float64 is returned.</p></li><li><p><code>(&quot;kinetic energy to wavelength: atomic units&quot;, value::Float64)</code>  ... to convert a kinetic energy value (in a.u.) into a wavelength (a.u.);                                                a Float64 is returned.</p></li><li><p><code>(&quot;length: from fm to atomic&quot;, value::Float64)</code>  ... to convert a length value (in fm) into a.u.;  a Float64 is returned.</p></li><li><p><code>(&quot;length: from atomic to fm&quot;, value::Float64)</code>  or  <code>(&quot;energy: from atomic to Kayser&quot;, value::Float64)</code>     ... to convert a length value (in Bohr&#39;s a.u.) to the speficied length unit;  a Float64 is returned.</p></li><li><p><code>(&quot;rate: from atomic to predefined unit&quot;, value::Float64)</code>  or  (&quot;rate: from atomic&quot;, value::Float64)  ... to convert a rate value                                            from atomic to the predefined rate unit; a Float64 is returned.</p></li><li><p><code>(&quot;rate: from atomic to 1/s&quot;, value::Float64)</code>  ... to convert an rate value from atomic to the speficied rate unit; a Float64 is returned.</p></li><li><p><code>(&quot;rate: from predefined to atomic unit&quot;, value::Float64)</code>  or  `(&quot;rate: to atomic&quot;, value::Float64)&#39;... to convert a                                               rate value from the predefined to the atomic rate unit; a Float64 is returned.</p></li></ul><ul><li><p><code>(&quot;strength: from atomic to predefined unit&quot;, value::Float64)</code>  or  (&quot;strength: from atomic&quot;, value::Float64)  ... to convert a (resonance)                                                strength value from atomic to the predefined rate unit; a Float64 is returned.</p></li><li><p><code>(&quot;time: from atomic to predefined unit&quot;, value::Float64)</code>  or  (&quot;time: from atomic&quot;, value::Float64)  ... to convert an time value                                            from atomic to the predefined time unit; a Float64 is returned.</p></li><li><p><code>(&quot;time: from atomic to sec&quot;, value::Float64)</code>  or  <code>(&quot;time: from atomic to fs&quot;, value::Float64)&#39;  or</code>(&quot;time: from atomic to as&quot;, value::Float64)`  ... to convert a time value from atomic to the speficied time unit; a Float64 is returned.</p></li><li><p><code>(&quot;time: from predefined to atomic unit&quot;, value::Float64)</code>  or  `(&quot;time: to atomic&quot;, value::Float64)&#39;  ... to convert a                                           time value from the predefined to the atomic time unit; a Float64 is returned.</p></li><li><p><code>(&quot;temperature: from Kelvin to (Hartree) units&quot;, value::Float64)</code>  ... to convert a temperature in Kelvin into atomic (Hartree) units;                                                a Float64 is returned.</p></li><li><p><code>(&quot;temperature: from atomic to Kelvin&quot;, value::Float64)</code>  ... to convert an atomic (energy) unit into Kelvin; 1 Hartree = 315774.64 K;                                                a Float64 is returned.</p></li><li><p><code>(&quot;wave number to total electron energy: atomic units&quot;, value::Float64)</code>  ... to convert a wavenumber (a.u.) into the total electron                                           energy, including the rest energy; a Float64 is returned.</p></li><li><p><code>(&quot;wave number to kinetic energy: atomic units&quot;, value::Float64)</code>  ... to convert a wavenumber (a.u.) into the kinetic energy;                                            a Float64 is returned.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><ul><li><code>(string, values::Array{Float64,1})</code>     ... to convert for the same strings as above but for an list of values; a corresponding Array{Float64,1} is returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>This function is called at many places within JAC to generate tables where all physical data are printed out in the  pre-specified units:</p><pre><code class="language-julia hljs">Defaults.convertUnits(&quot;energy: from atomic&quot;, 1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">219474.63068</code></pre><p>With the given user-selection, this is equivalent to:</p><pre><code class="language-julia hljs">Defaults.convertUnits(&quot;energy: from atomic to Kayser&quot;, 1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">219474.63068</code></pre><p>In JAC, the call of this function is often combined with some proper formatting of the results, such as:</p><pre><code class="language-julia hljs">using Printf
@sprintf(&quot;%.4e&quot;, Defaults.convertUnits(&quot;energy: from atomic&quot;, 1.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;2.1947e+05&quot;</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="demos.html">Demos »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Wednesday 23 April 2025 09:44">Wednesday 23 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
