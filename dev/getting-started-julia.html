<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started with Julia (in REPL) · JAC.jl</title><meta name="title" content="Getting started with Julia (in REPL) · JAC.jl"/><meta property="og:title" content="Getting started with Julia (in REPL) · JAC.jl"/><meta property="twitter:title" content="Getting started with Julia (in REPL) · JAC.jl"/><meta name="description" content="Documentation for JAC.jl."/><meta property="og:description" content="Documentation for JAC.jl."/><meta property="twitter:description" content="Documentation for JAC.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">JAC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li class="is-active"><a class="tocitem" href="getting-started-julia.html">Getting started with Julia (in REPL)</a></li><li><a class="tocitem" href="getting-started-jac.html">Getting started with JAC (in REPL)</a></li></ul></li><li><a class="tocitem" href="examples.html">Examples</a></li><li><a class="tocitem" href="api.html">API Reference</a></li><li><a class="tocitem" href="reference.html">Publications Reference</a></li><li><a class="tocitem" href="news.html">News</a></li><li><a class="tocitem" href="contributors.html">Contributors</a></li><li><a class="tocitem" href="license.html">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li class="is-active"><a href="getting-started-julia.html">Getting started with Julia (in REPL)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="getting-started-julia.html">Getting started with Julia (in REPL)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/OpenJAC/JAC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/OpenJAC/JAC.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-started-with-Julia-(in-REPL)"><a class="docs-heading-anchor" href="#Getting-started-with-Julia-(in-REPL)">Getting started with Julia (in REPL)</a><a id="Getting-started-with-Julia-(in-REPL)-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started-with-Julia-(in-REPL)" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Link to the Pluto jl and direct start with  example...</p></div></div><p>Here, we shall <strong>not introduce</strong> Julia&#39;s syntax and concepts for which many tutorials are available on the web. Instead, we just wish to remind and highlight some simple (syntax) features that help to go easier around with JAC, and especially for occasional users from experiment or teaching. This reminder aims to lower the initial <em>threshold</em> for users that have been trained on other languages in the past. Here, we shall <em>pick up</em> some issues whose physics background is explained only later in other tutorial. Obviously, however, Julia is a very rich and powerful language with many features that go well beyond of what is (and will ever) needed for JAC.</p><p>In brief, JAC provides tools for performing atomic (structure) calculations of different kind and complexity, and for which further details are given in the tutorials below. To see anything from JAC, we shall first invoke the tools by:</p><pre><code class="language-julia hljs">using JAC</code></pre><p>a line that will appear at the beginning of all subsequent tutorials. – A first powerful and frequently needed feature refers to Julia&#39;s help pages or just the &quot;?&quot;. By typing, for instance, atom or computation</p><pre><code class="nohighlight hljs">? atom</code></pre><pre><code class="nohighlight hljs">search: atomic Atomic AtomicState AtomicCompass AtomicStructure @atomic @atomicswap @atomicreplace

Couldn&#39;t find atom
Perhaps you meant atomic, atan, acot, acos, htol, hton, ltoh, ntoh, Atomic, @atomic, pathof, atand, atanh, cat, match, catch, stat, acotd, acoth, add, ans, abs, abs2, acosd, acosh, acsc, all, all!, any, any!, asec, asin, axes, as, tan or Beam
No documentation found.

Binding atom does not exist.</code></pre><p>we see, that <code>atom</code> itself is not a well-defined term in the JAC toolbox but that there exists a number of related terms, such as <code>Atomic</code>, <code>AtomicState</code> (two modules of JAC) and others. We shall not enter here the modular structure of the JAC toolbox but start much simpler with: </p><pre><code class="nohighlight hljs">? Orbital</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Radial.Orbital-getting-started-julia" href="#JAC.Radial.Orbital-getting-started-julia"><code>JAC.Radial.Orbital</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  Radial.Orbital</code>       ... defines a type for a single-electron radial orbital function with a large and small component, and which can refer to         either the standard or an explicitly given grid due to the logical flag useStandardGrid. Bound-state orbitals with energy &lt; 0 are          distinguished from free-electron orbitals by the flag isBound.</p><pre><code class="nohighlight hljs">+ subshell        ::Subshell          ... Relativistic subshell.
+ isBound         ::Bool              ... Logical flag to distinguish between bound (true) and free-electron orbitals (false).
+ useStandardGrid ::Bool              ... Logical flag for using the standard grid (true) or an explicitly given grid (false).
+ energy          ::Float64           ... Single-electron energies of bound orbitals are always negative.
+ P               ::Array{Float64,1}  ... Large and ..
+ Q               ::Array{Float64,1}  ... small component of the radial orbital.
+ Pprime          ::Array{Float64,1}  ... dP/dr.
+ Qprime          ::Array{Float64,1}  ... dQ/dr.
+ grid            ::Array{Float64,1}  ... explic. defined radial grid array for P, Q, if StandardGrid = false.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>which, apart from its formal meaning, is a particular data structure (<code>struct</code>) of JAC and which represents a relativistic orbital (function) including additional information that appears helpful in the given implementation. There are very many (say, more than 300) of such data struct&#39;s specified in the JAC toolbox, and thus quite obvious that nobody will remember the details of all these definitions. Indeed, the &quot;?&quot; is the right and a powerful means to remind yourself and make use of these data structures whenever necessary. Special care has been taken that all data structures and functions/methods comes with a reasonable explanation (docstring) in order to work efficiently with JAC.</p><p>For instance, we might ask of what can be <em>added</em> to each other in JAC:</p><pre><code class="nohighlight hljs">? add</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Basics.add-getting-started-julia" href="#JAC.Basics.add-getting-started-julia"><code>JAC.Basics.add</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Basics.add(pota::Radial.Potential, potb::Radial.Potential)</code>       ... to add two radial potentials together that are defined on the same grid. A potential::RadialPotential is returned          that inherits its radial size from the potential that is defined in a larger range of r-values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.add(ma::AngularM64, mb::AngularM64)</code>       ... adds the projections of the angular momenta ma + mb and returns a mc::AngularM64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>Apart from a short explanation, these docstring always tell the user (i) in which module the method is defined; (ii) which arguments it takes, including Julia&#39;s <em>multiple dispatch</em> feature as well as (iii) the type of the return value. All these information are typically relevant to the user, especially if some input or output does not behave as it should. Indeed, the complexity can grow quite rapidly, for instance, if we ask for help of what we can <code>generate</code>:</p><pre><code class="nohighlight hljs">? generate</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Basics.generate-getting-started-julia" href="#JAC.Basics.generate-getting-started-julia"><code>JAC.Basics.generate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Basics.generate(representation::AtomicState.Representation)</code>       ... to generate an atomic representation as specified by the representation.repType::AbstractRepresentationType.         All relevant intermediate and final results are printed to screen (stdout). Nothing is returned.</p><p><code>Basics.perform(representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.MeanFieldBasis, representation::AtomicState.Representation)</code>       ... to generate a mean-field basis (representation) for a set of reference configurations; all relevant intermediate          and final results are printed to screen (stdout). Nothing is returned.</p><p><code>Basics.generate(repType::AtomicState.MeanFieldBasis, representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.MeanFieldMultiplet, representation::AtomicState.Representation)</code>       ... to generate a mean-field basis (representation) for a set of reference configurations; all relevant intermediate          and final results are printed to screen (stdout). Nothing is returned.</p><p><code>Basics.generate(repType::AtomicState.MeanFieldMultiplet, representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.OneElectronSpectrum, representation::AtomicState.Representation)</code>       ... to generate a one-electron spectrum for the atomic potential from the (given) levels, based on a set of reference          configurations as well as for given settings. Relevant intermediate and final results are printed to screen (stdout).          Nothing is returned in this case.</p><pre><code class="nohighlight hljs">+ `(repType::AtomicState.OneElectronSpectrum, representation::AtomicState.Representation; output=true)`  
... to generate the same but to return the complete output in a orbitals::Dict{Subshell, Orbital}.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.CiExpansion, representation::AtomicState.Representation)</code>       ... to generate a configuration-interaction expansion for a single level symmetry and based on a set of reference configurations         and a number of pre-specified steps. All relevant intermediate and final results are printed to screen (stdout).          Nothing is returned.</p><p><code>Basics.generate(repType::AtomicState.CiExpansion, representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the computations but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.RasExpansion, representation::AtomicState.Representation)</code>       ... to generate a restricted active-space expansion for a single level symmetry and based on a set of reference configurations         and a number of pre-specified steps. All relevant intermediate and final results are printed to screen (stdout).          Nothing is returned.</p><p><code>Basics.generate(repType::AtomicState.RasExpansion, representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the computations but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(repType::AtomicState.GreenExpansion, representation::AtomicState.Representation)</code>       ... to generate a Green (function) expansion for a given approach and excitation scheme of the electron,         based on a set of reference configurations, a list of level symmetries as well as for given settings.         All relevant intermediate and final results are printed to screen (stdout). Nothing is returned.</p><p><code>Basics.generate(repType::AtomicState.GreenExpansion, representation::AtomicState.Representation; output=true)</code>       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;condensed multiplet: by single weight&quot;, multiplet::Multiplet)</code>       ... to condense/reduce the number of CSF in the basis of the given multiplet due to a single &#39;weight&#39;;          a multiplet::Multiplet is returned.  <strong>Not yet implemented !</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;configuration list: NR, from basis&quot;, basis::Basis)</code>       ... to (re-) generate the list of NR configurations from the given basis; a confList::Array{Configuration,1} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;configuration list: NR, single-configuration&quot;, refConf::Configuration, NoExcitations::Int64, fromShells::Array{Shell,1},</code>                     toShells::Array{Shell,1})       ... to generate a non-relativistic configuration list, including the given reference configuration (refConf) and with          all configurations that differ by NoExcitations from the fromShells into the toShells; an Array{Configuration,1}          is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;shells: ordered list for NR configurations&quot;, confs::Array{Configuration,1})</code>       ... to generate for confs, i.e. all the given (non-relativistic) configurations, a common and ordered shell list;          a list::Array{Shell,1} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;subshells: ordered list for two bases&quot;, basisA::Basis,  basisB::Basis)</code>       ... to generate common and ordered subshell list for the two basis A and B; a list::Array{Subshell,1} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section><section><div><p><code>Basics.generate(&quot;single-electron spectrum: STO&quot;, N::Int64, potential::Radial.Potential, grid::Radial.Grid; N_0::Int64=30, alpha_0::Float64=1.0,                     beta_0::Float64=1.1)</code>      ... to generate a complete one-electron spectrum with N positive and N negative states, and by using even-tempered Slater-type          orbitals (STO) with parameters <span>$lpha_i = lpha_0 eta_0^i$</span>; a spectrum::SingleElecSpectrum is returned where just          N0 positive and N_0 negative are kept for later use.  <strong>Not yet implemented !</strong></p><p><code>Basics.generate(&quot;single-electron spectrum: STO, positive&quot;, N::Int64, potential::Radial.Potential, grid::Radial.Grid; N_0::Int64=30, alpha_0::Float64=1.0,                     beta_0::Float64=1.1)</code>       ... to generate the same but to return only the N_0 positive states.  <strong>Not yet implemented !</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>Well, this is quite a lot, and we shall explain some of these methods below; a similar or even larger output, you can generate by <code>? perform</code> as well as few other terms that are central to the implementation of JAC.</p><p><strong>Constructors &amp; program control:<span>$\quad$</span></strong> Another frequent use of the (help) &quot;?&quot; concerns the data flow and control of almost all computations. In JAC, we often make use of (so-called) <code>Settings</code> that enable the user to overwrite default values or to <em>control</em> the computation to the extent, he or she wishes to have control. These <code>Settings</code> are context dependent and are different for each atomic property or process that can be computed by the JAC toolbox. They are defined in the various modules and need to be specified accordingly. For instance, to control the computation of transition probabilities for the (fine-structure) levels between given initial- and final-state configuration, one has to overwrite the (defaults) settings:</p><pre><code class="nohighlight hljs">? PhotoEmission.Settings</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.PhotoEmission.Settings-getting-started-julia" href="#JAC.PhotoEmission.Settings-getting-started-julia"><code>JAC.PhotoEmission.Settings</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  PhotoEmission.Settings  &lt;:  AbstractProcessSettings</code>       ... defines a type for the details and parameters of computing radiative lines.</p><pre><code class="nohighlight hljs">+ multipoles              ::Array{EmMultipoles}     ... Specifies the (radiat. field) multipoles to be included.
+ gauges                  ::Array{UseGauge}         ... Gauges to be included into the computations.
+ calcAnisotropy          ::Bool                    ... True, if the anisotropy (structure) functions are to be 
                                                        calculated and false otherwise 
+ printBefore             ::Bool                    ... True, if all energies and lines are printed before comput.
+ corePolarization        ::CorePolarization        ... Parametrization of the core-polarization potential/contribution.
+ lineSelection           ::LineSelection           ... Specifies the selected levels, if any.
+ photonEnergyShift       ::Float64                 ... An overall energy shift for all photon energies.
+ mimimumPhotonEnergy     ::Float64                 ... minimum transition energy for which (photon) transitions 
                                                        are included into the computation.
+ maximumPhotonEnergy     ::Float64                 ... maximum transition energy for which (photon) transitions 
                                                        are included.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>We shall meet these and (many) other settings quite often in the tutorials below. –- Beside of Julia&#39;s help features (?), however, it is sometimes difficult to remember the right term or function name. In this case, it easy to make a &lt;double-tab&gt; after the dot (notation) or to make use of the (Unix/Linux) <code>grep</code> command within the <code>JAC/src</code> directly. Similar line-search commands will exist also at other platforms. In particular, for those of you who wishes to support and extend the JAC toolbox, the dot expansion and the <code>grep</code> command will be found very helpful, perhaps more than other search tools.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Users can also refer to the API Reference section that provides a comprehensive list of JAC declared <code>Type</code>s and <code>Function</code>s for selected atomic processes.</p></div></div><p><strong>Use of constructors:<span>$\quad$</span></strong> Another Julia feature, that is frequently applied in JAC, is the successive definition of constructors in order to set-up complex data structures. This features is applied, for instance, in order to define an <code>Atomic.Computation</code> or a <code>Cascade.Computation</code> as a whole. We shall explain these rather complex data types below in different tutorials. The same issue appears however already at a much simpler level. For example, if we wish to select (specify) a number of levels from a multiplet prior to some particular – configuration interaction – computation, we can make use of a</p><pre><code class="nohighlight hljs">? LevelSelection</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Basics.LevelSelection-getting-started-julia" href="#JAC.Basics.LevelSelection-getting-started-julia"><code>JAC.Basics.LevelSelection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  Basics.LevelSelection  &lt;  Basics.AbstractSelection</code>       ... defines a struct to specify a list of levels by means of their (level) indices or level symmetries.</p><pre><code class="nohighlight hljs">+ active       ::Bool                     ... true, if some selection has been made.
+ indices      ::Array{Int64,1}           ... List of selected indices.
+ symmetries   ::Array{LevelSymmetry,1}   ... List of selected symmetries</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>Apart from the logical flag <code>active</code>, such a level selection requires to either specify a list of level numbers (indices) or <em>level symmetries</em></p><pre><code class="language-julia hljs">LevelSelection(true, indices= [i for i in 1:11])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LevelSelection:  indices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];    symmetries = LevelSymmetry[].</code></pre><pre><code class="language-julia hljs">LevelSelection(true, symmetries= [LevelSymmetry(1//2, Basics.plus)])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LevelSelection:  indices = Int64[];    symmetries = LevelSymmetry[1/2 +].</code></pre><p>Here, we made use of a LevelSymmetry to specify the overall rotational <span>$J^P$</span> symmetry of atomic levels.</p><pre><code class="nohighlight hljs">? LevelSymmetry</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JAC.Basics.LevelSymmetry-getting-started-julia" href="#JAC.Basics.LevelSymmetry-getting-started-julia"><code>JAC.Basics.LevelSymmetry</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct  Basics.LevelSymmetry  &lt;  AbstractAngularMomentum</code>  ... defines a struct for defining the overall J^P symmetry of a level.</p><pre><code class="nohighlight hljs">+ J          ::AngularJ64  ... total angular momentum of a level
+ parity     ::Parity      ... total parity of the level</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OpenJAC/JAC.jl">source</a></section></article><p>As seen from this definition, the level symmetry just comprises the total angular momentum (of type <code>AngularJ64</code>) and the parity of the level (of type <code>Parity</code>). Therefore, the specification of a list of level symmetries in <code>LevelSelection</code> already requires to nest four constructors in order make the level selection explicit: (i) For the angular momentum, (ii) the parity, (iii) the level symmetry and (iv) to create a list (array) of such level symmetries. All the constructors can be specified and built together also in subsequent steps, such as:</p><pre><code class="language-julia hljs">J1    = AngularJ64(1//2);           J2 = AngularJ64(5//2)
pl    = Basics.plus;                mn = Basics.minus
lsym1 = LevelSymmetry(J1, pl);      lsym2 = LevelSymmetry(J2, mn)
levelsyms = [lsym1, lsym2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{LevelSymmetry}:
 1/2 +
 5/2 -</code></pre><p>or simply by <em>nesting</em> all the information within a single step</p><pre><code class="language-julia hljs">levelsyms = [LevelSymmetry(AngularJ64(1//2), Basics.plus), LevelSymmetry(AngularJ64(5//2), Basics.minus)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{LevelSymmetry}:
 1/2 +
 5/2 -</code></pre><p>Both way have their pros and cons, and often some <em>mixture</em> is applied where complex constructors are first assigned to some variables, and which are later utilized to built up constructors of higher complexity. –- To finally specify aǹ instance of a <code>LevelSelection</code>, we use (onc more) its second constructor above:</p><pre><code class="language-julia hljs">LevelSelection(true, indices=[1,2,3], symmetries=levelsyms)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LevelSelection:  indices = [1, 2, 3];    symmetries = LevelSymmetry[1/2 +, 5/2 -].</code></pre><p>and which will tell the JAC program to compute the lowest three levels (1, 2, 3) as well as all levels with 1/2+ and 5/2- symmetry. Apart from the selection of individual levels, it is often helpful for the computation of atomic processes to make a prior <code>LineSelection</code> and in some cases even a <code>PathwaySelection</code> as, for instance, for dielectronic recombination processes. Some of these features will be explained below in subsequent tutorials of JAC:</p><p><strong>Functions &amp; methods:<span>$\quad$</span></strong> Like most other languages, Julia is based on the successive work through functions and methods; a <strong>function</strong> is first of all specified by its name and it maps a tuple of argument values upon a return value. For instance, the function</p><pre><code class="language-julia hljs">function addSomething(a, b)
    c = a + b
end
addSomething(3.1, 5//2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.6</code></pre><p>can be used to <em>add</em> two numbers, rather independent of their particular type, and which are <em>infered</em> here automatically. However, additional type declarations might help to <em>specialize</em> a function and to ensure <strong>type stability</strong>:</p><pre><code class="language-julia hljs">function addSomething(a::Int64, b::Int64, c::Int64)
    d = a + b + c
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">addSomething (generic function with 2 methods)</code></pre><p>While the function name is the same in both of these examples above, Julia carefully distinguishes between these two <strong>methods</strong> of the function <code>addSomething</code> that may differ by the type <em>and/or</em> the number of arguments. This multiple <em>use</em> <strong>(dispatch)</strong> of function name enables the user to write highly specialized code. Although a proper (and specialized) definition of functions is often very important for the performance of the program, we shall not discuss such technical issues here. Let us just mention, that a function/method may also return <code>nothing</code>:</p><pre><code class="language-julia hljs">typeof(nothing)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Nothing</code></pre><p>In JAC, the value <code>nothing</code> is usually returned by all <em>display</em> functions that print some selected data or tabulation to screen or elsewhere but does not return a value otherwise.</p><p><strong>Code failures:<span>$\quad$</span></strong> Beside of its large flexibility and user-friendliness, JAC might terminate from time to time for <em>non-obvious</em> reasons. Since JAC is first of all a <em>physics code</em>, no attempt has been made that all possible errors are fully captured and recovered by the program. Wrong input parameters or an inappropriate use of contructors will often lead to errors that cannot be resolved by the program. While some of this input can be readily recognized as wrong, and then lead to a proper error message, other wrong data may appear dynamically and cannot be captured with a reasonable overhead of the code.  In JAC, therefore, several conditional <code>if ... elseif ... else ... end</code> blocks include an additional clause <code>error(&quot;stop a&quot;)</code> or similar; these are clauses, which due to a first design of a function should never be entered, but this appears not to be true in all cases. The use of these (fully) <em>non-instructive</em> error message have still a great advantage due to Julia: If not switched-off explicitly, Julia always reports for all program failures the hierarchy of call&#39;s, that are made before the error occurs, and lists these calls together with the file and line number of source code. For this reason, an <code>error(&quot;stop a&quot;)</code> readily shows the position where something unexpected occurs. A short inspection of the corresponding (line of the) source code often help to understand of what went wrong internally.</p><p><strong>Julia macros:<span>$\quad$</span></strong>  What can one do, if the (source) code itself does not tell so much about the problem ? –- In this case, it is often useful to include some additional <strong>printouts</strong>  near to the line in question into the code and to re-run it again. There are different ways (<code>@show</code>, <code>print()</code>, <code>println()</code>) to place printout in the code; cf. https://julialang.org/learning/  A particular quick and useful way makes use of the Julia macro:</p><pre><code class="language-julia hljs">@show levelsyms</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{LevelSymmetry}:
 1/2 +
 5/2 -</code></pre><p>which simply repeats the <em>names</em> of the variables together with their values. Of course, the values of several such variables can be shown within the same call:</p><pre><code class="language-julia hljs">wa = 5;   wb = [2.0, pi];   wc = ones(3)
@show wa, wb, wc</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(5, [2.0, 3.141592653589793], [1.0, 1.0, 1.0])</code></pre><p>Indeed, this <code>@show</code> macro makes printout very easy. There are many macros (all starting with <code>@</code>) in Julia which need not to be considered here. We just mention that <code>@time</code> in front of a Julia command (block) will take and display the CPU time that is necessary to run this line(s):</p><pre><code class="language-julia hljs">@time rand(50000)   ;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">50000-element Vector{Float64}:
 0.33908187215733443
 0.210915165244009
 0.4739048253673537
 0.012402722114812192
 0.6552666848312372
 0.022803316624286363
 0.059622977881615746
 0.4492791169996385
 0.885456275071525
 0.6195657614772923
 ⋮
 0.9604923422596193
 0.5577446607846457
 0.27841445269554743
 0.373210575390605
 0.9852916393817458
 0.9730587921101319
 0.051744969104934646
 0.847370615557029
 0.6828991889974071</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="getting-started-jac.html">Getting started with JAC (in REPL) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 22 April 2025 09:29">Tuesday 22 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
