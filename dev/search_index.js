var documenterSearchIndex = {"docs":
[{"location":"reference.html","page":"Publications Reference","title":"Publications Reference","text":"For reference to (using) this code, please, use the Computer Physics Communications publication on JAC:","category":"page"},{"location":"reference.html","page":"Publications Reference","title":"Publications Reference","text":"S. Fritzsche: A fresh computational approach to atomic structures, processes and cascades     Computer Physics Communications 240, 1 (2019)\nG. Gaigalas & S. Fritzsche: Angular coefficients for symmetry-adapted configuration states in jj-coupling.    Comp. Phys. Commun. 267, 108086 (2021)\nS. Fritzsche, P. Palmeri & S. Schippers: Atomic cascade computations. Symmetry 13, 520 (2021)\nS. Fritzsche: Symbolic evaluation of expressions from Racah’s algebra. Symmetry 13, 1558 (2021)\nS. Fritzsche & A. Surzhykov: Approximate atomic Green functions. Molecules 26, 2660 (2021)\nS. Fritzsche: Dielectronic recombination strengths and plasma rate coefficients of multiply-charged ions.    A&A 656, A163 (2021)\nS. Fritzsche: Level structure and properties of open f-shell elements. Atoms 10, 7 (2022)\nS. Fritzsche: Photon emission from hollow ions near surfaces. Atoms 10, 37 (2022)\nS. Fritzsche, B. Böning: Strong-field ionization amplitudes for atomic many-electron targets. Atoms 10, 70 (2022)\nS. Fritzsche: Application of symmetry-adapted atomic amplitudes. Atoms 10, 127 (2022)\nS. Fritzsche, A.V. Maiorova & Z.W. Wu: Radiative recombination plasma rate coefficients of multiply-charged ions.    Atoms 11, 50 (2023)\nS. Fritzsche, L.G. Jiao, Y.C. Wang & J.E. Sienkiewicz; Collision strengths of astrophysical interest for multiply charged ions.    Atoms 11, 80 (2023)\nS. Fritzsche, A.K. Sahoo, L.Sharma, Z.W. Wu & S. Schippers; Merits of atomic cascade computations.    European Physical Journal D 78, 75 (2024)\nA.K. Sahoo, S. Fritzsche & L.Sharma; Computation of effective collision strengths for plasma applications using JAC.    European Physical Journal Plus 139, 986 (2024)\nS. Fritzsche, H.K. Huang, Z.K. Huang, S. Schippers, W.Q. Wen and Z.W. Wu; Dielectronic recombination into high-n Rydberg shells.    European Physical Journal D 79, 22 (2025)\nS. Fritzsche; Atomic input for modeling ionic mixtures in astrophysical plasma.    European Physical Journal A 61, 63 (2025)","category":"page"},{"location":"api.html#Autoionization","page":"API Reference","title":"Autoionization","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [AutoIonization]\nOrder   = [:type, :function]","category":"page"},{"location":"api.html#JAC.AutoIonization.Channel","page":"API Reference","title":"JAC.AutoIonization.Channel","text":"struct  Channel        ... defines a type for a AutoIonization channel to help characterize a scattering (continuum) state of many          electron-states with a single free electron.\n\n+ kappa          ::Int64                ... partial-wave of the free electron\n+ symmetry       ::LevelSymmetry        ... total angular momentum and parity of the scattering state\n+ phase          ::Float64              ... phase of the partial wave\n+ amplitude      ::Complex{Float64}     ... Auger amplitude associated with the given channel.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.AutoIonization.Line","page":"API Reference","title":"JAC.AutoIonization.Line","text":"struct  Line       ... defines a type for a AutoIonization line that may include the definition of sublines and their          corresponding amplitudes.\n\n+ initialLevel   ::Level           ... initial-(state) level\n+ finalLevel     ::Level           ... final-(state) level\n+ electronEnergy ::Float64         ... Energy of the (incoming free) electron.\n+ totalRate      ::Float64         ... Total rate of this line.\n+ angularAlpha   ::Float64         ... Angular alpha_2 coefficient.\n+ channels       ::Array{AutoIonization.Channel,1}  ... List of AutoIonization channels of this line.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.AutoIonization.Line-Tuple{Level, Level, Float64}","page":"API Reference","title":"JAC.AutoIonization.Line","text":"AutoIonization.Line(initialLevel::Level, finalLevel::Level, totalRate::Float64)       ... constructor for an AutoIonization line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.PlasmaSettings","page":"API Reference","title":"JAC.AutoIonization.PlasmaSettings","text":"struct  AutoIonization.PlasmaSettings  <:  Basics.AbstractLineShiftSettings       ... defines a type for the details and parameters of computing Auger rates with plasma interactions.\n\n+ printBefore         ::Bool             ... True, if all energies and lines are printed before their evaluation.\n+ lineSelection       ::LineSelection    ... Specifies the selected levels, if any.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.AutoIonization.PlasmaSettings-Tuple{}","page":"API Reference","title":"JAC.AutoIonization.PlasmaSettings","text":"AutoIonization.PlasmaSettings()  ... constructor for a standard instance of AutoIonization.PlasmaSettings.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.Settings","page":"API Reference","title":"JAC.AutoIonization.Settings","text":"struct  Settings  <:  AbstractProcessSettings  ... defines a type for the details and parameters of computing Auger lines.\n\n+ calcAnisotropy      ::Bool               ... True, if the intrinsic alpha_2,4 angular parameters are to be \n                                                calculated, and false otherwise.\n+ calcTeAuger         ::Bool               \n    ... True, if contributions of the two-electron Auger transitions are to be calculated, and false otherwise;\n        this flag requires a proper (resonant) Green function that supports the TEA transitions.\n+ printBefore         ::Bool               ... True, if all energies and lines are printed before their evaluation.\n+ lineSelection       ::LineSelection      ... Specifies the selected levels, if any.\n+ augerEnergyShift    ::Float64            ... An overall energy shift for all Auger (free-electron) energies.\n+ minAugerEnergy      ::Float64            ... Minimum energy of free (Auger) electrons to be included.\n+ maxAugerEnergy      ::Float64            ... Maximum energy of free (Auger) electrons to be included.\n+ maxKappa            ::Int64              ... Maximum kappa value of partial waves to be included.\n+ operator            ::AbstractEeInteraction   \n    ... Auger operator that is to be used for evaluating the Auger amplitudes; allowed values are: \n        CoulombInteraction(), BreitInteraction(), ...\n+ gMultiplet          ::Multiplet      \n    ... Mean-field multiplet of intermediate levels in the computations, sometimes referred to as\n        (resonant) Green function.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.AutoIonization.Settings-Tuple{JAC.AutoIonization.Settings}","page":"API Reference","title":"JAC.AutoIonization.Settings","text":"AutoIonization.Settings(set::AutoIonization.Settings;\n\n    calcAnisotropy=..,      calcTeAuger..,              printBefore=..,         augerEnergyShift=.., \n    minAugerEnergy=..,      maxAugerEnergy=..,          maxKappa=..,            operator=..,\n    gMultiplet=.. )\n                \n... constructor for modifying the given AutoIonization.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.Settings-Tuple{}","page":"API Reference","title":"JAC.AutoIonization.Settings","text":"AutoIonization.Settings()  ... constructor for the default values of AutoIonization line computations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.amplitude-Tuple{AbstractEeInteraction, JAC.AutoIonization.Channel, Level, Level, JAC.Radial.Grid}","page":"API Reference","title":"JAC.AutoIonization.amplitude","text":"AutoIonization.amplitude(kind::AbstractEeInteraction, channel::AutoIonization.Channel, continuumLevel::Level, initialLevel::Level,                              grid::Radial.Grid; printout::Bool=true)       ... to compute the kind in  CoulombInteraction(), BreitInteraction(), CoulombBreit(), CoulombGaunt()   Auger amplitude          <(alphaf Jf, kappa) Ji || O^(Auger, kind) || alphai J_i>  due to the interelectronic interaction for the given          final and initial level. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.channelAmplitude-Tuple{String, JAC.AutoIonization.Channel, Float64, Level, Level, JAC.Radial.Grid}","page":"API Reference","title":"JAC.AutoIonization.channelAmplitude","text":"AutoIonization.channelAmplitude(kind::String, channel::AutoIonization.Channel, energy::Float64, finalLevel::Level,                                      initialLevel::Level, grid::Radial.Grid)       ... to compute the kind = (CoulombInteraction(), BreitInteraction(), CoulombBreit(), CoulombGaunt())   Auger amplitude           <(alphaf Jf, kappa) Ji || O^(Auger, kind) || alphai J_i>  due to the interelectronic interaction for the given final and          initial level. A newChannel::AutoIonization.Channel is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.computeAmplitudesProperties-Tuple{JAC.AutoIonization.Line, Model, JAC.Radial.Grid, Int64, JAC.AutoIonization.Settings}","page":"API Reference","title":"JAC.AutoIonization.computeAmplitudesProperties","text":"AutoIonization.computeAmplitudesProperties(line::AutoIonization.Line, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,                                              settings::AutoIonization.Settings; printout::Bool=true)      ... to compute all amplitudes and properties of the given line; a line::AutoIonization.Line is returned for which the amplitudes          and properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.computeAmplitudesPropertiesPlasma-Tuple{JAC.AutoIonization.Line, Model, JAC.Radial.Grid, Int64, JAC.AutoIonization.PlasmaSettings}","page":"API Reference","title":"JAC.AutoIonization.computeAmplitudesPropertiesPlasma","text":"AutoIonization.computeAmplitudesPropertiesPlasma(line::AutoIonization.Line, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,                                                    settings::AutoIonization.PlasmaSettings; printout::Bool=true)       ... to compute all amplitudes and properties of the given line but for the given plasma model; a line::AutoIonization.Line is returned          for which the amplitudes and properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.computeIntrinsicAlpha-Tuple{Int64, JAC.AutoIonization.Line}","page":"API Reference","title":"JAC.AutoIonization.computeIntrinsicAlpha","text":"AutoIonization.computeIntrinsicAlpha(k::Int64, line::AutoIonization.Line)       ... to compute the intrinsic alpha_k anisotropy parameter for the given line. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.computeLines-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.AutoIonization.Settings}","page":"API Reference","title":"JAC.AutoIonization.computeLines","text":"AutoIonization.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                  settings::AutoIonization.Settings; output=true, printout::Bool=true)       ... to compute the Auger transition amplitudes and all properties as requested by the given settings. A list of          lines::Array{AutoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.computeLinesCascade-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.AutoIonization.Settings}","page":"API Reference","title":"JAC.AutoIonization.computeLinesCascade","text":"AutoIonization.computeLinesCascade(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                      settings::AutoIonization.Settings; output::Bool=true, printout::Bool=true)       ... to compute the Auger transition amplitudes and all properties as requested by the given settings. The computations         and printout is adapted for large cascade computations by including only lines with at least one channel and by sending         all printout to a summary file only. A list of lines::Array{AutoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.computeLinesFromOrbitals-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.AutoIonization.Settings, Dict{Subshell, Orbital}}","page":"API Reference","title":"JAC.AutoIonization.computeLinesFromOrbitals","text":"AutoIonization.computeLinesFromOrbitals(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                              settings::AutoIonization.Settings, contOrbitals::Dict{Subshell, Orbital}; output::Bool=true, printout::Bool=true)       ... to compute the Auger transition amplitudes and all properties as requested by the given settings but by using the given set of          continuum orbitals. The computations and printout is adapted for large cascade computations by including only lines with at least          one channel and by sending all printout to a summary file only. A list of lines::Array{AutoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.computeLinesPlasma-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.AutoIonization.PlasmaSettings}","page":"API Reference","title":"JAC.AutoIonization.computeLinesPlasma","text":"AutoIonization.computeLinesPlasma(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                     settings::AutoIonization.PlasmaSettings; output=true)       ... to compute the Auger transition amplitudes and all properties as requested by the given settings. A list of          lines::Array{AutoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.computeTeaAmplitude-Tuple{AbstractEeInteraction, JAC.AutoIonization.Channel, Level, Multiplet, Level, JAC.Radial.Grid}","page":"API Reference","title":"JAC.AutoIonization.computeTeaAmplitude","text":"AutoIonization.computeTeaAmplitude(kind::AbstractEeInteraction, channel::AutoIonization.Channel, continuumLevel::Level,                                      gMultiplet::Multiplet, initialLevel::Level, grid::Radial.Grid; printout::Bool=true)       ... to compute the kind in  CoulombInteraction(), BreitInteraction(), CoulombBreit() total Auger amplitude          for the two-electron Auger transitions via the gMultiplet as the resonant Green function:\n\n    <(alpha_f J_f, kappa) J_i || O^(TEA, kind) || alpha_i J_i> \n    \n                <(alpha_f J_f, kappa) J_i || O^(Auger, kind) || alpha_in J_n> <J_n || O^(e-e, kind) || alpha_i J_i>\n            = ---------------------------------------------------------------------------------------------------\n                                                                E_i  -  E_n\n                                                                \n    due to the interelectronic interaction as well as the given initial, intermediate (gMultiplet), and final \n    (continuum) levels and the given kind of interaction. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.determineChannels-Tuple{Level, Level, JAC.AutoIonization.Settings}","page":"API Reference","title":"JAC.AutoIonization.determineChannels","text":"AutoIonization.determineChannels(finalLevel::Level, initialLevel::Level, settings::AutoIonization.Settings)       ... to determine a list of Auger Channel for a transitions from the initial to final level and by taking into account the particular          settings of for this computation; an Array{AutoIonization.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.determineLines-Tuple{Multiplet, Multiplet, JAC.AutoIonization.Settings}","page":"API Reference","title":"JAC.AutoIonization.determineLines","text":"AutoIonization.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::AutoIonization.Settings)       ... to determine a list of AutoIonization.Line's for transitions between levels from the initial- and final-state multiplets, and           by taking into account the particular selections and settings for this computation; an Array{AutoIonization.Line,1} is returned.          Apart from the level specification, all physical properties are set to zero during the initialization process.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.displayLifetimes-Tuple{IO, Vector{JAC.AutoIonization.Line}}","page":"API Reference","title":"JAC.AutoIonization.displayLifetimes","text":"AutoIonization.displayLifetimes(stream::IO, lines::Array{AutoIonization.Line,1})       ... to list all lifetimes as associated with the selected lines. A neat table is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.displayLines-Tuple{IO, Vector{JAC.AutoIonization.Line}}","page":"API Reference","title":"JAC.AutoIonization.displayLines","text":"AutoIonization.displayLines(stream::IO, lines::Array{AutoIonization.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all selected          transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.AutoIonization.displayRates-Tuple{IO, Vector{JAC.AutoIonization.Line}, JAC.AutoIonization.Settings}","page":"API Reference","title":"JAC.AutoIonization.displayRates","text":"AutoIonization.displayRates(stream::IO, lines::Array{AutoIonization.Line,1}, settings::AutoIonization.Settings)       ... to list all results, energies, rates, etc. of the selected lines. A neat table is printed but nothing is returned          otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Dielectronic-Recombination","page":"API Reference","title":"Dielectronic Recombination","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [DielectronicRecombination]\nOrder   = [:type, :function]","category":"page"},{"location":"api.html#JAC.DielectronicRecombination.AbstractCorrections","page":"API Reference","title":"JAC.DielectronicRecombination.AbstractCorrections","text":"abstract type DielectronicRecombination.AbstractCorrections      ... defines an abstract type to distinguish different types of corrections to the decay rates and strength.         These corrections are based on the classification of shell:\n\n    n^(core)  <   n^(final)  <  n^(hydrogenic)  <  n^(lowest-captured)  <  n^(lower-empirical)    \n              <=  n^(upper-empirical)              ... where\n              \n    n^(core)            ... refers to the (maximum) principal quantum number to which initial core electrons are excited;\n    n^(final)           ... the maximum number for which shells are treated explicitly in the representation of the final levels f;\n    n^(hydrogenic)      ... to the maximum n-shell, to which the radiative decay is modeled by scaled-hydrogenic rates, \n                        ... and which can be omitted also from the list. \n    n^(lowest-captured) ... is the lowest, high-n shell, into which the additional electron is captured and which must\n                            (of course) occur explicitly in the basis of the intermediate and final levels. \n    [n^(lower-empirical)  <=  n^(upper-empirical)]  \n                        ... designates additional (empirical) high-n shells for which the contributions to the DR resonances \n                            are still estimated empirically by using arguments from quantum-defect theory. All shells with \n                            n > n^(upper-empirical) are neglected completely for their contributions to the DR spectra; see also:\n\n+ struct DielectronicRecombination.EmpiricalCorrections  \n    ... to estimate empirically the contributions of additional resonances for the capture of an electron into\n        shells with [n^(lower-empirical)  <=  n^(upper-empirical)]. A simple scaling of the rates, calculated initially\n        for n^(lowest-captured), ... only, is utilized for estimating the associated strength for these additional\n        resonances.\n+ struct DielectronicRecombination.HydrogenicCorrections  \n    ... to add for missing final decay levels to the (total) photon decay rates by scaling the corresponding rates\n        of non-relativistic hydrogenic ions with a suitable effective charge (Zeff); these hydrogenic corrections improve\n        goth, the total photon rate as well as the resonance strength.\n+ struct DielectronicRecombination.MaximumlCorrection  \n    ... to exclude all subshells with l > l_max in the hydrogenic corrections; this restriction does not apply to the \n        given resonance levels, which can be controlled (and are specified) by the list of intermediate configurations.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.DielectronicRecombination.EmpiricalCorrections","page":"API Reference","title":"JAC.DielectronicRecombination.EmpiricalCorrections","text":"struct  DielectronicRecombination.EmpiricalCorrections  <:  DielectronicRecombination.AbstractCorrections       ... to include empirical corrections for the shells with [n^(lower-empirical)  <=  n^(upper-empirical)].         A rather rude model is used so far.\n\n+ nUpperEmpirical ::Union{Int64,Missing}   \n    ... The upper-empirical shell for which rate contributions are estimated; the lower-empirical shell = n^(captured-max + 1) \n        is derived from the given configuration lists. No corrections are made for nUpperEmpirical <= n^(captured-max + 1).\n+ effectiveZ      ::Union{Float64,Missing}  ... effective charge Z_eff for the hydrogenic correction (inactive).\n+ rateScaling     ::Union{Float64,Missing}  ... scaling factor to modify the estimated rates.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.DielectronicRecombination.EmpiricalTreatment","page":"API Reference","title":"JAC.DielectronicRecombination.EmpiricalTreatment","text":"struct  DielectronicRecombination.EmpiricalTreatment       ... defines an (internal) type to communicate and distribute the physical (and technical) parameters         that are utilized to make the requested empirical corrections or just nothing. This data type should         not be applied by the user but is initialized by the given (set of) corrections.         Otherwise, it is treated like any other type in JAC. All parameters are made physically \"explicit\",         even if they were \"missing\" originally, and can be directly applied in the empirical treatment of         the DR process. The following hierarchy of shells is used:\n\n    n^(core)  <   n^(final)  <  n^(hydrogenic)  <  n^(lowest-captured)  <  n^(lower-empirical)    \n              <=  n^(upper-empirical) \n    \n+ doEmpiricalCorrections      ::Bool    ... True, if empirical corrections are needed, false o/w.\n+ doHydrogenicCorrections     ::Bool    ... True, if hydrogenic corrections are needed, false o/w.\n+ doMaximumlCorrection        ::Bool    ... True, if a maximum l values is used, false o/w.\n+ doResonanceWindowCorrection ::Bool    ... True, if a window of resonances is specified, false o/w.\n+ nCore                       ::Int64   \n    ... (maximum) principal quantum number to which initial core electrons are excited;\n+ nFinal                      ::Int64   \n    ... the maximum number for which shells are treated explicitly in the representation of the final levels f;\n+ nHydrogenic                 ::Int64   \n    ... maximum n-shell, to which the radiative decay is modeled by scaled-hydrogenic rates. \n+ nLowestCaptured             ::Int64   \n    ... lowest, high-n shell, into which the additional electron is captured and which must (of course) occur \n        explicitly in the basis of the intermediate and final levels.\n+ nLowerEmpirical             ::Int64   \n    ... maximum n-shell, to which the radiative decay is modeled by scaled-hydrogenic rates. \n+ nUpperEmpirical             ::Int64   \n    ... additional (empirical) high-n shells for which the contributions to the DR resonances are still \n        estimated empirically by using arguments from quantum-defect theory.\n+ maximum_l                   ::Int64    ... maximum l value; is set to a large value if not specified by the user.\n+ hydrogenicEffectiveZ        ::Float64  ... effective charge Z_eff for the hydrogenic correction (inactive).\n+ hydrogenicRateScaling       ::Float64  ... scaling factor to modify the estimated hydrogenic rates.\n+ empiricalEffectiveZ         ::Float64  ... effective Z for empirical estimates\n+ empiricalRateScaling        ::Float64  ... scaling factor to modify the empirical rates.\n+ resonanceEnergyMin:         ::Float64  ... minimum energy [Hartree] of the resonances to be considered.\n+ resonanceEnergyMax:         ::Float64  ... maximum energy [Hartree] of the resonances to be considered.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.DielectronicRecombination.HydrogenicCorrections","page":"API Reference","title":"JAC.DielectronicRecombination.HydrogenicCorrections","text":"struct  DielectronicRecombination.HydrogenicCorrections  <:  DielectronicRecombination.AbstractCorrections       ... to add for missing final decay levels the photon decay rates for non-relativistic hydrogenic ions;         this improves the total photon rate as well as the resonance strength. These corrections are taken into         account for all shells with n^{final}+1 <= n <= nHydrogenic\n\n+ nHydrogenic       ::Union{Int64,Missing}   \n    ... upper principal quantum number nHydrogenic for which hydrogenic correctios to the radiative photon rates are \n        calculated explicitly; the photon rates are further scaled if some proper effectiveZ and/or rateScaling\n        is provided.\n+ effectiveZ      ::Union{Float64,Missing}   ... effective charge Z_eff for the hydrogenic correction.\n+ rateScaling     ::Union{Float64,Missing}   ... scaling factor to scale the photon rates\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.DielectronicRecombination.MaximumlCorrection","page":"API Reference","title":"JAC.DielectronicRecombination.MaximumlCorrection","text":"struct  DielectronicRecombination.MaximumlCorrection  <:  DielectronicRecombination.AbstractCorrections       ... to exclude all subshells with l > l_max, both in the treatment of the corrections shells.\n\n+ maximum_l    ::Union{Int64,Missing}   \n    ... maximum orbital angular momentum quantum number for which contributions to the DR strengths are \n        taken into account. This number applies for all subshells for which other corrections are \n        requested, whereas the \"physical subshells\" are defined by the configuration lists.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.DielectronicRecombination.Passage","page":"API Reference","title":"JAC.DielectronicRecombination.Passage","text":"struct  DielectronicRecombination.Passage       ... defines a type for a dielectronic recombination passage, i.e. a (reduced) pathways, that include the          definition of channels and their corresponding amplitudes for the individual i –> m resonances, whereas         the subsequent radiative stabilization is considered only later.\n\n+ initialLevel      ::Level                   ... initial-(state) level\n+ intermediateLevel ::Level                   ... intermediate-(state) level\n+ electronEnergy    ::Float64                 ... energy of the (incoming, captured) electron\n+ captureRate       ::Float64                 ... rate for the electron capture (Auger rate)\n+ photonRate        ::EmProperty              ... rate for the photon emission\n+ reducedStrength   ::EmProperty              \n    ... reduced resonance strength Sum_f S(i -> d -> f) * Gamma_d of this passage; this reduced strength does \n        not require the knowledge of Gamma_d for the individual passage.\n+ captureChannels   ::Array{AutoIonization.Channel,1}   ... List of |i> -->  |n>   dielectronic (Auger) capture channels.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.DielectronicRecombination.Passage-Tuple{}","page":"API Reference","title":"JAC.DielectronicRecombination.Passage","text":"DielectronicRecombination.Passage()       ... constructor for an 'empty' instance of a dielectronic recombination passage between a specified          initial and intermediate level.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.Pathway","page":"API Reference","title":"JAC.DielectronicRecombination.Pathway","text":"struct  DielectronicRecombination.Pathway       ... defines a type for a dielectronic recombination pathways that may include the definition of channels and          their corresponding amplitudes.\n\n+ initialLevel      ::Level                   ... initial-(state) level\n+ intermediateLevel ::Level                   ... intermediate-(state) level\n+ finalLevel        ::Level                   ... final-(state) level\n+ electronEnergy    ::Float64                 ... energy of the (incoming, captured) electron\n+ photonEnergy      ::Float64                 ... energy of the (emitted) photon\n+ captureRate       ::Float64                 ... rate for the electron capture (Auger rate)\n+ photonRate        ::EmProperty              ... rate for the photon emission\n+ angularBeta       ::EmProperty              ... beta parameter of the photon emission\n+ reducedStrength   ::EmProperty              ... reduced resonance strength S(i -> d -> f) * Gamma_d of this pathway;\n                                                    this reduced strength does not require the knowledge of Gamma_d for each pathway.\n+ captureChannels   ::Array{AutoIonization.Channel,1}   ... List of |i> -->  |n>   dielectronic (Auger) capture channels.\n+ photonChannels    ::Array{PhotoEmission.Channel,1}    ... List of |n> -->  |f>   radiative stabilization channels.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.DielectronicRecombination.Pathway-Tuple{}","page":"API Reference","title":"JAC.DielectronicRecombination.Pathway","text":"DielectronicRecombination.Pathway()       ... constructor for an 'empty' instance of a dielectronic recombination pathway between a specified          initial, intermediate and final level.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.Resonance","page":"API Reference","title":"JAC.DielectronicRecombination.Resonance","text":"struct  DielectronicRecombination.Resonance       ... defines a type for a dielectronic resonance as defined by a given initial and resonance level but by summing over all final levels\n\n+ initialLevel      ::Level             ... initial-(state) level\n+ intermediateLevel ::Level             ... intermediate-(state) level\n+ resonanceEnergy   ::Float64           ... energy of the resonance w.r.t. the inital-state\n+ resonanceStrength ::EmProperty        ... strength of this resonance due to the stabilization into any of the allowed final levels.\n+ captureRate       ::Float64           ... capture (Auger) rate to form the intermediate resonance, starting from the initial level.\n+ augerRate         ::Float64           ... total (Auger) rate for an electron emission of the intermediate resonance\n+ photonRate        ::EmProperty        ... total photon rate for a photon emission, i.e. for stabilization.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.DielectronicRecombination.Resonance-Tuple{}","page":"API Reference","title":"JAC.DielectronicRecombination.Resonance","text":"DielectronicRecombination.Resonance()       ... constructor for an 'empty' instance of a dielectronic resonance as defined by a given initial and resonance          level but by summing over all final levels.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.ResonanceSelection","page":"API Reference","title":"JAC.DielectronicRecombination.ResonanceSelection","text":"struct  DielectronicRecombination.ResonanceSelection       ... defines a type for selecting classes of resonances in terms of leading configurations.\n\n+ active          ::Bool              ... initial-(state) level\n+ fromShells      ::Array{Shell,1}    ... List of shells from which excitations are to be considered.\n+ toShells        ::Array{Shell,1}    ... List of shells to which (core-shell) excitations are to be considered.\n+ intoShells      ::Array{Shell,1}    ... List of shells into which electrons are initially placed (captured).\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.DielectronicRecombination.ResonanceSelection-Tuple{}","page":"API Reference","title":"JAC.DielectronicRecombination.ResonanceSelection","text":"DielectronicRecombination.ResonanceSelection()       ... constructor for an 'empty' instance of a ResonanceSelection()\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.ResonanceWindowCorrection","page":"API Reference","title":"JAC.DielectronicRecombination.ResonanceWindowCorrection","text":"struct  DielectronicRecombination.ResonanceWindowCorrection  <:  DielectronicRecombination.AbstractCorrections       ... to exclude all DR resonances outside of a given \"window [Emin, Emax]\" of resonance energies with         regard to the initial level.\n\n+ energyMin  ::Float64   ... minimum energy [Hartree] of the resonances to be considered.  \n+ energyMax  ::Float64   ... maximum energy [Hartree] of the resonances to be considered.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.DielectronicRecombination.Settings","page":"API Reference","title":"JAC.DielectronicRecombination.Settings","text":"struct  DielectronicRecombination.Settings  <:  AbstractProcessSettings       ... defines a type for the details and parameters of computing dielectronic recombination pathways.\n\n+ multipoles            ::Array{EmMultipoles}  ... Multipoles of the radiation field that are to be included.\n+ gauges                ::Array{UseGauge}      ... Specifies the gauges to be included into the computations.\n+ calcOnlyPassages      ::Bool                 \n    ... Only compute resonance strength but without making all the pathways explicit. This option is useful\n        for the capture into high-n shells or if the photons are not considered explicit. It also treats the \n        shells differently due to the given core shells < final-state shells < hydrogenically-scaled shells <\n        capture-shells < asymptotic-shells. Various correction and multi-threading techiques can be applied\n        to deal with or omit different classes of these shells.\n+ calcRateAlpha         ::Bool                 \n    ... True, if the DR rate coefficients are to be calculated, and false o/w.\n+ printBefore           ::Bool                 \n    ... True, if all energies and pathways are printed before their evaluation.\n+ pathwaySelection      ::PathwaySelection     ... Specifies the selected levels/pathways, if any.\n+ electronEnergyShift   ::Float64              \n    ... An overall energy shift for all electron energies (i.e. from the initial to the resonance levels [Hartree].\n+ photonEnergyShift     ::Float64              \n    ... An overall energy shift for all photon energies (i.e. from the resonance to the final levels.\n+ mimimumPhotonEnergy   ::Float64              \n    ... minimum transition energy for which photon transitions are  included into the evaluation.\n+ temperatures          ::Array{Float64,1}     \n    ... list of temperatures for which plasma rate coefficients are displayed; however, these rate coefficients\n        only include the contributions from those pathsways that are calculated here explicitly.\n+ corrections           ::Array{DielectronicRecombination.AbstractCorrections,1}\n    ... Specify, if appropriate, the inclusion of additional corrections to the rates and DR strengths.\n+ augerOperator         ::AbstractEeInteraction \n    ... Auger operator that is to be used for evaluating the Auger amplitude's; the allowed values are: \n        CoulombInteraction(), BreitInteration(), CoulombBreit(), CoulombGaunt().\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.DielectronicRecombination.Settings-Tuple{JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.Settings","text":"(set::DielectronicRecombination.Settings;\n\n    multipoles=..,             gauges=..,                  \n    calcOnlyPassages=..,       calcRateAlpha=..,         printBefore=..,           pathwaySelection=..,     \n    electronEnergyShift=..,    photonEnergyShift=..,       \n    mimimumPhotonEnergy=..,    temperatures=..,          corrections=..,           augerOperator=..)\n                \n... constructor for modifying the given DielectronicRecombination.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.Settings-Tuple{}","page":"API Reference","title":"JAC.DielectronicRecombination.Settings","text":"DielectronicRecombination.Settings()       ... constructor for the default values of dielectronic recombination pathway computations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.addEmpiricalPassages!-Tuple{Vector{JAC.DielectronicRecombination.Passage}, JAC.DielectronicRecombination.EmpiricalTreatment}","page":"API Reference","title":"JAC.DielectronicRecombination.addEmpiricalPassages!","text":"DielectronicRecombination.addEmpiricalPassages!(passages::Array{DielectronicRecombination.Passage,1},                                                  empTreatment::EmpiricalTreatment)       ... to add further (empirical) passages due to the capture of electrons into higher n-shells; information         about the last \"captured\" shell as well as the interval [nLowerEmpirical, nUpperEmpirical] are taken from         empTreatment. A simple scaling rules of energies and rates are presently applied bu could be improved         if needed. The array passages::Array{DielectronicRecombination.Passage,1} is modified and nothing is         returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.checkConsistentMultiplets-Tuple{Multiplet, Multiplet, Multiplet}","page":"API Reference","title":"JAC.DielectronicRecombination.checkConsistentMultiplets","text":"DielectronicRecombination.checkConsistentMultiplets(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet,                                                       initialMultiplet::Multiplet)       ... to check that the given initial-, intermediate- and final-state levels and multiplets are consistent to each other and         to avoid later problems with the computations. An error message is issued if an inconsistency occurs,         and nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.checkOrbitalRepresentation-Tuple{Multiplet, Multiplet, Multiplet}","page":"API Reference","title":"JAC.DielectronicRecombination.checkOrbitalRepresentation","text":"DielectronicRecombination.checkOrbitalRepresentation(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet,                                                        initialMultiplet::Multiplet)       ... to check (and analyze) that all high nl orbitals in these multiplets are properly represented on the given grid.         The function prints for each symmetry block kappa the high-nl orbitals and checks that they are all bound.         An error message is issued if this is not the case, and nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.computeAmplitudesProperties-Tuple{JAC.DielectronicRecombination.Passage, Multiplet, Model, JAC.Radial.Grid, Int64, JAC.DielectronicRecombination.EmpiricalTreatment, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.computeAmplitudesProperties","text":"DielectronicRecombination.computeAmplitudesProperties(passage::DielectronicRecombination.Passage,                             finalMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,                             empTreatment::EmpiricalTreatment, settings::DielectronicRecombination.Settings)      ... to compute all amplitudes and properties of the given line; a line::DielectronicRecombination.Pathway is returned          for which the amplitudes and properties have now been evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.computeAmplitudesProperties-Tuple{JAC.DielectronicRecombination.Pathway, Model, JAC.Radial.Grid, Int64, JAC.DielectronicRecombination.Settings, Bool, Vector{JAC.AutoIonization.Channel}}","page":"API Reference","title":"JAC.DielectronicRecombination.computeAmplitudesProperties","text":"(pathway::DielectronicRecombination.Pathway, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,    settings::DielectronicRecombination.Settings, hasCaptureChannels::Bool,     lastCaptureChannels::Array{AutoIonization.Channel,1})      ... to compute all amplitudes and properties of the given line; a line::DielectronicRecombination.Pathway is returned          for which the amplitudes and properties have now been evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.computeHydrogenicRate-Tuple{Int64, Int64, Int64, Int64, Float64}","page":"API Reference","title":"JAC.DielectronicRecombination.computeHydrogenicRate","text":"DielectronicRecombination.computeHydrogenicRate(ni::Int64, li::Int64, nf::Int64, lf::Int64,  Zeff::Float64)     ... to compute the non-relativistic electric-dipole rate for the transition from shell ni,li –> nf,lf of a         hydrogenic ion with effective charge Zeff. The recursion formulas by Infeld and Hull (1951) are used         together with the absorption oscillator strength. This makes the overall formulation/computation rather         obscure, unfortunately. Uses SpecialFunctions.logfactorial. A rate::Float64 [a.u.] is returned.         This procedure has been worked out by Stefan Schippers (2023).\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.computePassages-Tuple{Multiplet, Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.DielectronicRecombination.EmpiricalTreatment, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.computePassages","text":"DielectronicRecombination.computePassages(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet, initialMultiplet::Multiplet,                                            nm::Nuclear.Model, grid::Radial.Grid, empTreatment::EmpiricalTreatment,                                             settings::DielectronicRecombination.Settings)       ... to compute the data for all resonances (resonance lines) directly from the given multiplets of the initial-, intermediate-          and final states. It also enables one to (successively) include a set of corrections to the resonance strength to incorporate         the contributions of shells that were not considered explicitly.          A list of resonances::Array{DielectronicRecombination.Resonance,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.computePathways-Tuple{Multiplet, Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.computePathways","text":"DielectronicRecombination.computePathways(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet, initialMultiplet::Multiplet,                            nm::Nuclear.Model, grid::Radial.Grid, settings::DielectronicRecombination.Settings; output=true)       ... to compute the dielectronic recombination amplitudes and all properties as requested by the given settings.          A list of pathways::Array{DielectronicRecombination.Pathway,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.computeRateCoefficient-Tuple{JAC.DielectronicRecombination.Resonance, Float64}","page":"API Reference","title":"JAC.DielectronicRecombination.computeRateCoefficient","text":"DielectronicRecombination.computeRateCoefficient(resonance::DielectronicRecombination.Resonance, temp::Float64)       ... computes for a delta-like resonance the DR rate coefficient alpha_d (i, Te) from the given resonance strength         and temperature [K], and for both, Coulomb and Babushkin gauge. All values are directly returned in [cm^3/s].         An alphaDR::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.computeResonances-Tuple{Vector{JAC.DielectronicRecombination.Passage}, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.computeResonances","text":"DielectronicRecombination.computeResonances(passages::Array{DielectronicRecombination.Passage,1},                                               settings::DielectronicRecombination.Settings)       ... to compute the data for all resonances (resonance lines) as defined by the given passages and and settings.          In fact, passages and resonances are treated rather similar to each other in JAC and can be readily         extracted from each other. A list of resonances::Array{DielectronicRecombination.Resonance,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.computeResonances-Tuple{Vector{JAC.DielectronicRecombination.Pathway}, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.computeResonances","text":"(pathways::Array{DielectronicRecombination.Pathway,1}, settings::DielectronicRecombination.Settings)       ... to compute the data for all resonances (resonance lines) as defined by the given pathways and and settings.          A list of resonances::Array{DielectronicRecombination.Resonance,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.determineCaptureChannels-Tuple{Level, Level, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.determineCaptureChannels","text":"DielectronicRecombination.determineCaptureChannels(intermediateLevel::Level, initialLevel::Level,                                                      settings::DielectronicRecombination.Settings)      ... to determine a list of AutoIonization.Channel for a (Auger) capture transitions from the initial to an          intermediate level, and by taking into account the particular settings of for this computation;           an Array{AutoIonization.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.determineEmpiricalTreatment-Tuple{Multiplet, Multiplet, Model, Multiplet, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.determineEmpiricalTreatment","text":"DielectronicRecombination.determineEmpiricalTreatment(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet,                                      nm::Nuclear.Model, initialMultiplet::Multiplet, settings::DielectronicRecombination.Settings)      ... to determine an instance of empiricalTreatment::EmpiricalTreatment that is (internally) applied to simplify         the use of \"corrections\" to the DR strenghts. This data structure summarizes all parameters that help introduce         several empirical corrections. The procedure is simple but slightly sophisticated as we wish to support \"missing\"         parameters in the individual corrections as well as the knowledge that can be derived internally.          The definition of EmpiricalTreatment() can readily be extended as the need arises from the user side.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.determinePassages-Tuple{Multiplet, Multiplet, JAC.DielectronicRecombination.EmpiricalTreatment, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.determinePassages","text":"DielectronicRecombination.determinePassages(intermediateMultiplet::Multiplet, initialMultiplet::Multiplet,                                               empTreatment::EmpiricalTreatment, settings::DielectronicRecombination.Settings)       ... to determine a list of dielectronic-recombination resonances between the levels from the given initial- and intermediate-          states, whereas the final states are considered \"on-fly\"; the particular selections and settings for this computation         are taken into account; an Array{DielectronicRecombination.Passsage,1} is returned. Apart from the level specification,          all physical properties are set to zero during the initialization process.  \n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.determinePathways-Tuple{Multiplet, Multiplet, Multiplet, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.determinePathways","text":"DielectronicRecombination.determinePathways(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet, initialMultiplet::Multiplet,                                               settings::DielectronicRecombination.Settings)       ... to determine a list of dielectronic-recombination pathways between the levels from the given initial-, intermediate- and          final-state multiplets and by taking into account the particular selections and settings for this computation;          an Array{DielectronicRecombination.Pathway,1} is returned. Apart from the level specification, all physical properties          are set to zero during the initialization process.  \n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.determinePhotonChannels-Tuple{Level, Level, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.determinePhotonChannels","text":"DielectronicRecombination.determinePhotonChannels(finalLevel::Level, intermediateLevel::Level,                                                     settings::DielectronicRecombination.Settings)      ... to determine a list of PhotoEmission.Channel for the photon transitions from the intermediate and to a final level, and by          taking into account the particular settings of for this computation;  an Array{PhotoEmission.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.displayPassages-Tuple{IO, Vector{JAC.DielectronicRecombination.Passage}}","page":"API Reference","title":"JAC.DielectronicRecombination.displayPassages","text":"DielectronicRecombination.displayPassages(stream::IO, passages::Array{DielectronicRecombination.Passage,1})       ... to display a list of passages and channels that have been selected due to the prior settings. A neat table of all selected          transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.displayPathways-Tuple{IO, Vector{JAC.DielectronicRecombination.Pathway}}","page":"API Reference","title":"JAC.DielectronicRecombination.displayPathways","text":"DielectronicRecombination.displayPathways(stream::IO, pathways::Array{DielectronicRecombination.Pathway,1})       ... to display a list of pathways and channels that have been selected due to the prior settings. A neat table of all selected          transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.displayRateCoefficients-Tuple{IO, Vector{JAC.DielectronicRecombination.Resonance}, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.displayRateCoefficients","text":"DielectronicRecombination.displayRateCoefficients(stream::IO, resonances::Array{DielectronicRecombination.Resonance,1},                                                    settings::DielectronicRecombination.Settings)       ... to list, if settings.calcRateAlpha, all rate coefficients for the selected temperatures. Both, the individual as well as         the total DR plasma rate coefficients are printed in neat tables, though nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.displayResults-Tuple{IO, Vector{JAC.DielectronicRecombination.Pathway}, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.displayResults","text":"DielectronicRecombination.displayResults(stream::IO, pathways::Array{DielectronicRecombination.Pathway,1},                                           settings::DielectronicRecombination.Settings)       ... to list all results, energies, cross sections, etc. of the selected lines. A neat table is printed but nothing is          returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.displayResults-Tuple{IO, Vector{JAC.DielectronicRecombination.Resonance}, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.displayResults","text":"+ (stream::IO, resonances::Array{DielectronicRecombination.Resonance,1}, settings::DielectronicRecombination.Settings)`  \n... to list all results for the resonances. A neat table is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.extractRateCoefficients-Tuple{Vector{JAC.DielectronicRecombination.Resonance}, JAC.DielectronicRecombination.Settings}","page":"API Reference","title":"JAC.DielectronicRecombination.extractRateCoefficients","text":"DielectronicRecombination.extractRateCoefficients(resonances::Array{DielectronicRecombination.Resonance,1}, settings::DielectronicRecombination.Settings)       ... to extract, if settings.calcRateAlpha, the total DR rate coefficients for all temperatures.          A list of total rate coefficients [cm^3/s] alphaDR::Array{EmProperty,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.DielectronicRecombination.isResonanceToBeExcluded-Tuple{Level, Any, JAC.DielectronicRecombination.ResonanceSelection}","page":"API Reference","title":"JAC.DielectronicRecombination.isResonanceToBeExcluded","text":"DielectronicRecombination.isResonanceToBeExcluded(level::Level, refLevel, rSelection::ResonanceSelection)       returns true, if level is to be excluded from the valid resonances, and false otherwise.     It returns false if the ResonanceSelection() is inactive or if level belongs to the selected resoances.     It is true only of ResonanceSelection() is active but the level does not belong to the selected resonances.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Electron-Impact-Excitation","page":"API Reference","title":"Electron Impact Excitation","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [ImpactExcitation]\nOrder   = [:type, :function]","category":"page"},{"location":"api.html#JAC.ImpactExcitation.Channel","page":"API Reference","title":"JAC.ImpactExcitation.Channel","text":"struct  ImpactExcitation.Channel       ... defines a type for a electron-impact excitaiton channel to help characterize the incoming and outgoing (continuum) states of          many electron-states with a single free electron\n\n+ initialKappa     ::Int64              ... partial-wave of the incoming free electron\n+ finalKappa       ::Int64              ... partial-wave of the outgoing free electron\n+ symmetry         ::LevelSymmetry      ... total angular momentum and parity of the scattering state\n+ initialPhase     ::Float64            ... phase of the incoming partial wave\n+ finalPhase       ::Float64            ... phase of the outgoing partial wave\n+ amplitude        ::Complex{Float64}   ... Collision amplitude associated with the given channel.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.ImpactExcitation.Line","page":"API Reference","title":"JAC.ImpactExcitation.Line","text":"struct  ImpactExcitation.Line       ... defines a type for a electron-impact excitation line that may include the definition of channels and their corresponding                                                                                                                         amplitudes.\n\n+ initialLevel           ::Level         ... initial- (bound-state) level\n+ finalLevel             ::Level         ... final- (bound-state) level\n+ initialElectronEnergy  ::Float64       ... energy of the incoming (initial-state) free-electron\n+ finalElectronEnergy    ::Float64       ... energy of the outgoing (final-state) free-electron\n+ crossSection           ::Float64       ... total cross section of this line\n+ collisionStrength      ::Float64       ... total collision strength of this line\n+ channels               ::Array{ImpactExcitation.Channel,1}  ... List of ImpactExcitation channels of this line.\n+ convergence            ::Float64       ... convergence of calculation\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.ImpactExcitation.Line-Tuple{Level, Level, Float64}","page":"API Reference","title":"JAC.ImpactExcitation.Line","text":"ImpactExcitation.Line(initialLevel::Level, finalLevel::Level, crossSection::Float64)       ... constructor for an electron-impact excitation line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.Line-Tuple{}","page":"API Reference","title":"JAC.ImpactExcitation.Line","text":"ImpactExcitation.Line()  ... 'empty' constructor for an electron-impact excitation line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.RateCoefficients","page":"API Reference","title":"JAC.ImpactExcitation.RateCoefficients","text":"struct  ImpactExcitation.RateCoefficients     ... Defines a type for the output results from excitation rate or                                                     effective collision strengths calculations\n\n+ initialLevel        ::Level               ... initial- (bound-state) level\n+ finalLevel          ::Level               ... final- (bound-state) level\n+ temperatures        ::Array{Float64,1}    ... Temperatures in [K] to calculate excitation rates and effective collision strengths\n+ alphas              ::Array{Float64,1}    ... Excitation rate coefficients in [cm^3/s] for the input temperatures\n+ effOmegas           ::Array{Float64,1}    ... Effective collision strengths for the input temperatures\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.ImpactExcitation.RateCoefficients-Tuple{}","page":"API Reference","title":"JAC.ImpactExcitation.RateCoefficients","text":"ImpactExcitation.RateCoefficients()  ... constructor for the default values of electron-impact excitation rate coefficient or                                             effective collision strength computations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.Settings","page":"API Reference","title":"JAC.ImpactExcitation.Settings","text":"struct  ImpactExcitation.Settings  <:  AbstractProcessSettings  ... defines a type for the details and parameters of computing                                                                                                  electron-impact excitation lines.\n\n+ lineSelection            ::LineSelection      ... Specifies the selected levels, if any.\n+ electronEnergies         ::Array{Float64,1}   ... List of impact-energies of the incoming elecgtrons (in user-defined units).\n+ energyShift              ::Float64            ... An overall energy shift for all transitions |i> --> |f>.\n+ maxKappa                 ::Int64              ... Maximum kappa value of partial waves to be included.\n+ calcRateCoefficient      ::Bool               ... True, if the plasma rate coefficients to be calculated, false otherwise.\n+ maxEnergyMultiplier      ::Float64            ... Maximum initial electron energy for eff. collision strength integration.\n                                 (maxEnergyMultiplier * Excitation threshold energy), after this assymptotic limit is applied.\n+ numElectronEnergies      ::Int64              ... No. of different electron energy points at which collision strengths to compute\n                                                    in electron energy range [0, (maxEnergyMultiplier * Excitation threshold energy)]\n+ temperatures             ::Array{Float64, 1}  ... Electron temperatures [K] for eff. collision strengths and rate coefficients.\n+ printBefore              ::Bool               ... True, if all energies and lines are printed before their evaluation.\n+ operator                 ::AbstractEeInteraction   \n    ... Interaction operator that is to be used for evaluating the e-e interaction amplitudes; allowed values are: \n        CoulombInteraction(), BreitInteraction(), ...\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.ImpactExcitation.Settings-Tuple{JAC.ImpactExcitation.Settings}","page":"API Reference","title":"JAC.ImpactExcitation.Settings","text":"ImpactExcitation.Settings(set::ImpactExcitation.Settings;\n\nlineSelection...,  electronEnergies..., energyShift..., maxKappa...,\ncalcRateCoefficient..., maxEnergyMultiplier..., numElectronEnergies..., temperatures...,\nprintBefore..., operator...)\n\n... constructor for modifying the given ImpactExcitation.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.Settings-Tuple{}","page":"API Reference","title":"JAC.ImpactExcitation.Settings","text":"ImpactExcitation.Settings()  ... constructor for the default values of electron-impact excitation line computations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.amplitude-Tuple{AbstractEeInteraction, JAC.ImpactExcitation.Channel, Level, Level, JAC.Radial.Grid}","page":"API Reference","title":"JAC.ImpactExcitation.amplitude","text":"ImpactExcitation.amplitude(kind::AbstractEeInteraction, channel::ImpactExcitation.Channel, cFinalLevel::Level, cInitialLevel::Level,                              grid::Radial.Grid; printout::Bool=true)       ... to compute the kind in  CoulombInteraction(), BreitInteraction(), CoulombBreit() electron-impact interaction amplitude          <(alphaf Jf, kappaf) Jt || O^(e-e, kind) || (alphai Ji, kappai) Jt>  due to the interelectronic interaction for          the given final and initial (continuum) level. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.computeAmplitudesProperties-Tuple{JAC.ImpactExcitation.Line, Model, JAC.Radial.Grid, JAC.ImpactExcitation.Settings}","page":"API Reference","title":"JAC.ImpactExcitation.computeAmplitudesProperties","text":"ImpactExcitation.computeAmplitudesProperties(line::ImpactExcitation.Line, nm::Nuclear.Model, grid::Radial.Grid,                                                  settings::ImpactExcitation.Settings; printout::Bool=true)       ... to compute all amplitudes and properties of the given line; a line::ImpactExcitation.Line is returned for which      the amplitudes and properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.computeEffStrengths-Tuple{Vector{JAC.ImpactExcitation.Line}, JAC.ImpactExcitation.Settings}","page":"API Reference","title":"JAC.ImpactExcitation.computeEffStrengths","text":"ImpactExcitation.computeEffStrengths(lines::Array{ImpactExcitation.Line, 1}, settings::ImpactExcitation.Settings)     ... computes Effective collision strengths from the calculated line collision strengths at temperature(s) [K].         Returns an Array{ImpactExcitation.RateCoefficients,1}.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.computeLines-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.ImpactExcitation.Settings}","page":"API Reference","title":"JAC.ImpactExcitation.computeLines","text":"ImpactExcitation.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                  settings::ImpactExcitation.Settings; output=true)       ... to compute the electron-impact excitation transition amplitudes and all properties as requested by the given settings.          A list of lines::Array{ImpactExcitation.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.computeRateCoefficients-Tuple{Vector{JAC.ImpactExcitation.Line}, JAC.ImpactExcitation.Settings}","page":"API Reference","title":"JAC.ImpactExcitation.computeRateCoefficients","text":"ImpactExcitation.computeRateCoefficients(effStrengths::Vector{RateCoefficients}, settings::ImpactExcitation.Settings)     ... computes Exitation rate coefficients from the calculated collsion strengths at a temperature(s) [K].         The rate coefficients are returned in [cm^3/s]. Returns an Array{ImpactExcitation.RateCoefficients,1}.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.determineChannels-Tuple{Level, Level, JAC.ImpactExcitation.Settings}","page":"API Reference","title":"JAC.ImpactExcitation.determineChannels","text":"ImpactExcitation.determineChannels(finalLevel::Level, initialLevel::Level, settings::ImpactExcitation.Settings)       ... to determine a list of electron-impact excitation Channels for a transitions from the initial to the final level and by          taking into account the particular settings of for this computation; an Array{ImpactExcitation.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.determineLines-Tuple{Multiplet, Multiplet, JAC.ImpactExcitation.Settings}","page":"API Reference","title":"JAC.ImpactExcitation.determineLines","text":"ImpactExcitation.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::ImpactExcitation.Settings)       ... to determine a list of ImpactExcitation.Line's for transitions between levels from the initial- and final-state multiplets,          and by taking into account the particular selections and settings for this computation; an Array{ImpactExcitation.Line,1} is          returned. Apart from the level specification, all physical properties are set to zero during the initialization process.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.displayLines-Tuple{Vector{JAC.ImpactExcitation.Line}}","page":"API Reference","title":"JAC.ImpactExcitation.displayLines","text":"ImpactExcitation.displayLines(lines::Array{ImpactExcitation.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all          selected transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.displayResults-Tuple{JAC.ImpactExcitation.Line}","page":"API Reference","title":"JAC.ImpactExcitation.displayResults","text":"ImpactExcitation.displayResults(line::ImpactExcitation.Line)     ... to display energies, cross sections, collision stregths, convergence etc. for a single line immediatly after         the calculation for that line is completed.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.displayResults-Tuple{Vector{JAC.ImpactExcitation.Line}}","page":"API Reference","title":"JAC.ImpactExcitation.displayResults","text":"ImpactExcitation.displayResults(lines::Array{ImpactExcitation.Line,1})       ... to list all results, energies, cross sections, etc. of the selected lines. A neat table is printed but nothing is          returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.displayResults-Tuple{Vector{JAC.ImpactExcitation.RateCoefficients}}","page":"API Reference","title":"JAC.ImpactExcitation.displayResults","text":"ImpactExcitation.displayResults(allRates::Array{RateCoefficients,1})       ... to list the excitation rate coefficients and effective collision strengths for the selected lines at the selected temperatures.         A neat table is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.groupLines-Tuple{Vector{JAC.ImpactExcitation.Line}, JAC.ImpactExcitation.Settings}","page":"API Reference","title":"JAC.ImpactExcitation.groupLines","text":"ImpactExcitation.groupLines(lines::Array{ImpactExcitation.Line,1}, settings::ImpactExcitation.Settings)     ... groups lines having the same initial and final level but different energies         returns an Array{Array{ImpactExcitation.Line,1},1}\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.groupLines-Tuple{Vector{JAC.ImpactExcitation.Line}}","page":"API Reference","title":"JAC.ImpactExcitation.groupLines","text":"ImpactExcitation.groupLines(lines::Array{ImpactExcitation.Line,1})     ... groups lines having the same initial and final level but different energies         returns an Array{Array{ImpactExcitation.Line,1},1}\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.interpolateCS-Tuple{Float64, Vector{Float64}, Vector{Float64}, Bool}","page":"API Reference","title":"JAC.ImpactExcitation.interpolateCS","text":"ImpactExcitation.interpolateCS(x::Float64, xa::Vector{Float64}, ya::Vector{Float64}, isE1Allowed::Bool)     ... interpolates the cross section or collision stregths for a given initial electron Energy         if the energy is beyond the upper bound then uses asymptotic approximation for extrapolation,         depending on the transition is E1 allowed or not.         Returns a Float64.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.ImpactExcitation.interpolateCS-Tuple{Float64, Vector{Float64}, Vector{Float64}}","page":"API Reference","title":"JAC.ImpactExcitation.interpolateCS","text":"ImpactExcitation.interpolateCS(x::Float64, xa::Vector{Float64}, ya::Vector{Float64})     ... interpolates the cross section or collision stregths for a given initial electron Energy         returns a Float64.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Photoemission","page":"API Reference","title":"Photoemission","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [PhotoEmission]\nOrder   = [:type, :function]","category":"page"},{"location":"api.html#JAC.PhotoEmission.Channel","page":"API Reference","title":"JAC.PhotoEmission.Channel","text":"struct  PhotoEmission.Channel       ... defines a type for a single radiative emission/absorption channel that specifies the multipole, gauge and amplitude.\n\n+ multipole         ::EmMultipole        ... Multipole of the photon emission/absorption.\n+ gauge             ::EmGauge            ... Gauge for dealing with the (coupled) radiation field.\n+ amplitude         ::Complex{Float64}   ... Amplitude of this multiple channel.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoEmission.Line","page":"API Reference","title":"JAC.PhotoEmission.Line","text":"struct  PhotoEmission.Line       ... defines a type for a radiative line that may include the definition of sublines and their corresponding amplitudes.\n\n+ initialLevel   ::Level               ... initial-(state) level\n+ finalLevel     ::Level               ... final-(state) level\n+ omega          ::Float64             ... Transition frequency of this line; can be shifted w.r.t. the level energies.\n+ photonRate     ::EmProperty          ... Total rate of this line.\n+ angularBeta    ::EmProperty          ... Angular beta_2 coefficient.\n+ hasSublines    ::Bool                ... Determines whether the sublines are defined in terms of their multipolarity, amplitude, or not.\n+ channels       ::Array{PhotoEmission.Channel,1}  ... List of radiative (photon) channels\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoEmission.Line-Tuple{Level, Level, Float64, JAC.Basics.EmProperty}","page":"API Reference","title":"JAC.PhotoEmission.Line","text":"PhotoEmission.Line(initialLevel::Level, finalLevel::Level, photonRate::Float64)       ... constructor an radiative line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.Settings","page":"API Reference","title":"JAC.PhotoEmission.Settings","text":"struct  PhotoEmission.Settings  <:  AbstractProcessSettings       ... defines a type for the details and parameters of computing radiative lines.\n\n+ multipoles              ::Array{EmMultipoles}     ... Specifies the (radiat. field) multipoles to be included.\n+ gauges                  ::Array{UseGauge}         ... Gauges to be included into the computations.\n+ calcAnisotropy          ::Bool                    ... True, if the anisotropy (structure) functions are to be \n                                                        calculated and false otherwise \n+ printBefore             ::Bool                    ... True, if all energies and lines are printed before comput.\n+ corePolarization        ::CorePolarization        ... Parametrization of the core-polarization potential/contribution.\n+ lineSelection           ::LineSelection           ... Specifies the selected levels, if any.\n+ photonEnergyShift       ::Float64                 ... An overall energy shift for all photon energies.\n+ mimimumPhotonEnergy     ::Float64                 ... minimum transition energy for which (photon) transitions \n                                                        are included into the computation.\n+ maximumPhotonEnergy     ::Float64                 ... maximum transition energy for which (photon) transitions \n                                                        are included.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoEmission.Settings-Tuple{JAC.PhotoEmission.Settings}","page":"API Reference","title":"JAC.PhotoEmission.Settings","text":"PhotoEmission.Settings(set::PhotoEmission.Settings;\n\n    multipoles::=..,        gauges=..,                calcAnisotropy=..,          printBefore=..,\n    corePolarization=..,    lineSelection=..,         photonEnergyShift=..,       \n    mimimumPhotonEnergy=.., maximumPhotonEnergy=..) \n                \n... constructor for modifying the given PhotoEmission.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.Settings-Tuple{}","page":"API Reference","title":"JAC.PhotoEmission.Settings","text":"PhotoEmission.Settings()  ... constructor for the default values of radiative line computations\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.amplitude-Tuple{String, CorePolarization, Float64, Level, Level, JAC.Radial.Grid}","page":"API Reference","title":"JAC.PhotoEmission.amplitude","text":"+ (kind::String, cp::CorePolarization, omega::Float64, finalLevel::Level, initialLevel::Level, grid::Radial.Grid;          display::Bool=false, printout::Bool=false)           ... to compute the kind = E1 with core-polarization emission amplitude               <alphaf Jf || O^(E1, emission with core-polarization) || alphai Ji> in length gauge and for the given transition energy.             A value::ComplexF64 is returned. The amplitude value is printed to screen if display=true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.amplitude-Tuple{String, EmMultipole, JAC.Basics.EmGauge, Float64, Level, Level, JAC.Radial.Grid}","page":"API Reference","title":"JAC.PhotoEmission.amplitude","text":"PhotoEmission.amplitude(kind::String, Mp::EmMultipole, gauge::EmGauge, omega::Float64, finalLevel::Level, initialLevel::Level,                              grid::Radial.Grid; display::Bool=false, printout::Bool=false)       ... to compute the kind = (absorption or emission) amplitude  <alphaf Jf || O^(Mp, kind) || alphai Ji> for the          interaction with  photon of multipolarity Mp and for the given transition energy and gauge. A value::ComplexF64 is          returned. The amplitude value is printed to screen if display=true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.computeAmplitudesProperties-Tuple{JAC.PhotoEmission.Line, JAC.Radial.Grid, JAC.PhotoEmission.Settings}","page":"API Reference","title":"JAC.PhotoEmission.computeAmplitudesProperties","text":"PhotoEmission.computeAmplitudesProperties(line::PhotoEmission.Line, grid::Radial.Grid, settings::Einstein.Settings; printout::Bool=true)       ... to compute all amplitudes and properties of the given line; a line::Einstein.Line is returned for which the amplitudes and          properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.computeLines-Tuple{Multiplet, Multiplet, JAC.Radial.Grid, JAC.PhotoEmission.Settings}","page":"API Reference","title":"JAC.PhotoEmission.computeLines","text":"PhotoEmission.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, grid::Radial.Grid, settings::PhotoEmission.Settings;                              output=true)       ... to compute the radiative transition amplitudes and all properties as requested by the given settings. A list of          lines::Array{PhotoEmission.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.computeLinesCascade-Tuple{Multiplet, Multiplet, JAC.Radial.Grid, JAC.PhotoEmission.Settings}","page":"API Reference","title":"JAC.PhotoEmission.computeLinesCascade","text":"PhotoEmission.computeLinesCascade(finalMultiplet::Multiplet, initialMultiplet::Multiplet, grid::Radial.Grid,                                      settings::PhotoEmission.Settings; output::Bool=true, printout::Bool=true)       ... to compute the radiative transition amplitudes and all properties as requested by the given settings. The computations         and printout is adapted for larger cascade computations by including only lines with at least one channel and by sending         all printout to a summary file only. A list of lines::Array{PhotoEmission.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.determineChannels-Tuple{Level, Level, JAC.PhotoEmission.Settings}","page":"API Reference","title":"JAC.PhotoEmission.determineChannels","text":"PhotoEmission.determineChannels(finalLevel::Level, initialLevel::Level, settings::PhotoEmission.Settings)       ... to determine a list of PhotoEmission.Channel for a transitions from the initial to final level and by taking into          account the particular settings of for this computation; an Array{PhotoEmission.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.determineLines-Tuple{Multiplet, Multiplet, JAC.PhotoEmission.Settings}","page":"API Reference","title":"JAC.PhotoEmission.determineLines","text":"PhotoEmission.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::PhotoEmission.Settings)       ... to determine a list of PhotoEmission Line's for transitions between the levels from the given initial- and          final-state multiplets and by taking into account the particular selections and settings for this computation;          an Array{PhotoEmission.Line,1} is returned. Apart from the level specification, all physical properties are set          to zero during the initialization process.  \n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.displayAnisotropies-Tuple{IO, Vector{JAC.PhotoEmission.Line}, JAC.PhotoEmission.Settings}","page":"API Reference","title":"JAC.PhotoEmission.displayAnisotropies","text":"PhotoEmission.displayAnisotropies(stream::IO, lines::Array{PhotoEmission.Line,1}, settings::PhotoEmission.Settings)       ... to list all energies and anisotropy parameters of the selected lines. A neat table is printed but nothing is          returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.displayLifetimes-Tuple{IO, Vector{JAC.PhotoEmission.Line}, JAC.PhotoEmission.Settings}","page":"API Reference","title":"JAC.PhotoEmission.displayLifetimes","text":"PhotoEmission.displayLifetimes(stream::IO, lines::Array{PhotoEmission.Line,1}, settings::PhotoEmission.Settings)       ... to list all lifetimes as derived from the selected lines. A neat table is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.displayLines-Tuple{IO, Vector{JAC.PhotoEmission.Line}}","page":"API Reference","title":"JAC.PhotoEmission.displayLines","text":"PhotoEmission.displayLines(stream::IO, lines::Array{PhotoEmission.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all          selected transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoEmission.displayRates-Tuple{IO, Vector{JAC.PhotoEmission.Line}, JAC.PhotoEmission.Settings}","page":"API Reference","title":"JAC.PhotoEmission.displayRates","text":"PhotoEmission.displayRates(stream::IO, lines::Array{PhotoEmission.Line,1}, settings::PhotoEmission.Settings)       ... to list all results, energies, rates, etc. of the selected lines. A neat table is printed but nothing is          returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Photoexcitation","page":"API Reference","title":"Photoexcitation","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [PhotoExcitation]\nOrder   = [:type, :function]","category":"page"},{"location":"api.html#JAC.PhotoExcitation.Line","page":"API Reference","title":"JAC.PhotoExcitation.Line","text":"struct  PhotoExcitation.Line       ... defines a type for a photo-excitation line that may include the definition of sublines and their          corresponding amplitudes.\n\n+ initialLevel   ::Level                       ... initial-(state) level\n+ finalLevel     ::Level                       ... final-(state) level\n+ omega          ::Float64                     ... Transition frequency of this line; can be shifted w.r.t. the level energies.\n+ oscStrength    ::EmProperty                  ... Absorption oscillator strength\n+ crossSection   ::EmProperty                  ... Total cross section of this line.\n+ staTensor      ::Array{TensorComp,1}         ... Array of statistical tensor components rho_kq\n+ hasSublines    ::Bool                        ... Determines whether the individual sublines are defined in terms of their \n                                                    multipolarity, amplitude, or not; cf. PhotoEmission.Channel\n+ channels       ::Array{PhotoEmission.Channel,1}  ... List of radiative (photon) channels\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoExcitation.Line-Tuple{Level, Level, Float64, JAC.Basics.EmProperty}","page":"API Reference","title":"JAC.PhotoExcitation.Line","text":"PhotoExcitation.Line(initialLevel::Level, finalLevel::Level, omega::Float64, crossSection::EmProperty)       ... constructor an photo-excitation line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.Settings","page":"API Reference","title":"JAC.PhotoExcitation.Settings","text":"struct  PhotoExcitation.Settings  <:  AbstractProcessSettings  ... defines a type for the details and parameters of computing photo-excitation  lines.\n\n+ multipoles              ::Array{EmMultipole,1}    ... Specifies the multipoles of the radiation field that are to be included.\n+ gauges                  ::Array{UseGauge,1}       ... Specifies the gauges to be included into the computations.\n+ calcForStokes           ::Bool                    ... True, if the excitation cross sections are to be calculated (and false otherwise)\n                                                        for given Stokes parameter of the incident plane-wave photons.\n+ calcPhotonDm            ::Bool                    ... True, if the photon density matrix of a subsequently emitted fluorescence photon \n                                                        is to be calculated and false otherwise. \n+ calcTensors             ::Bool                    ... True, if statistical tensors of the excited atom are to be calculated, false otherwise. \n+ printBefore             ::Bool                    ... True, if all energies and lines are printed before their evaluation.\n+ lineSelection           ::LineSelection           ... Specifies the selected levels, if any.\n+ photonEnergyShift       ::Float64                 ... An overall energy shift for all photon energies.\n+ mimimumPhotonEnergy     ::Float64                 ... minimum transition energy for which (photon) transitions are included into the\n                                                        computation.\n+ maximumPhotonEnergy     ::Float64                 ... maximum transition energy for which (photon) transitions are included.\n+ stokes                  ::ExpStokes               ... Stokes parameters of the incident radiation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoExcitation.Settings-Tuple{JAC.PhotoExcitation.Settings}","page":"API Reference","title":"JAC.PhotoExcitation.Settings","text":"PhotoExcitation.Settings(set::PhotoExcitation.Settings;\n\n    multipoles=..,          gauges=..,                  calcForStokes=..,           calcPhotonDm=..,    \n    calcTensors=..,         printBefore=..,             lineSelection=..,    \n    photonEnergyShift=..,   mimimumPhotonEnergy=..,     maximumPhotonEnergy=..,     stokes=..)\n                \n... constructor for modifying the given PhotoExcitation.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.Settings-Tuple{}","page":"API Reference","title":"JAC.PhotoExcitation.Settings","text":"PhotoExcitation.Settings()  ... 'empty' constructor for the default values of photo-excitation line computations\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.computeAmplitudesProperties-Tuple{JAC.PhotoExcitation.Line, JAC.Radial.Grid, JAC.PhotoExcitation.Settings}","page":"API Reference","title":"JAC.PhotoExcitation.computeAmplitudesProperties","text":"PhotoExcitation.computeAmplitudesProperties(line::PhotoExcitation.Line, grid::Radial.Grid, settings::PhotoExcitation.Settings; printout::Bool=true)       ... to compute all amplitudes and properties of the given line; a line::PhotoExcitation.Line is returned for which          the amplitudes and properties have now been evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.computeCrossSection-Tuple{JAC.PhotoExcitation.Line, ExpStokes}","page":"API Reference","title":"JAC.PhotoExcitation.computeCrossSection","text":"PhotoExcitation.computeCrossSection(line::PhotoExcitation.Line, stokes::ExpStokes)       ... to compute the excitation cross section for the excitation of unpolarized atoms by plane-wave photons, whose polarization          is described by the given (experimental) Stokes parameters. A cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.computeLines-Tuple{Multiplet, Multiplet, JAC.Radial.Grid, JAC.PhotoExcitation.Settings}","page":"API Reference","title":"JAC.PhotoExcitation.computeLines","text":"PhotoExcitation.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, grid::Radial.Grid,                                      settings::PhotoExcitation.Settings; output=true)       ... to compute the photo-excitation amplitudes and all properties as requested by the given settings. A list          of lines::Array{PhotoExcitation.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.computeLinesCascade-Tuple{Multiplet, Multiplet, JAC.Radial.Grid, JAC.PhotoExcitation.Settings, LevelSelection}","page":"API Reference","title":"JAC.PhotoExcitation.computeLinesCascade","text":"PhotoExcitation.computeLinesCascade(finalMultiplet::Multiplet, initialMultiplet::Multiplet, grid::Radial.Grid,                                       settings::PhotoExcitation.Settings, initialLevelSelection::LevelSelection;                                       output::Bool=true, printout::Bool=true)       ... to compute the excitation (absorption) transition amplitudes and all properties as requested by the given settings.          The computations and printout is adapted for larger cascade computations by including only lines with at least one channel          and by sending all printout to a summary file only. A list of lines::Array{PhotoExcitation.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.computeStatisticalTensor-Tuple{Int64, Int64, JAC.PhotoExcitation.Line, ExpStokes}","page":"API Reference","title":"JAC.PhotoExcitation.computeStatisticalTensor","text":"PhotoExcitation.computeStatisticalTensor(k::Int64, q::Int64, line::PhotoExcitation.Line, stokes::ExpStokes)       ... to compute the statistical tensor (component) rho{k,q} of the final level for the excitation of unpolarized atoms by          plane-wave photons, whose polarization is described by the given (experimental) Stokes parameters.          A rhokq::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.determineChannels-Tuple{Level, Level, JAC.PhotoExcitation.Settings}","page":"API Reference","title":"JAC.PhotoExcitation.determineChannels","text":"PhotoExcitation.determineChannels(finalLevel::Level, initialLevel::Level, settings::PhotoExcitation.Settings)       ... to determine a list of PhotoExcitation.Channel for a transitions from the initial to final level and by taking          into account the particular settings of for this computation; an Array{PhotoExcitation.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.determineLines-Tuple{Multiplet, Multiplet, JAC.PhotoExcitation.Settings}","page":"API Reference","title":"JAC.PhotoExcitation.determineLines","text":"PhotoExcitation.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::PhotoExcitation.Settings)       ... to determine a list of photo-excitation Line's for transitions between the levels from the given initial- and          final-state multiplets and by taking into account the particular selections and settings for this computation;          an Array{PhotoExcitation.Line,1} is returned. Apart from the level specification, all physical properties are set to          zero during the initialization process.  \n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.displayCrossSections-Tuple{IO, Vector{JAC.PhotoExcitation.Line}, JAC.PhotoExcitation.Settings}","page":"API Reference","title":"JAC.PhotoExcitation.displayCrossSections","text":"PhotoExcitation.displayCrossSections(stream::IO, lines::Array{PhotoExcitation.Line,1}, settings::PhotoExcitation.Settings)       ... to list all results, energies, cross sections, etc. of the selected lines. A neat table is printed but nothing          is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.displayLineData-Tuple{IO, Vector{JAC.PhotoExcitation.Line}}","page":"API Reference","title":"JAC.PhotoExcitation.displayLineData","text":"PhotoExcitation.displayLineData(stream::IO, lines::Array{PhotoExcitation.Line,1})       ... to display the calculated data, ordered by the initial levels and the photon energies involved.         Neat tables of all initial levels and photon energies as well as all associated total cross sections are printed         but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.displayLines-Tuple{IO, Vector{JAC.PhotoExcitation.Line}}","page":"API Reference","title":"JAC.PhotoExcitation.displayLines","text":"PhotoExcitation.displayLines(stream::IO, lines::Array{PhotoExcitation.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all          selected transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoExcitation.estimateCrossSection-Tuple{Vector{JAC.PhotoExcitation.Line}, Float64, Float64, Any}","page":"API Reference","title":"JAC.PhotoExcitation.estimateCrossSection","text":"PhotoExcitation.estimateCrossSection(lines::Array{PhotoExcitation.Line,1}, omega::Float64, gamma::Float64, initialLevel)       ... to estimate from lines the total PE cross section for any omega and for initial level.          The procedure assumes a Gaussian line shape for each PhotoExcitation.Line with widths gamma and distributes         the (total cross section according to the line shape within [Er - 10*gamma, Er + 10*gamma].         Other line shapes can be readily implemented; a cross section cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Photoionization","page":"API Reference","title":"Photoionization","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [PhotoIonization]\nOrder   = [:type, :function]","category":"page"},{"location":"api.html#JAC.PhotoIonization.Channel","page":"API Reference","title":"JAC.PhotoIonization.Channel","text":"struct  PhotoIonization.Channel       ... defines a type for a photoionization channel to help characterize a single multipole and scattering (continuum) state          of many electron-states with a single free electron.\n\n+ multipole      ::EmMultipole          ... Multipole of the photon absorption.\n+ gauge          ::EmGauge              ... Gauge for dealing with the (coupled) radiation field.\n+ kappa          ::Int64                ... partial-wave of the free electron\n+ symmetry       ::LevelSymmetry        ... total angular momentum and parity of the scattering state\n+ phase          ::Float64              ... phase of the partial wave\n+ amplitude      ::Complex{Float64}     ... Photoionization amplitude associated with the given channel.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoIonization.Line","page":"API Reference","title":"JAC.PhotoIonization.Line","text":"struct  Line  ... defines a type for a photoionization line that may include the definition of channels.\n\n+ initialLevel   ::Level                  ... initial-(state) level\n+ finalLevel     ::Level                  ... final-(state) level\n+ electronEnergy ::Float64                ... Energy of the (outgoing free) electron.\n+ photonEnergy   ::Float64                ... Energy of the absorbed photon.\n+ crossSection   ::EmProperty             ... Cross section for this photoionization.\n+ angularBeta    ::EmProperty             ... beta -parameter for unpolarized targets with J=0, 1/2, 1\n+ coherentDelay  ::EmProperty             ... coherent time-delay due to the selected averaging of phases.\n+ incoherentDelay::EmProperty             ... incoherent time-delay due to the selected averaging of phases.\n+ channels       ::Array{PhotoIonization.Channel,1}  ... List of PhotoIonization.Channels of this line.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoIonization.Line-Tuple{Level, Level, JAC.Basics.EmProperty}","page":"API Reference","title":"JAC.PhotoIonization.Line","text":"PhotoIonization.Line(initialLevel::Level, finalLevel::Level, crossSection::Float64)       ... constructor for an photoionization line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.PlasmaSettings","page":"API Reference","title":"JAC.PhotoIonization.PlasmaSettings","text":"struct  PhotoIonization.PlasmaSettings  <:  Basics.AbstractLineShiftSettings       ... defines a type for the details and parameters of computing photoionization rates with plasma interactions.\n\n+ multipoles             ::Array{Basics.EmMultipole}     ... Specifies the multipoles of the radiation field that are to be included.\n+ gauges                 ::Array{Basics.UseGauge}        ... Specifies the gauges to be included into the computations.\n+ photonEnergies         ::Array{Float64,1}              ... List of photon energies.  \n+ printBefore            ::Bool                          ... True, if all energies and lines are printed before their evaluation.\n+ lineSelection          ::LineSelection                 ... Specifies the selected levels, if any.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoIonization.PlasmaSettings-Tuple{}","page":"API Reference","title":"JAC.PhotoIonization.PlasmaSettings","text":"PhotoIonization.PlasmaSettings()  ... constructor for a standard instance of PhotoIonization.PlasmaSettings.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.Settings","page":"API Reference","title":"JAC.PhotoIonization.Settings","text":"struct  PhotoIonization.Settings  <:  AbstractProcessSettings  ... defines a type for the details and parameters of computing photoionization lines.\n\n+ multipoles                    ::Array{EmMultipole}  ... Specifies the multipoles of the radiation field that are to be included.\n+ gauges                        ::Array{UseGauge}     ... Specifies the gauges to be included into the computations.\n+ photonEnergies                ::Array{Float64,1}    ... List of photon energies [in user-selected units].  \n+ electronEnergies              ::Array{Float64,1}    ... List of electron energies; usually only one of these lists are utilized. \n+ thetas                        ::Array{Float64,1}    ... List of theta-values if angle-differential CS are calculated explicitly. \n+ calcAnisotropy                ::Bool                ... True, if the beta anisotropy parameters are to be calculated and false otherwise (o/w). \n+ calcPartialCs                 ::Bool                ... True, if partial cross sections are to be calculated and false otherwise.  \n+ calcTimeDelay                 ::Bool                ... True, if time-delays are to be calculated and false otherwise.  \n+ calcNonE1AngleDifferentialCS  ::Bool                ... True, if non-E1 angle-differential CS are be calculated and false otherwise.  \n+ calcTensors                   ::Bool                ... True, if statistical tensors of the excited atom are to be calculated and false o/w. \n+ printBefore                   ::Bool                ... True, if all energies and lines are printed before their evaluation.\n+ lineSelection                 ::LineSelection       ... Specifies the selected levels, if any.\n+ stokes                        ::ExpStokes           ... Stokes parameters of the incident radiation.\n+ freeElectronShift             ::Float64             ... An overall energy shift of all free-electron energies [user-specified units].\n+ lValues                       ::Array{Int64,1}      ... Orbital angular momentum of free-electrons, for which partial waves are considered.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoIonization.Settings-Tuple{JAC.PhotoIonization.Settings}","page":"API Reference","title":"JAC.PhotoIonization.Settings","text":"PhotoIonization.Settings(set::PhotoIonization.Settings;\n\n    multipoles=..,                      gauges=..,                  photonEnergies=..,          electronEnergies=..,     \n    thetas=..,                          calcAnisotropy=..,          calcPartialCs..,            calcTimeDelay=..,           \n    calcNonE1AngleDifferentialCS=..,    calcTensors=..,             printBefore=..,             lineSelection=..,           \n    stokes=..,                          freeElectronShift=..,       lValues=.. )\n                \n... constructor for modifying the given PhotoIonization.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.Settings-Tuple{}","page":"API Reference","title":"JAC.PhotoIonization.Settings","text":"PhotoIonization.Settings()  ... constructor for the default values of photoionization line computations\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.amplitude-Tuple{String, JAC.PhotoIonization.Channel, Float64, Level, Level, JAC.Radial.Grid}","page":"API Reference","title":"JAC.PhotoIonization.amplitude","text":"PhotoIonization.amplitude(kind::String, channel::PhotoIonization.Channel, omega::Float64, continuumLevel::Level,                                  initialLevel::Level, grid::Radial.Grid)       ... to compute the kind = (photoionization) amplitude  <(alphaf Jf, epsilon kappa) Jt || O^(photoionization) || alphai J_i>           due to the electron-photon interaction for the given final and initial level, the partial wave of the outgoing          electron as well as the given multipole and gauge. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.angularFunctionK-Tuple{Int64, Int64, Int64, AngularJ64, AngularJ64, Int64, AngularJ64, Int64, AngularJ64}","page":"API Reference","title":"JAC.PhotoIonization.angularFunctionK","text":"PhotoIonization.angularFunctionK(L1::Int64, L2::Int64, X::Int64, Ji::AngularJ64, Jf::AngularJ64,                                    kappa1::Int64, J1::AngularJ64, kappa2::Int64, J2::AngularJ64)       ... to compute angular function K(...) as defined for the non-E1 angle-differential cross sections by         Nishita Hosea (2025). No tests are made that the triangular conditions of the quantum numbers         are fulfilled. A wa::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.angularFunctionW-Tuple{Float64, Int64, Int64, Int64, Int64, Int64, Int64, Rational{Int64}, Int64, Rational{Int64}}","page":"API Reference","title":"JAC.PhotoIonization.angularFunctionW","text":"PhotoIonization.angularFunctionW(theta::Float64, L1::Int64, L2::Int64, X::Int64, lambda1::Int64, lambda2::Int64,                                   kappa1::Int64, mu1::Rational{Int64}, kappa2::Int64, mu2::Rational{Int64})       ... to compute angular function W(theta; ...) as defined for the non-E1 angle-differential cross sections by         Nishita Hosea (2025). No tests are made that the triangular conditions of the quantum numbers         are fulfilled. A  wa::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.computeAmplitudesProperties-Tuple{JAC.PhotoIonization.Line, Model, JAC.Radial.Grid, Int64, JAC.PhotoIonization.Settings}","page":"API Reference","title":"JAC.PhotoIonization.computeAmplitudesProperties","text":"PhotoIonization.computeAmplitudesProperties(line::PhotoIonization.Line, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,                                                      settings::PhotoIonization.Settings; printout::Bool=false)       ... to compute all amplitudes and properties of the given line; a line::PhotoIonization.Line is returned for which the amplitudes and          properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.computeAmplitudesPropertiesPlasma-Tuple{JAC.PhotoIonization.Line, Model, JAC.Radial.Grid, JAC.PhotoIonization.PlasmaSettings}","page":"API Reference","title":"JAC.PhotoIonization.computeAmplitudesPropertiesPlasma","text":"PhotoIonization.computeAmplitudesPropertiesPlasma(line::PhotoIonization.Line, nm::Nuclear.Model, grid::Radial.Grid,                                                     settings::PhotoIonization.PlasmaSettings)       ... to compute all amplitudes and properties of the given line but for the given plasma model;          a line::PhotoIonization.Line is returned for which the amplitudes and properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.computeAngularBeta-Tuple{Level, Level, Vector{JAC.PhotoIonization.Channel}}","page":"API Reference","title":"JAC.PhotoIonization.computeAngularBeta","text":"PhotoIonization.computeAngularBeta(iLevel::Level, fLevel::Level, channels::Array{PhotoIonization.Channel,1})       ... to compute the beta anisotropy parameter for the photoionization transition i -> f with the given channels;         here, the formula from Balashov (1994, Eq. 2.135) has been utilized. A beta::EmProperty parameter is returned.         These (gauge-dependent) beta parameters are set to -9., if no amplitudes are calculated for the given gauge.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.computeDisplayNonE1AngleDifferentialCS-Tuple{IO, Vector{JAC.PhotoIonization.Line}, JAC.PhotoIonization.Settings}","page":"API Reference","title":"JAC.PhotoIonization.computeDisplayNonE1AngleDifferentialCS","text":"PhotoIonization.computeDisplayNonE1AngleDifferentialCS(stream::IO, lines::Array{PhotoIonization.Line,1},                                                          settings::PhotoIonization.Settings)       ... to compute & display the non-E1 angle-differential photoionization cross sections for all PhotoIonization.Line's          and at all angles theta as defined in the settings. The general formula by Nishita Hosea (2025) is applied here.         A neat table is printed for each line but nothing is returned otherwise. \n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.computeLines-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.PhotoIonization.Settings}","page":"API Reference","title":"JAC.PhotoIonization.computeLines","text":"PhotoIonization.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                      settings::PhotoIonization.Settings; output::Bool=true)       ... to compute the photoIonization transition amplitudes and all properties as requested by the given settings.          A list of lines::Array{PhotoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.computeLinesCascade-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.PhotoIonization.Settings, LevelSelection}","page":"API Reference","title":"JAC.PhotoIonization.computeLinesCascade","text":"PhotoIonization.computeLinesCascade(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                       settings::PhotoIonization.Settings, initialLevelSelection::LevelSelection;                                       output=true, printout::Bool=true)       ... to compute the photoionization transition amplitudes and all properties as requested by the given settings. The computations         and printout is adapted for large cascade computations by including only lines with at least one channel and by sending         all printout to a summary file only. A list of lines::Array{PhotoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.computeLinesPlasma-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.PhotoIonization.PlasmaSettings}","page":"API Reference","title":"JAC.PhotoIonization.computeLinesPlasma","text":"PhotoIonization.computeLinesPlasma(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                      settings::PhotoIonization.PlasmaSettings; output::Bool=true)       ... to compute the photoIonization transition amplitudes and all properties as requested by the given settings.          A list of lines::Array{PhotoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.computePartialCrossSectionUnpolarized-Tuple{JAC.Basics.EmGauge, AngularM64, JAC.PhotoIonization.Line}","page":"API Reference","title":"JAC.PhotoIonization.computePartialCrossSectionUnpolarized","text":"PhotoIonization.computePartialCrossSectionUnpolarized(gauge::EmGauge, Mf::AngularM64, line::PhotoIonization.Line)       ... to compute the partial photoionization cross section for initially unpolarized atoms by unpolarized plane-wave photons.         A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.computeStatisticalTensorUnpolarized-Tuple{Int64, Int64, JAC.Basics.EmGauge, JAC.PhotoIonization.Line, JAC.PhotoIonization.Settings}","page":"API Reference","title":"JAC.PhotoIonization.computeStatisticalTensorUnpolarized","text":"PhotoIonization.computeStatisticalTensorUnpolarized(k::Int64, q::Int64, gauge::EmGauge, line::PhotoIonization.Line,                                                              settings::PhotoIonization.Settings)       ... to compute the statistical tensor of the photoion in its final level after the photoionization of initially unpolarized atoms          by plane-wave photons with given Stokes parameters (density matrix). A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.computeTimeDelays-Tuple{Vector{JAC.PhotoIonization.Channel}, Vector{JAC.PhotoIonization.Channel}, Float64, AngularJ64}","page":"API Reference","title":"JAC.PhotoIonization.computeTimeDelays","text":"PhotoIonization.computeTimeDelays(channels::Array{PhotoIonization.Channel,1}, xchannels::Array{PhotoIonization.Channel,1},                                      deltaE::Float64, Jf::AngularJ64)       ... to compute the – coherent and incoherent – time delay from the channels as calculated for two neighboured photon          energies (deltaE = xE - E). Two tuple of two time delays (coherentDelay::EmProperty, incoherentDelay::EmProperty)         is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.determineChannels-Tuple{Level, Level, JAC.PhotoIonization.Settings}","page":"API Reference","title":"JAC.PhotoIonization.determineChannels","text":"PhotoIonization.determineChannels(finalLevel::Level, initialLevel::Level, settings::PhotoIonization.Settings)       ... to determine a list of photoionization Channel for a transitions from the initial to final level and by taking into account          the particular settings of for this computation; an Array{PhotoIonization.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.determineLines-Tuple{Multiplet, Multiplet, JAC.PhotoIonization.Settings}","page":"API Reference","title":"JAC.PhotoIonization.determineLines","text":"PhotoIonization.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::PhotoIonization.Settings)       ... to determine a list of PhotoIonization.Line's for transitions between levels from the initial- and final-state multiplets,          and  by taking into account the particular selections and settings for this computation; an Array{PhotoIonization.Line,1}          is returned. Apart from the level specification, all physical properties are set to zero during the initialization process.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.displayLineData-Tuple{IO, Vector{JAC.PhotoIonization.Line}}","page":"API Reference","title":"JAC.PhotoIonization.displayLineData","text":"PhotoIonization.displayLineData(stream::IO, lines::Array{PhotoIonization.Line,1})       ... to display the calculated data, ordered by the initial levels and the photon energies involved.         Neat tables of all initial levels and photon energies as well as all associated cross sections are printed         but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.displayLines-Tuple{IO, Vector{JAC.PhotoIonization.Line}}","page":"API Reference","title":"JAC.PhotoIonization.displayLines","text":"PhotoIonization.displayLines(stream::IO, lines::Array{PhotoIonization.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all selected          transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.displayPhases-Tuple{Vector{JAC.PhotoIonization.Line}}","page":"API Reference","title":"JAC.PhotoIonization.displayPhases","text":"PhotoIonization.displayPhases(lines::Array{PhotoIonization.Line,1})       ... to display a list of lines, channels and phases of the continuum wave that have been selected due to the prior settings.         A neat table of all selected transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.displayResults-Tuple{IO, Vector{JAC.PhotoIonization.Line}, JAC.PhotoIonization.Settings}","page":"API Reference","title":"JAC.PhotoIonization.displayResults","text":"PhotoIonization.displayResults(stream::IO, lines::Array{PhotoIonization.Line,1}, settings::PhotoIonization.Settings)       ... to list all results, energies, cross sections, etc. of the selected lines. A neat table is printed but nothing          is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.extractCrossSection-Tuple{Vector{JAC.PhotoIonization.Line}, Float64, Any}","page":"API Reference","title":"JAC.PhotoIonization.extractCrossSection","text":"PhotoIonization.extractCrossSection(lines::Array{PhotoIonization.Line,1}, omega::Float64, initialLevel)       ... to extract from lines the total PI cross section that refer to the given omega and initial level;         a cross section cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.extractCrossSection-Tuple{Vector{JAC.PhotoIonization.Line}, Float64, Shell, Any}","page":"API Reference","title":"JAC.PhotoIonization.extractCrossSection","text":"PhotoIonization.extractCrossSection(lines::Array{PhotoIonization.Line,1}, omega::Float64, shell::Shell, initialLevel)       ... to extract from lines the total PI cross section that refer to the given omega and initial level and to          to the ionization of an electron from shell; a cross section cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.extractLines-Tuple{Vector{JAC.PhotoIonization.Line}, Float64}","page":"API Reference","title":"JAC.PhotoIonization.extractLines","text":"PhotoIonization.extractLines(lines::Array{PhotoIonization.Line,1}, omega::Float64)       ... to extract from lines all those that refer to the given omega;         a reduced list rLines::Array{PhotoIonization.Line,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.extractPhotonEnergies-Tuple{Vector{JAC.PhotoIonization.Line}}","page":"API Reference","title":"JAC.PhotoIonization.extractPhotonEnergies","text":"PhotoIonization.extractPhotonEnergies(lines::Array{PhotoIonization.Line,1})       ... to extract all photon energies for which photoionization data and cross sections are provided by lines;         an list of energies::Array{Float64,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.getLineKappas-Tuple{JAC.PhotoIonization.Line}","page":"API Reference","title":"JAC.PhotoIonization.getLineKappas","text":"PhotoIonization.getLineKappas(line::PhotoIonization.Line)       ... returns a list of kappa-values (partial waves) which contribute to the given line, to which one or several channels are          assigned. An kappaList::Array{Int64,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoIonization.interpolateCrossSection-Tuple{Vector{JAC.PhotoIonization.Line}, Float64, Any}","page":"API Reference","title":"JAC.PhotoIonization.interpolateCrossSection","text":"PhotoIonization.interpolateCrossSection(lines::Array{PhotoIonization.Line,1}, omega::Float64, initialLevel)       ... to interpolate (or extrapolate) from lines the total PI cross section for any given omega and          initial level. The procedure applies a linear interpolation/extrapolation by just using the          cross sections from the two nearest (given) omega points; a cross section cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Photorecombination","page":"API Reference","title":"Photorecombination","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [PhotoRecombination]\nOrder   = [:type, :function]","category":"page"},{"location":"api.html#JAC.PhotoRecombination.Channel","page":"API Reference","title":"JAC.PhotoRecombination.Channel","text":"struct  PhotoRecombination.Channel       ... defines a type for a photorecombination channel to help characterize a single multipole and scattering          (continuum) state of many electron-states with a single free electron.\n\n+ multipole      ::EmMultipole          ... Multipole of the photon emission/absorption.\n+ gauge          ::EmGauge              ... Gauge for dealing with the (coupled) radiation field.\n+ kappa          ::Int64                ... partial-wave of the free electron\n+ symmetry       ::LevelSymmetry        ... total angular momentum and parity of the scattering state\n+ phase          ::Float64              ... phase of the partial wave\n+ amplitude      ::Complex{Float64}     ... Rec amplitude associated with the given channel.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoRecombination.Line","page":"API Reference","title":"JAC.PhotoRecombination.Line","text":"struct  PhotoRecombination.Line       ... defines a type for a Photorecombination line that may include the definition of channels.\n\n+ initialLevel   ::Level                  ... initial-(state) level\n+ finalLevel     ::Level                  ... final-(state) level\n+ electronEnergy ::Float64                ... Energy of the (incoming free) electron.\n+ photonEnergy   ::Float64                ... Energy of the emitted photon.\n+ betaGamma2     ::Float64                ... beta^2 * gamma^2.\n+ weight         ::Float64                ... weight of line in the integration over electron energies.\n+ crossSection   ::EmProperty             ... Cross section for this electron capture.\n+ channels       ::Array{PhotoRecombination.Channel,1}    ... List of photorecombination channels of this line.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoRecombination.Line-Tuple{Level, Level}","page":"API Reference","title":"JAC.PhotoRecombination.Line","text":"PhotoRecombination.Line()       ... constructor for an empty instance of a photorecombination line between a specified initial          and final level.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.Settings","page":"API Reference","title":"JAC.PhotoRecombination.Settings","text":"struct  PhotoRecombination.Settings  <:  AbstractProcessSettings ... defines a type for the details and parameters of computing photo recombination lines.\n\n+ multipoles          ::Array{EmMultipole}  ... Multipoles of the radiation field that are to be included.\n+ gauges              ::Array{UseGauge}     ... Gauges to be included into the computations.\n+ electronEnergies    ::Array{Float64,1}    ... List of electron energies [in default units].\n+ ionEnergies         ::Array{Float64,1}    ... List of ion energies [in MeV/u].\n+ useIonEnergies      ::Bool                ... Make use of ion energies in [MeV/u] to obtain the electron energies.\n+ calcTotalCs         ::Bool                ... True, if the total cross sections is to be calculated/displayed for all initial levels.\n+ calcAnisotropy      ::Bool                ... True, if the overall anisotropy is to be calculated.\n+ calcTensors         ::Bool                ... True, if the statistical tensors are to be calculated and \n                                                false otherwise.\n+ printBefore         ::Bool                ... True, if all energies and lines are printed before their evaluation.\n+ maxKappa            ::Int64               ... Maximum kappa value of partial waves to be included.\n+ lineSelection       ::LineSelection       ... Specifies the selected levels, if any.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JAC.PhotoRecombination.Settings-Tuple{JAC.PhotoRecombination.Settings}","page":"API Reference","title":"JAC.PhotoRecombination.Settings","text":"PhotoRecombination.Settings(set::PhotoRecombination..Settings;\n\n    multipoles=..,          gauges=..,              electronEnergies=..,          ionEnergies=..,     \n    useIonEnergies=..,      calcTotalCs..,          calcAnisotropy=..,            calcTensors=..,             \n    printBefore=..,         maxKappa=..,            lineSelection=..)\n                \n... constructor for modifying the given PhotoRecombination..Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.Settings-Tuple{}","page":"API Reference","title":"JAC.PhotoRecombination.Settings","text":"PhotoRecombination.Settings()  ... constructor for the default values of photo recombination line computations\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.amplitude-Tuple{String, JAC.PhotoRecombination.Channel, Float64, Level, Level, JAC.Radial.Grid}","page":"API Reference","title":"JAC.PhotoRecombination.amplitude","text":"PhotoRecombination.amplitude(kind::String, channel::PhotoRecombination.Channel, energy::Float64, finalLevel::Level,                                  continuumLevel::Level, grid::Radial.Grid)       ... to compute the kind = (photorecombination) amplitude           < alphaf Jf || O^(photorecombination) || (alphai Ji, epsilon kappa) J_t>  due to the electron-photon          interaction for the given final and continuum level, the partial wave of the outgoing electron as well as          the given multipole and gauge. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.checkConsistentMultiplets-Tuple{Multiplet, Multiplet}","page":"API Reference","title":"JAC.PhotoRecombination.checkConsistentMultiplets","text":"PhotoRecombination.checkConsistentMultiplets(finalMultiplet::Multiplet, initialMultiplet::Multiplet)       ... to check that the given initial- and final-state levels and multiplets are consistent to each other and         to avoid later problems with the computations. An error message is issued if an inconsistency occurs,         and nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.compareCrossSectionEmpirical-Tuple{Vector{Float64}, Float64}","page":"API Reference","title":"JAC.PhotoRecombination.compareCrossSectionEmpirical","text":"PhotoRecombination.compareCrossSectionEmpirical(energies::Array{Float64,1}, Z::Float64)       ... to evaluate and compare different (non-relativistic) shell-resolved and total cross section for the          RR of a free electron with energy into initially bare ions with nuclear charge Z; an cs::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.comparePlasmaRateEmpirical-Tuple{Vector{Float64}, Float64}","page":"API Reference","title":"JAC.PhotoRecombination.comparePlasmaRateEmpirical","text":"PhotoRecombination.comparePlasmaRateEmpirical(temps::Array{Float64,1}, Z::Float64)       ... to evaluate and compare different plasma rate coefficients for the capture of a Maxwellian-distributed         free electron with temperature Te in temps into initially bare ions with nuclear charge Z; nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.computeAmplitudesProperties-Tuple{JAC.PhotoRecombination.Line, Model, JAC.Radial.Grid, Int64, JAC.PhotoRecombination.Settings}","page":"API Reference","title":"JAC.PhotoRecombination.computeAmplitudesProperties","text":"PhotoRecombination.computeAmplitudesProperties(line::PhotoRecombination.Line, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,                                                  settings::PhotoRecombination.Settings)       ... to compute all amplitudes and properties of the given line; a line::PhotoRecombination.Line is returned for          which the amplitudes and properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.computeAnisotropyParameter-Tuple{Int64, JAC.Basics.EmGauge, JAC.PhotoRecombination.Line}","page":"API Reference","title":"JAC.PhotoRecombination.computeAnisotropyParameter","text":"PhotoRecombination.computeAnisotropyParameter(nu::Int64, gauge::EmGauge, line::PhotoRecombination.Line)       ... to compute the anisotropy parameter of the emitted photons for the photorecombination of an initially unpolarized ion.          A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.computeCrossSectionBareIon-Tuple{Float64, Subshell, Vector{EmMultipole}, JAC.Basics.EmGauge, Model, JAC.Radial.Grid, Int64}","page":"API Reference","title":"JAC.PhotoRecombination.computeCrossSectionBareIon","text":"PhotoRecombination.computeCrossSectionBareIon(energy_eV::Float64, subshell::Subshell, multipoles::Array{EmMultipole,1},                                                  gauge::EmGauge, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64)       ... to compute the (hydrogenic) RR cross section for the capture of an electron into a single subshell;          only the amplitudes for the given multipoles are taken into account; an cs::Float64 [a.u.] is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.computeCrossSectionForMultipoles-Tuple{Vector{EmMultipole}, JAC.PhotoRecombination.Line}","page":"API Reference","title":"JAC.PhotoRecombination.computeCrossSectionForMultipoles","text":"PhotoRecombination.computeCrossSectionForMultipoles(multipoles::Array{EmMultipole,1}, line::PhotoRecombination.Line)       ... to compute the cross section from the channel amplitudes of a given line; only the amplitudes         for the given multipoles are taken into account; an cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.computeLines-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.PhotoRecombination.Settings}","page":"API Reference","title":"JAC.PhotoRecombination.computeLines","text":"PhotoRecombination.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                          settings::PhotoRecombination.Settings; output::Bool=true)      ... to compute the photo recombination transition amplitudes and all properties as requested by the given settings.          A list of lines::Array{PhotoRecombination.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.computeLinesWithContinuumOrbital-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, Dict{Subshell, Orbital}, JAC.Radial.GridGL, JAC.PhotoRecombination.Settings}","page":"API Reference","title":"JAC.PhotoRecombination.computeLinesWithContinuumOrbital","text":"PhotoRecombination.computeLinesWithContinuumOrbital(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model,                                                          grid::Radial.Grid, cOrbitals::Dict{Subshell, Orbital}, energyGrid::Radial.GridGL,                                                          settings::PhotoRecombination.Settings; output::Bool=true)      ... to compute the photo recombination transition amplitudes and all properties as requested by the given settings but with the         given continuum orbitals cOrbitals and for the (free-) electronEnergies. A error message is issued if these energies are not         the same a given by the settings. The continuum orbital with electronEnergies[i] has the principal quantum number 100+i.         A list of lines::Array{PhotoRecombination.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.crossSectionBellTotal-Tuple{Float64, Float64}","page":"API Reference","title":"JAC.PhotoRecombination.crossSectionBellTotal","text":"PhotoRecombination.crossSectionBellTotal(energy::Float64, Z::Float64)       ... to evaluate the (non-relativistic) total Bell & Bell cross section for the RR of a free electron with energy          into any shell of initially bare ions with nuclear charge Z; an cs::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.crossSectionKramers-Tuple{Float64, Float64, Tuple{Int64, Int64}}","page":"API Reference","title":"JAC.PhotoRecombination.crossSectionKramers","text":"PhotoRecombination.crossSectionKramers(energy::Float64, Z::Float64, nLowUp::Tuple{Int64,Int64})       ... to evaluate the (non-relativistic) Kramers cross section for the RR of a free electron with energy into all shells with         n = nLow ... nUp of initially bare ions with nuclear charge Z; an cs::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.crossSectionKramersTotal-Tuple{Float64, Float64}","page":"API Reference","title":"JAC.PhotoRecombination.crossSectionKramersTotal","text":"PhotoRecombination.crossSectionKramersTotal(energy::Float64, Z::Float64)       ... to evaluate the (non-relativistic) Kramers cross section for the RR of a free electron with energy into any shell         of initially bare ions with nuclear charge Z; an cs::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.crossSectionStobbe-Tuple{Float64, Float64}","page":"API Reference","title":"JAC.PhotoRecombination.crossSectionStobbe","text":"PhotoRecombination.crossSectionStobbe(energy::Float64, Z::Float64)       ... to evaluate the (non-relativistic) Stobbe cross section for the RR of a free electron with energy into the 1s state of          initially bare ions with nuclear charge Z; an cs::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.determineChannels-Tuple{Level, Level, JAC.PhotoRecombination.Settings}","page":"API Reference","title":"JAC.PhotoRecombination.determineChannels","text":"PhotoRecombination.determineChannels(finalLevel::Level, initialLevel::Level, settings::PhotoRecombination.Settings)       ... to determine a list of RecChannel for a transitions from the initial to final level and by taking into account          the particular settings of for this computation; an Array{PhotoRecombination.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.determineLines-Tuple{Multiplet, Multiplet, JAC.PhotoRecombination.Settings}","page":"API Reference","title":"JAC.PhotoRecombination.determineLines","text":"PhotoRecombination.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::PhotoRecombination.Settings)       ... to determine a list of PhotoRecombination.Line's for transitions between levels from the initial- and final-state          multiplets, and by taking into account the particular selections and settings for this computation;          an Array{PhotoRecombination.Line,1} is returned. Apart from the level specification, all physical properties are set          to zero during the initialization process.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.displayLines-Tuple{IO, Vector{JAC.PhotoRecombination.Line}}","page":"API Reference","title":"JAC.PhotoRecombination.displayLines","text":"PhotoRecombination.displayLines(stream::IO, lines::Array{PhotoRecombination.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all selected          transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.displayRateCoefficients-Tuple{IO, LevelSymmetry, Vector{Float64}, Vector{JAC.Basics.EmProperty}}","page":"API Reference","title":"JAC.PhotoRecombination.displayRateCoefficients","text":"PhotoRecombination.displayRateCoefficients(stream::IO, isym::LevelSymmetry, temperatures::Array{Float64,1}, alphaRR::Array{EmProperty,1})       ... to print all rate coefficients for the selected temperatures in neat tables,          though nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.displayResults-Tuple{IO, Vector{JAC.PhotoRecombination.Line}, JAC.PhotoRecombination.Settings}","page":"API Reference","title":"JAC.PhotoRecombination.displayResults","text":"PhotoRecombination.displayResults(stream::IO, lines::Array{PhotoRecombination.Line,1}, settings::PhotoRecombination.Settings)       ... to list all results, energies, cross sections, etc. of the selected lines. A neat table is printed but nothing is          returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.plasmaRateKotelnikov-Tuple{Float64, Float64}","page":"API Reference","title":"JAC.PhotoRecombination.plasmaRateKotelnikov","text":"PhotoRecombination.plasmaRateKotelnikov(Te::Float64, Z::Float64)       ... to evaluate the RR plasma rate coefficient at temperature Te and for a Maxwellian distribution of electron         energies and an initially bare ions with nuclear charge Z; an alpha::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.plasmaRateKotelnikov_1s-Tuple{Float64, Float64}","page":"API Reference","title":"JAC.PhotoRecombination.plasmaRateKotelnikov_1s","text":"PhotoRecombination.plasmaRateKotelnikov_1s(Te::Float64, Z::Float64)       ... to evaluate the RR plasma rate coefficient at temperature Te and for a Maxwellian distribution of electron         energies and an initially bare ions with nuclear charge Z; here only the capture into 1s is taken into account.         An alpha::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.plasmaRatePartialSeaton-Tuple{Float64, Float64, Int64}","page":"API Reference","title":"JAC.PhotoRecombination.plasmaRatePartialSeaton","text":"PhotoRecombination.plasmaRatePartialSeaton(Te::Float64, Z::Float64, n::Int64)       ... to evaluate the RR plasma rate coefficient at temperature Te and for a Maxwellian distribution of electron         energies and an initially bare ions with nuclear charge Z.         An alpha::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JAC.PhotoRecombination.plasmaRateSeaton-Tuple{Float64, Float64}","page":"API Reference","title":"JAC.PhotoRecombination.plasmaRateSeaton","text":"PhotoRecombination.plasmaRateSeaton(Te::Float64, Z::Float64)       ... to evaluate the RR plasma rate coefficient at temperature Te and for a Maxwellian distribution of electron         energies and an initially bare ions with nuclear charge Z; this formula is valid for 2*Te / Z^2 << 1.         An alpha::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"license.html#jac-license","page":"License","title":"LICENSE","text":"","category":"section"},{"location":"license.html","page":"License","title":"License","text":"The JAC apackage is distributed under the MIT licence. The associated User Guide, Compendium & Theoretical Background to JAC is distributed under the Creative Commons Attribution 4.0 International (CC BY 4.0) license.","category":"page"},{"location":"license.html","page":"License","title":"License","text":"Copyright (c) 2017-2025: Stephan Fritzsche.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"examples.html#Demo-files","page":"Examples","title":"Demo files","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"info: Info\nThe demo files are designed with Pluto notebook. A detaild guideline of Pluto Installation is available at (https://plutojl.org/#install).\nUsers can also find the files in the demo folder JAC package.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"SCF and CI\nTransition Probabilities and Lifetime\nDielectronic Recombination\nAuger rates","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Hallo world !","category":"page"},{"location":"examples.html#Hydrogenic-Computation","page":"Examples","title":"Hydrogenic Computation","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using JAC","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Perhaps, the simplest atomic computations can be made for hydrogenic ions. If we consider, for example, hydrogen-like argon (Z=18), we can first determine and compare the energies of the 1s and 2p levels from the (non-relativistic) Schroedinger equation with those from Dirac's relativistic equation by","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Z     = 18.0\ne1s   = HydrogenicIon.energy(Shell(\"1s\"), Z)   ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"e2p   = HydrogenicIon.energy(Shell(\"2p\"), Z)\ne2p_1 = HydrogenicIon.energy(Subshell(\"2p_1/2\"), Z)   \ne2p_3 = HydrogenicIon.energy(Subshell(\"2p_3/2\"), Z)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"While the (one-electron) energies are displayed by the function  HydrogenicIon.energy() in the default units (presently eV here and as could be overwritten by the user), all computations are internally performed and returned always in atomic units. This applies to all computations if not stated otherwise in the description of some particular function; indeed, the user-defined units mainly in the tabulation of results but are not returned. Most of these tabulations are generated by display method which print some table to screen but return nothing otherwise.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This clear distinction between the use of atomic and (user-specified) default units can be seen  easily from the output of the variables e2p, e2p_1, e2p_3 above: ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(e2p, e2p_1, e2p_3) ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The units of energies, rates and several other physical properties can be however quite easily converted among each other, for instance, by:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"e1s_eV = convertUnits(\"energy: from atomic to eV\", e1s)\ne1s_au = convertUnits(\"energy: from eV to atomic\", e1s_eV)\n(e1s, e1s_eV, e1s_au)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"... and similarly also for other energy units as well as for other physical entities; cf. ? convertUnits().","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"From these energies, we can easily compute the fine-structure splitting of the 2p level into the 2p_12 and 2p_32 (fine-structure) levels for hydrogen-like argon from above:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"e13 = e2p_1 - e2p_3\ne13_eV = convertUnits(\"energy: from atomic to eV\", e13)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Apart from the (single-electron) energies, we can generate also the radial orbitals, i.e. the P(r) in the non-relativistic theory or  P(r) and Q(r)  in the relativistic theory. Both, the relativistic and non-relativistic orbitals, can be calculated by using the general (and analytically well-known) solutions of either the Dirac's or Schrödinger's equation. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"However, since all (radial) orbital functions are represented on some Radial.Grid, special care has to be taken in order to define a proper grid, and which affects also all subsequent numerical computations as well as the accuracy that can be obtained. To better understand the definition of the grid, let us ask for:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"? Radial.Grid","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Radial.Grid","category":"page"},{"location":"examples.html#JAC.Radial.Grid-examples","page":"Examples","title":"JAC.Radial.Grid","text":"struct  Radial.Grid  ... defines a type for the radial grid which contains all information about the grid parameters, the genration                              of the B-spline basis as well as for performing radial integrations.\n\n** Physical grid parameter **\n+ rnt        ::Float64           ... smalles grid point > 0.\n+ h          ::Float64           ... stepsize in the construction of the exponential grid.\n+ hp         ::Float64           ... asymptotic stepsize of the log-lin grid.\n+ NoPoints   ::Int64             ... No. of grid points so that r[NoPoints] coincides also \n                                        with the largest break point of the B-spline knot.\n** B-spline grid parameters and break points **\n+ tL         ::Array{Float64,1}  ... radial break points for the B-splines of the large c.\n+ tS         ::Array{Float64,1}  ... radial break points for the B-splines of the small c.\n+ ntL        ::Int64             ... number of break points in the t-grid of the large c.\n+ ntS        ::Int64             ... number of break points in the t-grid of the small c.\n+ orderL     ::Int64             ... B-spline order of large components.\n+ orderS     ::Int64             ... B-spline order of small components.\n+ nsL        ::Int64             ... number of B-splines for large components.\n+ nsS        ::Int64             ... number of B-splines for small components.\n+ orderGL    ::Int64             \n    ... order of the Gauss-Lengedre integration if mesh == Radial.MeshGL(); this order also determines\n        the (number of) break points by taking the orderGL-th point from the physical grid points.\n** Radial mesh points **\n+ meshType   ::Radial.AbstractMesh\n+ r          ::Array{Float64,1}  ... radial grid points\n+ rp         ::Array{Float64,1}  ... derivative of the radial grid at the grid points\n+ rpor       ::Array{Float64,1}  ... rp over r\n+ wr         ::Array{Float64,1}  \n    ... integration weights for all grid points, for instance, GL weights.\n\n\n\n\n\n","category":"type"},{"location":"examples.html","page":"Examples","title":"Examples","text":"which shows the internal definition and the constructors to define such a grid. In practice, there are three (logical) levels that are considered and realized for each grid:  (i) The phenomenological grid definition that is based on our physics understanding and intuition of which grid is appropriate to decribe a particular atomic property or process. Two currently implemented grid refers to an exponential grid (with exponentially increasing stepsize) as appropriate for many bound-state computations and a linear-logarithmic grid that start exponentially but becomes linear in its stepsize for large values of r. Such a linear-logarithmic grid is typically needed to describe electron ionization and capture processes as the incoming or outgoing electron waves are sinusoidal and should be represented with a proper number of grid points, say 20-30, per period of the electron wave. In JAC, the phenomenologically part of the grid is chosen (analogue as in GRASP) by the parameters rnt, h, hp and NoPoints in the definition above. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(ii) The phenomenological definition of the grid is internally translated into a sequence of knots upon which the B-spline primitives are defined. Here, each nth mesh point from the phenomenological is chosen to keep the number of B-splines and the corresponding size of matrices (that need to be diagonalized) moderate. These knots are used to define the B-splines and to determine the eigenvectors of all orbitals (within some given potential) but they are not applied in order evaluate matrix elements or radial integrals.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(iii) The phenomenological grid and the definition of the B-splines (knots) are eventually combined into a physical grid upon which all radial functions are represented. This physical grid resembles the phenomenological grid but with modified grid points in between the knots of the B-spline grid (t-grid). Here the radial points and corresponding weights are chosen due to a Gauss-Legendre distribution and goal to determine all radial integrals exact up to a given Gauss-Legendre order.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The physical grid is thus defined by the three arrays r (the mesh points along r), rp (the derivatives d r/ dr), rpor (the values rp / r) as well as w (the corresponding weights). All these arrays are of length nr approx NoPoints but not necessarely equal as the grid points nr are coupled to the underlying integration, respectively, interpolation scheme. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In principle, this physical grid could chosen also on other interpolation/integration formulas, such as Gauss-Laguerre or others, that have been utilized in atomic physics. All what is needed would be to adapt the intermediate grid point and weights accordingly.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The clear distinction between the phenomenological grid and the physical grid help avoid that every new (radial) operator as well as particular boundary condition of the radial orbital functions need to be treated independently within the B-spline basis. Instead, a proper interpolation/integration formula should guarantee that all results are integrated sufficiently accurate, and this is first of all tested by enlarging the number of grid point NoPoint –> nr","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Here, we first apply an exponential grid, and which is appropriate below in order to compute various expectation values:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"grid   = Radial.Grid(true, printout= true)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"With this grid, the non-relativistic radial orbitals P(r) can be obtained either for a single r-value, for a list of r-values as well as for all r-values on a given radial grid:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Pnr_1s = HydrogenicIon.radialOrbital(Shell(\"1s\"), Z, grid)\nPnr_2p = HydrogenicIon.radialOrbital(Shell(\"2p\"), Z, grid)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Here, the exponential tails of the radial orbitals are simply set to zero if P  10e-15 (and similarly for Q).","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Of course, we could plot the two functions Pnr_1s and Pnr_2p directly by some proper call of PyPlot, and if we give the correct arrays of radial mesh points from above.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Plots \nplot(grid.r, [Pnr_1s, Pnr_2p],xlims=(0,1), xlabel = \"r (a.u.)\", ylabel=\"Amplitude (a.u.)\", label=[\"1s\" \"2p\"])\nsavefig(\"hdy-1.svg\"); nothing # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We can also make use of this function to visualise the relativistic orbitals if we specify the total angular momentum and generate the relativistic orbitals, which contain both the large and the small component.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"setDefaults(\"standard grid\", grid)\nPQr_1s = HydrogenicIon.radialOrbital(Subshell(\"1s_1/2\"), Z, grid)\nPQr_2p1 = HydrogenicIon.radialOrbital(Subshell(\"2p_1/2\"), Z, grid)\nPQr_2p3 = HydrogenicIon.radialOrbital(Subshell(\"2p_3/2\"), Z, grid)\nplot(grid.r, [PQr_1s,PQr_2p1, PQr_2p3],xlims=(0,1), xlabel = \"r (a.u.)\", ylabel=\"Amplitude (a.u.)\", label=[\"1s - Large component\" \"1s - Small component\" \"2p_1/2 - Large component\" \"2p_1/2 - Small component\" \"2p_3/2 - Large component\" \"2p_3/2 - Small component\"])\nsavefig(\"hdy-2.svg\"); nothing # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In practice, using Pyplot is often quite tedious since all the specification of arrays, axes, labels, etc. need to be given explicitly. To display the shape of such orbitals, a special plotting method is prepared in JAC that displayes one or several orbitals together. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"? Basics.plot","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Basics.plot","category":"page"},{"location":"examples.html#JAC.Basics.plot-examples","page":"Examples","title":"JAC.Basics.plot","text":"Basics.plot()  ... plots various quantities, often in a new window.\n\n(\"radial potentials\", potentials::Array{Radial.Potential,1}, grid::Radial.Grid; N::Int64 = 0)     ... to plot one or more radial potentials, and where N::Int64 describes the number of grid points to be considered.       call:  using Plots; pyplot()    ... to access this method by plot(...)\n\n\n\n\n\n(\"radial orbitals: large\", orbitals::Array{Radial.Orbital,1}, grid::Radial.Grid; N::Int64 = 0)     ... to plot the large component of one or more radial orbitals, and where N::Int64 describes the number of grid        points to be considered.\n(\"radial orbitals: small\", orbitals::Array{Radial.Orbital,1}, grid::Radial.Grid; N::Int64 = 0)     ... to plot the small component of one or more radial orbitals.\n(\"radial orbitals: both\",  orbitals::Array{Radial.Orbital,1}, grid::Radial.Grid; N::Int64 = 0)     ... to plot the large and small component of one or more radial orbitals.\ncall:  using Plots; pyplot()    ... to access this method by plot(...)\n\n\n\n\n\n(\"spectrum: transition rates over energy\", lines::Array{PhotoEmission.Line,1})     ... to plot the transition rates of all lines as function of their transition energies. The plot is shown in a new        window but nothing is returned otherwise. Not yet implemented !\n(\"spectrum: oscillator strength over energy, emission\", lines::Array{PhotoEmission.Line,1}) or   (\"spectrum: oscillator strength over energy, absorption\", lines::Array{PhotoEmission.Line,1})    ... to plot the absorption oscillator strength of all lines as function of their transition energies. Again, a new        window is opened but nothing returned by this method. Not yet implemented !\n\n\n\n\n\n(\"spectrum: transition rates over energy, Gaussian\", lines::Array{PhotoEmission.Line,1}; widths=value::Float64) or   (\"spectrum: transition rates over energy, Lorentzian\", lines::Array{PhotoEmission.Line,1}; widths=value::Float64)   ... to plot the transition rates of all lines as function of their transition energies but with a Gaussian or Lorentzian        distribution. Again, a new window is opened but nothing returned by this method. It still need to be decided how        the widths (and, perhaps, other parameters) will be communicated to the method. Not yet implemented !\n\n\n\n\n\n","category":"function"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This Basics.plot function (from the Basics module) accepts for instance a list of (relativistic) radial Orbitals:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"? Orbital","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Orbital","category":"page"},{"location":"examples.html#JAC.Radial.Orbital-examples","page":"Examples","title":"JAC.Radial.Orbital","text":"struct  Radial.Orbital       ... defines a type for a single-electron radial orbital function with a large and small component, and which can refer to         either the standard or an explicitly given grid due to the logical flag useStandardGrid. Bound-state orbitals with energy < 0 are          distinguished from free-electron orbitals by the flag isBound.\n\n+ subshell        ::Subshell          ... Relativistic subshell.\n+ isBound         ::Bool              ... Logical flag to distinguish between bound (true) and free-electron orbitals (false).\n+ useStandardGrid ::Bool              ... Logical flag for using the standard grid (true) or an explicitly given grid (false).\n+ energy          ::Float64           ... Single-electron energies of bound orbitals are always negative.\n+ P               ::Array{Float64,1}  ... Large and ..\n+ Q               ::Array{Float64,1}  ... small component of the radial orbital.\n+ Pprime          ::Array{Float64,1}  ... dP/dr.\n+ Qprime          ::Array{Float64,1}  ... dQ/dr.\n+ grid            ::Array{Float64,1}  ... explic. defined radial grid array for P, Q, if StandardGrid = false.\n\n\n\n\n\n","category":"type"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Of course, the main purpose of this plot method is to display and compare a number of generated orbitals, either for getting physical insight or just for test purposes. We can make use of the same plot method also for the non-relativistic  Pnr_1s(r)  orbital if we assign this array as large component of a relativistic orbital and specify the additional quantum numbers. Moreover, we here first internally to define a standard grid as well as such an (instance of the) Orbital by using its standard constructor, and by setting the small  Q(r) component as well as dPdr and dQdr simply to zero:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"setDefaults(\"standard grid\", grid)\nQnr_1s   = Pprime = Qprime = zeros( length(Pnr_1s) )\nnrOrb_1s = Orbital( Subshell(\"1s_1/2\"), true, true, e1s, Pnr_1s, Qnr_1s, Pprime, Qprime, Radial.Grid())\ntypeof(nrOrb_1s)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We could also compute a relativistic 1s_12 orbital on the given grid and plot the two 1s-orbitals together; while the large components of these orbitals coincide of course, due to its special construction via the non-relativistic orbitals, the small compoments differ. Note that one need to use the standard REPL in order to display these functions in some separate window.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Orb_1s = HydrogenicIon.radialOrbital(Subshell(\"1s_1/2\"), Z, grid)\ne1s_1 = HydrogenicIon.energy(Subshell(\"1s_1/2\"), Z)\nrOrb_1s = Orbital( Subshell(\"1s_1/2\"), true, true, e1s_1, Orb_1s[1], Orb_1s[2], Pprime, Qprime, Radial.Grid())","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"plot(\"radial orbitals: both\", Orbital[nrOrb_1s, rOrb_1s], grid; N = 230)\nsavefig(\"hdy-3.svg\"); nothing # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We can use these orbitals to quickly evaluate some overlap integrals and langle r^k rangle expectation values; for this, we make use of the non-relativistic 2p radial orbital Pnr_2p from above and compute the normalization  and langle r rangle expectation values:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"N_1s = RadialIntegrals.overlap(Pnr_1s, Pnr_1s, grid)\nN_2p = RadialIntegrals.overlap(Pnr_2p, Pnr_2p, grid)\nr_exp_1s = RadialIntegrals.rkDiagonal(1, Pnr_1s, Pnr_1s,grid)\nr_exp_2p = RadialIntegrals.rkDiagonal(1, Pnr_2p, Pnr_2p,grid)\nprintln(\"N_1s = $(N_1s)\",\"\\n\",\"N_2p = $(N_2p)\",\"\\n\",\"r_exp_1s = $(r_exp_1s)\",\"\\n\",\"r_exp_2p = $(r_exp_2p)\")","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"As we can see the radial orbitals are already normalized by construction and the expectation values match with the analytic values of langle r rangle_nl = frac12Z3n²-l(l+1). ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"For the sake of simplicity, all hydrogenic computations are performed for a point-like nucleus. For many-electron computations, in constrast, a more realistic nucleus can be taken into accout by selecting a proper nuclear model. See the tutorial: Define the nuclear model parameters   or   ? Nuclear.Model  ... for further details.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":" ? Nuclear.Model","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Nuclear.Model","category":"page"},{"location":"examples.html#JAC.Nuclear.Model","page":"Examples","title":"JAC.Nuclear.Model","text":"struct  Nuclear.Model  ... defines a type for the nuclear model, i.e. for its form and parameters.\n\n+ Z        ::Float64         ... nuclear charge\n+ model    ::String          ... identifier of the nuclear model: {\"Fermi\", \"Point\", \"Uniform\"}\n+ mass     ::Float64         ... atomic mass\n+ radius   ::Float64         ... (root-mean square) radius of a uniform or Fermi-distributed nucleus\n+ spinI    ::AngularJ64      ... nuclear spin I, must be >= 0\n+ mu       ::Float64         ... magnetic dipole moment in Bohr magnetons\n+ Q        ::Float64         ... electric quadrupole moment\n\n\n\n\n\n","category":"type"},{"location":"examples.html","page":"Examples","title":"Examples","text":"If we would like to compute a relativistic orbital by taking into account the type of the nucleus, we can simply define a nuclear model: ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Nucleus = Model(Z, \"Fermi\")","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"and set it as an argument value of the radialOrbital-function. By comparing the analytic orbitals which are based on a point like nucleus and the orbitals taking into account a fermi distributed nucleus one can see, that the influence of the nucleus is negligible for large r. However by looking at the functions at a closer angle the influence of the nucleus is well visible for small r. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"nuc_orb_1s = HydrogenicIon.radialOrbital(Subshell(\"1s_1/2\"),Nucleus, grid)\nplot(\"radial orbitals: both\", [nuc_orb_1s,rOrb_1s], grid; N = 230)\nsavefig(\"hdy-4.svg\"); nothing # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"plot(\"radial orbitals: both\", [nuc_orb_1s,rOrb_1s], grid; N = 75)\nsavefig(\"hdy-2.svg\"); nothing # hide","category":"page"},{"location":"examples.html#Compute-the-low-lying-levels-of-C{2}-1s2-(2s2-2s2p-2p2):-\\;-SCF-and-configuration-interaction-calculations","page":"Examples","title":"Compute the low-lying levels of C^2+ 1s^2 (2s^2 + 2s2p + 2p^2):  SCF and configuration interaction calculations","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using JAC","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The low-lying levels (level structure) of beryllium-like ions, and especially of C^2+, has been calculated in many case studies in the literature. While the level structure of these ions is still quite simple, it exhibits a considerable admixture of the  2s^22p^2 configuration already for the 1s^22s^2 ^1S_0 ground level.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We here show how the low-lying levels of C^2+ can be readily calculated in JAC by either following the default settings or by specifying further details for both, the SCF and configuration-interaction (CI) computations. As usual, we first need to  specify a radial grid as well as the nuclear model for the subsequent computations:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"grid     = Radial.Grid(true)\nnucModel = Nuclear.Model(6., \"Fermi\")","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"For a quick computation of the ground level of C^2+ ions, we can simply use the standard settings as given by AsfSettings():","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"multiplet     = SelfConsistent.performSCF([Configuration(\"1s^2 2s^2\")], nucModel, grid, AsfSettings());\nBasics.tabulate(stdout, \"multiplet: energies\", multiplet, Array(1:length(multiplet.levels)) )       # hide\nBasics.tabulate(stdout, \"multiplet: energy of each level relative to lowest level\", multiplet, Array(1:length(multiplet.levels)) )  # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"... and, similarly, also for the 10 lowest levels of C^2+ ions as they arise from the C^2+ 1s^2 (2s^2 + 2s2p + 2p^2) configurations:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"multiplet     = SelfConsistent.performSCF([Configuration(\"1s^2 2s^2\"), Configuration(\"1s^2 2s 2p\"), Configuration(\"1s^2 2p^2\")], \n                              nucModel, grid, AsfSettings());\nBasics.tabulate(stdout, \"multiplet: energies\", multiplet, Array(1:length(multiplet.levels)) )   # hide\nBasics.tabulate(stdout, \"multiplet: energy of each level relative to lowest level\", multiplet, Array(1:length(multiplet.levels)) )  # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"From the comparison of the two ground-state energies, we see that the admixture of the 2p^2 configuration has lowered the (total) ground state energy by about 1.8 eV, a rather remarkable admixture, as the  ^3P_0 is just 6.6 eV above of the ground level.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Further control about these electronic computations can be obtained by modifying the (so-called) settings. In general, all computations of the electronic structure, properties and processes as well as all more advanced computations can be controlled quite in details by various settings that are associated to the different computational requests. The SCF and configuration interaction calculations are controlled by AsfSettings that specify all details for the generation of the ASF. We can first have a look at the internal representation of these settings:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"? AsfSettings","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"AsfSettings","category":"page"},{"location":"examples.html#JAC.ManyElectron.AsfSettings-examples","page":"Examples","title":"JAC.ManyElectron.AsfSettings","text":"struct  ManyElectron.AsfSettings       ... a struct for defining the settings for the atomic state functions, i.e. the self-consistent-field (SCF)          and CI computations\n\n+ generateScf          ::Bool                   ... True, if a SCF need to be generated, and false otherwise \n                                                    (frozen orbitals).\n+ eeInteraction        ::AbstractEeInteraction  ... Specify the e-e interaction to be included into the SCF \n                                                    computations.\n+ scField              ::AbstractScField        ... Specify the self-consistent field, for instance, \n                                                    Basics.ALField(), etc.\n+ startScfFrom         ::AbstractStartOrbitals  ... Specify the orbitals to start the SCF computations\n+ maxIterationsScf     ::Int64                  ... maximum number of SCF iterations\n+ accuracyScf          ::Float64                ... convergence criterion for the SCF field.\n+ shellSequenceScf     ::Array{Subshell,1}      ... Sequence of subshells to be optimized.\n+ frozenSubshells      ::Array{Subshell,1}      ... Sequence of subshells to be kept frozen.\n\n+ eeInteractionCI      ::AbstractEeInteraction  ... Specify the e-e interaction to be included into the \n                                                    CI computations.\n+ qedModel             ::AbstractQedModel       ... model for estimating QED corrections {NoneQed(), \n                                                    QedPetersburg(), QedSydney()}.\n+ jjLS                 ::LSjjSettings           ... settings to control a jj-LS transformation of atomic \n                                                    level, if requested.\n+ levelSelectionCI     ::LevelSelection         ... Specifies the selected levels, if any.\n\n\n\n\n\n","category":"type"},{"location":"examples.html","page":"Examples","title":"Examples","text":"... as well as how the standard settings are presently defined:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"defaultAsfSettings = AsfSettings()","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"From this list, we easily see that the self-consistent field is by default based on a (mean) Dirac-Fock-Slater potential, a choice which we could overwrite by meanCH or any pre-defined potential. At present, however, no full treatment of the exchange interaction has yet been implemented in this first release of the program. The standard settings also show that the SCF is usually based on just the lowest level (cf. levelScf) as well as on the accuracy 1.0e-6 to terminate the SCF computations. Moreover, the individual orbitals are improved due to the standard subshell order (cf. shellSequenceScf).","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"For the CI parameters, the treatment of the Breit and QED interaction is of particular interest. At present, the defaults does not included neither Breit interactions nor QED. Such QED estimates can either be neglected (NoneQed()) or estimated by using an effective Hamiltonian approach due to Shabaev and coworkers  (QedPetersburg()) or effective potential approach (QedSydney(); Flambaum et al.) However, further tests need to be done to better understand the reliability of these QED estimates to the level structure and state represetation of the ASF.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"As seen from the settings above, moreover, there are special features in order to select individual levels for the CI computations, either in terms of their (relative) level No within the given multiplet or in terms of their level symmetry, i.e. their total angular momentum and parity, respectively. The  levelSelectionCI::LevelSelection here tells whether (and which) selections were made; apparently, no selection of level numbers of symmetries is made by default though this can be overwritten. The selection of individual symmetries, in particular, may considerably reduced the computational effort as the Hamiltonian matrix need then to be calculated only for the selected symmetries.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In principle, these standard settings can be easily re-defined within the code by simply modifying the constructor AsfSetings() with no additional arguments. Alternatively, we can easily overwrite those parameters in some given (instance of) AsfSetting which we just wish to modify. This is achieved by","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"asfSettings = AsfSettings(defaultAsfSettings; generateScf=true, jjLS=LSjjSettings(true), \n              levelSelectionCI=LevelSelection(true, symmetries=[LevelSymmetry(0,\"+\"), LevelSymmetry(1,\"-\")]) )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"multiplet     = SelfConsistent.performSCF([Configuration(\"1s^2 2s^2\"), Configuration(\"1s^2 2s 2p\"), \n                               Configuration(\"1s^2 2p^2\"), Configuration(\"1s^2 3s^2\"), \n                               Configuration(\"1s^2 3p^2\")],  nucModel, grid, asfSettings);\nBasics.tabulate(stdout, \"multiplet: energies\", multiplet, Array(1:length(multiplet.levels)) )   # hide\nBasics.tabulate(stdout, \"multiplet: energy of each level relative to lowest level\", multiplet, Array(1:length(multiplet.levels)) )  # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We finish this (simple) tutorial by enlarging the configuration basis for the low-lying levels but by restricting the CI computations to the level symmetries J^P = 0^+ and 1^-. This is achieved by specifying the settings to:","category":"page"},{"location":"news.html#The-following-features-have-been-recently-implemented-and-up-loaded-into-JAC's-master-code.","page":"News","title":"The following features have been recently implemented and up-loaded into JAC's master code.","text":"","category":"section"},{"location":"news.html#2023","page":"News","title":"2023","text":"","category":"section"},{"location":"news.html","page":"News","title":"News","text":"Update of UserGuide & Compendium: Various material has been added to the UserGuide & Compendium.    (May'23) \nFirst design of empirical computations: A new kind Empirical.Computation() has been established to support   electron-impact ionization (EII) cross sections. (March'23) ","category":"page"},{"location":"news.html#2022","page":"News","title":"2022","text":"","category":"section"},{"location":"news.html","page":"News","title":"News","text":"RR plasma rate coefficients: A cascade model has been established to automatically compute radiative    recombination (RR) plasma rate coefficients. (October'22) \nTwo-photon excitation and decay rates: Use of an appropriate Green function to generate (first) two-photon   excitation and decay rates. (May'22) \nElectron-impact excitation of ions: The collision strength and electron-impact excitation cross sections   can now be modeled for simple shell structures. (May'22) \nExpansion opacity computations: Estimates on the expansion opacity of atoms and ions have been implemented   as a cascade scheme. (May'22) \nDecay cascades for ions with empty shells: The cascades calculations for the stepwise decay of inner-shell   holes now proceed also for intially empty shells. (April'22)\nReduced 1-p density matrix & natural orbitals: Can be calculated for individual levels. (March'22)","category":"page"},{"location":"news.html#2021","page":"News","title":"2021","text":"","category":"section"},{"location":"news.html","page":"News","title":"News","text":"Hollow-ion cascades: The photon spectra and autoionization of hollow ions can be modeled by just providing   the initial configurations and the decay shells that are occupied during the stabilitation; cf. S. Fritzsche,    Atoms 2021, 10, 37; https://doi.org/10.3390/atoms10020037  (December'21)\nStrong-field ionization (together with Birger Böning): A first module (and examples) have been worked out to    apply the strong-field approximation (SFA) in a partial-wave reprensentation of the initial and Volkov states;    this makes the SFA suitable for dealing with realistic electronic structures of atoms and with different gauges   of the radiation field. (September'21)\nExtended and improved User Guide & Compendium:  (August'21)\nWrite-up of atomic Green functions: Cf. S. Fritzsche  & A. Surzhykov,   Molecules 2021, 26, 2660; https://doi.org/10.3390/molecules26092660   (May'21)\nExtended dielectronic recombination (DR) calculations: Apart from the DR resonance strength, the   DR (plasma) rate coefficients can be calculated as well.(March'21)\nWrite-up of atomic cascade computations: Cf. S. Fritzsche, P. Palmeri & S. Schippers,   Symmetry 2021, 13(3), 520; https://doi.org/10.3390/sym13030520   (March'21)\nJulia implementation of the spin-angular integration (together with Gediminas Gaigalas) The former    dependence of JAC upon the (Fortran) ANCO module for the spin-angular coefficients has now been removed   and replaced by the (Julia) SpinAngular module. This simplifies significantly the installation of the    JAC toolbox and will support further developments on cascades, reduced density matrices, etc.   (March'21)\nIsotope-shift calculations: Set-up of a first module for isotope-shift calculations (February'21)","category":"page"},{"location":"news.html#2020","page":"News","title":"2020","text":"","category":"section"},{"location":"news.html","page":"News","title":"News","text":"Extended and improved User Guide & Compendium:  (October'20)\nEnlarged number of second-order processes: Several second-order processes are now partly supported,   including photoexcitation & fluorescence,  photoexcitation & autoionization, Rayleigh scattering    of light, multi-photon excitation & decay, double-Auger decay, photo-double ionization,    radiative-Auger decay. (October'20)\nEnlarged number of atomic processes: The presently supported atomic processes now include    photoemission, photoexcitation, photoionization, photorecombination, Auger & autoionization,   dielectronic recombination. (September'20)\nAtomic cascades: The presently supported cascade computations include decay cascades as well as   their excitation by photoionization, photoexcitation or electron-capture. These excitation also   strongly affect the complexity of a cascade. (September'20)\nAutoionization & dielectronic recombination (DR): See ? AutoIonization.Settings or Dielectronic.Settings   for the calculation of Auger rates and DR resonance strength. (August'20)\nPhotoionization cross sections: See ? PhotoIonization.Settings for the calculation of photoionization   cross sections and angular parameters. (July'20)\nGeneration & use of continuum orbitals: See ? setDefaults how one can choose different methods   for the generation (\"method: continuum, Galerkin\", \"method: continuum, asymptotic Coulomb\", ...)   and normalization (\"method: normalization, pure Coulomb\", ...) of continuum orbitals. (June'20)\nNew level & line selectors: See ? LevelSelection, ? LineSelection and PathwaySelection; this   enables one to easily select individual levels, lines or pathways in the computation of properties   and processes. (June'20)\nNew and extended tutorials: A good number of new tutorials have been implemented and extended,   inluding the symbolic evaluation of expressions from Racah's algebra. (May'20)\nImproved continuum orbitals: Use of Galerkin method for generating continuum orbitals with    well-defined energy. (April'20)\nExtended and improved User Guide & Compendium:  (January-March'20)","category":"page"},{"location":"news.html#2019","page":"News","title":"2019","text":"","category":"section"},{"location":"news.html","page":"News","title":"News","text":"New and extended tutorials: A good number of new tutorials have been implemented and extended,   inluding SCF computations and different representations of atomic states. (30.11.19)\nGreen (function) expansions: Implememtation of simple approximate Green expansions, though still without   any continuum interactions. (26.11.19)\nRestricted active-space (RAS) expansions: Automatic generation of RAS expansions for selected levels   or symmetries. (22.11.19)\nAtomic representations: Different representations of wave and Green functions can now be distinguished;   cf. User Guide, section 4.1. (15.10.19)\nRacah algebra: Symbolic evaluation of expressions from Racah's algebra, based on special value and   sum rules; cf. User Guide, chapter 15. (10.8.19)\njjJ - LSJ transformation: LSJ expansion & notations of atomic levels with one (nonrelativistic)    open shell. (12.7.19)\nAtomic form factors: Standard and modified form factors for atoms in spherical-symmetric levels   (15.6.19)\nDebye-Hückel plasma potential: Implementation of the plasma shifts of energy levels into the   CI computation of a multiplet; cf. User Guide, section 6.1.e.   (26.3.19)\nBreit interaction:  Implementation of the frequency-independent Breit interaction amplitudes    that can be accessed via AsfSettings(..., breitCI=true, ...) in all configuration-interaction   computations.  (4.1.19)","category":"page"},{"location":"getting-started-julia.html#Getting-started-with-Julia-(in-REPL)","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"","category":"section"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"info: Info\nLink to the Pluto jl and direct start with  example...","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Here, we shall not introduce Julia's syntax and concepts for which many tutorials are available on the web. Instead, we just wish to remind and highlight some simple (syntax) features that help to go easier around with JAC, and especially for occasional users from experiment or teaching. This reminder aims to lower the initial threshold for users that have been trained on other languages in the past. Here, we shall pick up some issues whose physics background is explained only later in other tutorial. Obviously, however, Julia is a very rich and powerful language with many features that go well beyond of what is (and will ever) needed for JAC.","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"In brief, JAC provides tools for performing atomic (structure) calculations of different kind and complexity, and for which further details are given in the tutorials below. To see anything from JAC, we shall first invoke the tools by:","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"using JAC","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"a line that will appear at the beginning of all subsequent tutorials. – A first powerful and frequently needed feature refers to Julia's help pages or just the \"?\". By typing, for instance, atom or computation","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"? atom","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"search: atomic Atomic AtomicState AtomicCompass AtomicStructure @atomic @atomicswap @atomicreplace\n\nCouldn't find atom\nPerhaps you meant atomic, atan, acot, acos, htol, hton, ltoh, ntoh, Atomic, @atomic, pathof, atand, atanh, cat, match, catch, stat, acotd, acoth, add, ans, abs, abs2, acosd, acosh, acsc, all, all!, any, any!, asec, asin, axes, as, tan or Beam\nNo documentation found.\n\nBinding atom does not exist.","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"we see, that atom itself is not a well-defined term in the JAC toolbox but that there exists a number of related terms, such as Atomic, AtomicState (two modules of JAC) and others. We shall not enter here the modular structure of the JAC toolbox but start much simpler with: ","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"? Orbital","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Orbital","category":"page"},{"location":"getting-started-julia.html#JAC.Radial.Orbital-getting-started-julia","page":"Getting started with Julia (in REPL)","title":"JAC.Radial.Orbital","text":"struct  Radial.Orbital       ... defines a type for a single-electron radial orbital function with a large and small component, and which can refer to         either the standard or an explicitly given grid due to the logical flag useStandardGrid. Bound-state orbitals with energy < 0 are          distinguished from free-electron orbitals by the flag isBound.\n\n+ subshell        ::Subshell          ... Relativistic subshell.\n+ isBound         ::Bool              ... Logical flag to distinguish between bound (true) and free-electron orbitals (false).\n+ useStandardGrid ::Bool              ... Logical flag for using the standard grid (true) or an explicitly given grid (false).\n+ energy          ::Float64           ... Single-electron energies of bound orbitals are always negative.\n+ P               ::Array{Float64,1}  ... Large and ..\n+ Q               ::Array{Float64,1}  ... small component of the radial orbital.\n+ Pprime          ::Array{Float64,1}  ... dP/dr.\n+ Qprime          ::Array{Float64,1}  ... dQ/dr.\n+ grid            ::Array{Float64,1}  ... explic. defined radial grid array for P, Q, if StandardGrid = false.\n\n\n\n\n\n","category":"type"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"which, apart from its formal meaning, is a particular data structure (struct) of JAC and which represents a relativistic orbital (function) including additional information that appears helpful in the given implementation. There are very many (say, more than 300) of such data struct's specified in the JAC toolbox, and thus quite obvious that nobody will remember the details of all these definitions. Indeed, the \"?\" is the right and a powerful means to remind yourself and make use of these data structures whenever necessary. Special care has been taken that all data structures and functions/methods comes with a reasonable explanation (docstring) in order to work efficiently with JAC.","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"For instance, we might ask of what can be added to each other in JAC:","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"? add","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"add","category":"page"},{"location":"getting-started-julia.html#JAC.Basics.add-getting-started-julia","page":"Getting started with Julia (in REPL)","title":"JAC.Basics.add","text":"Basics.add(pota::Radial.Potential, potb::Radial.Potential)       ... to add two radial potentials together that are defined on the same grid. A potential::RadialPotential is returned          that inherits its radial size from the potential that is defined in a larger range of r-values.\n\n\n\n\n\nBasics.add(ma::AngularM64, mb::AngularM64)       ... adds the projections of the angular momenta ma + mb and returns a mc::AngularM64.\n\n\n\n\n\n","category":"function"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Apart from a short explanation, these docstring always tell the user (i) in which module the method is defined; (ii) which arguments it takes, including Julia's multiple dispatch feature as well as (iii) the type of the return value. All these information are typically relevant to the user, especially if some input or output does not behave as it should. Indeed, the complexity can grow quite rapidly, for instance, if we ask for help of what we can generate:","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"? generate","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"generate","category":"page"},{"location":"getting-started-julia.html#JAC.Basics.generate-getting-started-julia","page":"Getting started with Julia (in REPL)","title":"JAC.Basics.generate","text":"Basics.generate(representation::AtomicState.Representation)       ... to generate an atomic representation as specified by the representation.repType::AbstractRepresentationType.         All relevant intermediate and final results are printed to screen (stdout). Nothing is returned.\n\nBasics.perform(representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(repType::AtomicState.MeanFieldBasis, representation::AtomicState.Representation)       ... to generate a mean-field basis (representation) for a set of reference configurations; all relevant intermediate          and final results are printed to screen (stdout). Nothing is returned.\n\nBasics.generate(repType::AtomicState.MeanFieldBasis, representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(repType::AtomicState.MeanFieldMultiplet, representation::AtomicState.Representation)       ... to generate a mean-field basis (representation) for a set of reference configurations; all relevant intermediate          and final results are printed to screen (stdout). Nothing is returned.\n\nBasics.generate(repType::AtomicState.MeanFieldMultiplet, representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(repType::AtomicState.OneElectronSpectrum, representation::AtomicState.Representation)       ... to generate a one-electron spectrum for the atomic potential from the (given) levels, based on a set of reference          configurations as well as for given settings. Relevant intermediate and final results are printed to screen (stdout).          Nothing is returned in this case.\n\n+ `(repType::AtomicState.OneElectronSpectrum, representation::AtomicState.Representation; output=true)`  \n... to generate the same but to return the complete output in a orbitals::Dict{Subshell, Orbital}.\n\n\n\n\n\nBasics.generate(repType::AtomicState.CiExpansion, representation::AtomicState.Representation)       ... to generate a configuration-interaction expansion for a single level symmetry and based on a set of reference configurations         and a number of pre-specified steps. All relevant intermediate and final results are printed to screen (stdout).          Nothing is returned.\n\nBasics.generate(repType::AtomicState.CiExpansion, representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the computations but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(repType::AtomicState.RasExpansion, representation::AtomicState.Representation)       ... to generate a restricted active-space expansion for a single level symmetry and based on a set of reference configurations         and a number of pre-specified steps. All relevant intermediate and final results are printed to screen (stdout).          Nothing is returned.\n\nBasics.generate(repType::AtomicState.RasExpansion, representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the computations but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(repType::AtomicState.GreenExpansion, representation::AtomicState.Representation)       ... to generate a Green (function) expansion for a given approach and excitation scheme of the electron,         based on a set of reference configurations, a list of level symmetries as well as for given settings.         All relevant intermediate and final results are printed to screen (stdout). Nothing is returned.\n\nBasics.generate(repType::AtomicState.GreenExpansion, representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(\"condensed multiplet: by single weight\", multiplet::Multiplet)       ... to condense/reduce the number of CSF in the basis of the given multiplet due to a single 'weight';          a multiplet::Multiplet is returned.  Not yet implemented !\n\n\n\n\n\nBasics.generate(\"configuration list: NR, from basis\", basis::Basis)       ... to (re-) generate the list of NR configurations from the given basis; a confList::Array{Configuration,1} is returned.\n\n\n\n\n\nBasics.generate(\"configuration list: NR, single-configuration\", refConf::Configuration, NoExcitations::Int64, fromShells::Array{Shell,1},                     toShells::Array{Shell,1})       ... to generate a non-relativistic configuration list, including the given reference configuration (refConf) and with          all configurations that differ by NoExcitations from the fromShells into the toShells; an Array{Configuration,1}          is returned.\n\n\n\n\n\nBasics.generate(\"shells: ordered list for NR configurations\", confs::Array{Configuration,1})       ... to generate for confs, i.e. all the given (non-relativistic) configurations, a common and ordered shell list;          a list::Array{Shell,1} is returned.\n\n\n\n\n\nBasics.generate(\"subshells: ordered list for two bases\", basisA::Basis,  basisB::Basis)       ... to generate common and ordered subshell list for the two basis A and B; a list::Array{Subshell,1} is returned.\n\n\n\n\n\nBasics.generate(\"single-electron spectrum: STO\", N::Int64, potential::Radial.Potential, grid::Radial.Grid; N_0::Int64=30, alpha_0::Float64=1.0,                     beta_0::Float64=1.1)      ... to generate a complete one-electron spectrum with N positive and N negative states, and by using even-tempered Slater-type          orbitals (STO) with parameters lpha_i = lpha_0 eta_0^i; a spectrum::SingleElecSpectrum is returned where just          N0 positive and N_0 negative are kept for later use.  Not yet implemented !\n\nBasics.generate(\"single-electron spectrum: STO, positive\", N::Int64, potential::Radial.Potential, grid::Radial.Grid; N_0::Int64=30, alpha_0::Float64=1.0,                     beta_0::Float64=1.1)       ... to generate the same but to return only the N_0 positive states.  Not yet implemented !\n\n\n\n\n\n","category":"function"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Well, this is quite a lot, and we shall explain some of these methods below; a similar or even larger output, you can generate by ? perform as well as few other terms that are central to the implementation of JAC.","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Constructors & program control:quad Another frequent use of the (help) \"?\" concerns the data flow and control of almost all computations. In JAC, we often make use of (so-called) Settings that enable the user to overwrite default values or to control the computation to the extent, he or she wishes to have control. These Settings are context dependent and are different for each atomic property or process that can be computed by the JAC toolbox. They are defined in the various modules and need to be specified accordingly. For instance, to control the computation of transition probabilities for the (fine-structure) levels between given initial- and final-state configuration, one has to overwrite the (defaults) settings:","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"? PhotoEmission.Settings","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"PhotoEmission.Settings","category":"page"},{"location":"getting-started-julia.html#JAC.PhotoEmission.Settings-getting-started-julia","page":"Getting started with Julia (in REPL)","title":"JAC.PhotoEmission.Settings","text":"struct  PhotoEmission.Settings  <:  AbstractProcessSettings       ... defines a type for the details and parameters of computing radiative lines.\n\n+ multipoles              ::Array{EmMultipoles}     ... Specifies the (radiat. field) multipoles to be included.\n+ gauges                  ::Array{UseGauge}         ... Gauges to be included into the computations.\n+ calcAnisotropy          ::Bool                    ... True, if the anisotropy (structure) functions are to be \n                                                        calculated and false otherwise \n+ printBefore             ::Bool                    ... True, if all energies and lines are printed before comput.\n+ corePolarization        ::CorePolarization        ... Parametrization of the core-polarization potential/contribution.\n+ lineSelection           ::LineSelection           ... Specifies the selected levels, if any.\n+ photonEnergyShift       ::Float64                 ... An overall energy shift for all photon energies.\n+ mimimumPhotonEnergy     ::Float64                 ... minimum transition energy for which (photon) transitions \n                                                        are included into the computation.\n+ maximumPhotonEnergy     ::Float64                 ... maximum transition energy for which (photon) transitions \n                                                        are included.\n\n\n\n\n\n","category":"type"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"We shall meet these and (many) other settings quite often in the tutorials below. –- Beside of Julia's help features (?), however, it is sometimes difficult to remember the right term or function name. In this case, it easy to make a <double-tab> after the dot (notation) or to make use of the (Unix/Linux) grep command within the JAC/src directly. Similar line-search commands will exist also at other platforms. In particular, for those of you who wishes to support and extend the JAC toolbox, the dot expansion and the grep command will be found very helpful, perhaps more than other search tools.","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"info: Info\nUsers can also refer to the API Reference section that provides a comprehensive list of JAC declared Types and Functions for selected atomic processes.","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Use of constructors:quad Another Julia feature, that is frequently applied in JAC, is the successive definition of constructors in order to set-up complex data structures. This features is applied, for instance, in order to define an Atomic.Computation or a Cascade.Computation as a whole. We shall explain these rather complex data types below in different tutorials. The same issue appears however already at a much simpler level. For example, if we wish to select (specify) a number of levels from a multiplet prior to some particular – configuration interaction – computation, we can make use of a","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"? LevelSelection","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"LevelSelection","category":"page"},{"location":"getting-started-julia.html#JAC.Basics.LevelSelection-getting-started-julia","page":"Getting started with Julia (in REPL)","title":"JAC.Basics.LevelSelection","text":"struct  Basics.LevelSelection  <  Basics.AbstractSelection       ... defines a struct to specify a list of levels by means of their (level) indices or level symmetries.\n\n+ active       ::Bool                     ... true, if some selection has been made.\n+ indices      ::Array{Int64,1}           ... List of selected indices.\n+ symmetries   ::Array{LevelSymmetry,1}   ... List of selected symmetries\n\n\n\n\n\n","category":"type"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Apart from the logical flag active, such a level selection requires to either specify a list of level numbers (indices) or level symmetries","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"LevelSelection(true, indices= [i for i in 1:11])","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"LevelSelection(true, symmetries= [LevelSymmetry(1//2, Basics.plus)])","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Here, we made use of a LevelSymmetry to specify the overall rotational J^P symmetry of atomic levels.","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"? LevelSymmetry","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"LevelSymmetry","category":"page"},{"location":"getting-started-julia.html#JAC.Basics.LevelSymmetry-getting-started-julia","page":"Getting started with Julia (in REPL)","title":"JAC.Basics.LevelSymmetry","text":"struct  Basics.LevelSymmetry  <  AbstractAngularMomentum  ... defines a struct for defining the overall J^P symmetry of a level.\n\n+ J          ::AngularJ64  ... total angular momentum of a level\n+ parity     ::Parity      ... total parity of the level\n\n\n\n\n\n","category":"type"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"As seen from this definition, the level symmetry just comprises the total angular momentum (of type AngularJ64) and the parity of the level (of type Parity). Therefore, the specification of a list of level symmetries in LevelSelection already requires to nest four constructors in order make the level selection explicit: (i) For the angular momentum, (ii) the parity, (iii) the level symmetry and (iv) to create a list (array) of such level symmetries. All the constructors can be specified and built together also in subsequent steps, such as:","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"J1    = AngularJ64(1//2);           J2 = AngularJ64(5//2)  \npl    = Basics.plus;                mn = Basics.minus\nlsym1 = LevelSymmetry(J1, pl);      lsym2 = LevelSymmetry(J2, mn)\nlevelsyms = [lsym1, lsym2]","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"or simply by nesting all the information within a single step","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"levelsyms = [LevelSymmetry(AngularJ64(1//2), Basics.plus), LevelSymmetry(AngularJ64(5//2), Basics.minus)]","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Both way have their pros and cons, and often some mixture is applied where complex constructors are first assigned to some variables, and which are later utilized to built up constructors of higher complexity. –- To finally specify aǹ instance of a LevelSelection, we use (onc more) its second constructor above:","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"LevelSelection(true, indices=[1,2,3], symmetries=levelsyms)","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"and which will tell the JAC program to compute the lowest three levels (1, 2, 3) as well as all levels with 1/2+ and 5/2- symmetry. Apart from the selection of individual levels, it is often helpful for the computation of atomic processes to make a prior LineSelection and in some cases even a PathwaySelection as, for instance, for dielectronic recombination processes. Some of these features will be explained below in subsequent tutorials of JAC:","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Functions & methods:quad Like most other languages, Julia is based on the successive work through functions and methods; a function is first of all specified by its name and it maps a tuple of argument values upon a return value. For instance, the function","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"function addSomething(a, b)\n    c = a + b\nend\naddSomething(3.1, 5//2)","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"can be used to add two numbers, rather independent of their particular type, and which are infered here automatically. However, additional type declarations might help to specialize a function and to ensure type stability:","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"function addSomething(a::Int64, b::Int64, c::Int64)\n    d = a + b + c\nend","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"While the function name is the same in both of these examples above, Julia carefully distinguishes between these two methods of the function addSomething that may differ by the type and/or the number of arguments. This multiple use (dispatch) of function name enables the user to write highly specialized code. Although a proper (and specialized) definition of functions is often very important for the performance of the program, we shall not discuss such technical issues here. Let us just mention, that a function/method may also return nothing:","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"typeof(nothing)","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"In JAC, the value nothing is usually returned by all display functions that print some selected data or tabulation to screen or elsewhere but does not return a value otherwise.","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Code failures:quad Beside of its large flexibility and user-friendliness, JAC might terminate from time to time for non-obvious reasons. Since JAC is first of all a physics code, no attempt has been made that all possible errors are fully captured and recovered by the program. Wrong input parameters or an inappropriate use of contructors will often lead to errors that cannot be resolved by the program. While some of this input can be readily recognized as wrong, and then lead to a proper error message, other wrong data may appear dynamically and cannot be captured with a reasonable overhead of the code.  In JAC, therefore, several conditional if ... elseif ... else ... end blocks include an additional clause error(\"stop a\") or similar; these are clauses, which due to a first design of a function should never be entered, but this appears not to be true in all cases. The use of these (fully) non-instructive error message have still a great advantage due to Julia: If not switched-off explicitly, Julia always reports for all program failures the hierarchy of call's, that are made before the error occurs, and lists these calls together with the file and line number of source code. For this reason, an error(\"stop a\") readily shows the position where something unexpected occurs. A short inspection of the corresponding (line of the) source code often help to understand of what went wrong internally.","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Julia macros:quad  What can one do, if the (source) code itself does not tell so much about the problem ? –- In this case, it is often useful to include some additional printouts  near to the line in question into the code and to re-run it again. There are different ways (@show, print(), println()) to place printout in the code; cf. https://julialang.org/learning/  A particular quick and useful way makes use of the Julia macro:","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"@show levelsyms","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"which simply repeats the names of the variables together with their values. Of course, the values of several such variables can be shown within the same call:","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"wa = 5;   wb = [2.0, pi];   wc = ones(3)\n@show wa, wb, wc","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"Indeed, this @show macro makes printout very easy. There are many macros (all starting with @) in Julia which need not to be considered here. We just mention that @time in front of a Julia command (block) will take and display the CPU time that is necessary to run this line(s):","category":"page"},{"location":"getting-started-julia.html","page":"Getting started with Julia (in REPL)","title":"Getting started with Julia (in REPL)","text":"@time rand(50000)   ;","category":"page"},{"location":"index.html#Jena-Atomic-Calculator-(JAC)-for-the-computation-of-atomic-representations,-processes-and-cascades","page":"Home","title":"Jena Atomic Calculator (JAC) for the computation of atomic representations, processes and cascades","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Last update: April, 15th, 2025","category":"page"},{"location":"index.html#What-is-JAC?","page":"Home","title":"What is JAC?","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"JAC, the Jena Atomic Calculator, provides an open-source Julia package for doing atomic computations of various kind and complexity. In particular, JAC is a (relativistic) electronic structure code for the computation of (atomic many-electron)  interaction amplitudes, properties as well as a good number of excitation and decay processes for open-shell atoms and ions  across the whole periodic table. In recent years, moreover, emphasis has been placed support atomic cascade computations in different physical contexts as well as symbolic analysis (simplifications) of expressions from Racah's algebra. Some further work is done (or planned) to incorporate central features for studying atomic – strong-field – responses to external fields and particles, or the time-evolution of atoms and ions in the framework of (time-dependent) density matrix and Liouville equations.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A primary guiding philosophy of JAC was to develop a general and easy-to-use toolbox for the atomic physics community,  including an interface that is equally accessible for scientists working in astro and plasma physics, atomic spectroscopy, theoretical physics as well as for code developers. Beside of its simple use, however, we wish to provide and support a modern code design, a reasonable detailed documentation of the code and features for integrated testing. Indeed, the JAC toolbox  facilitates many typical computations and the handling of atomic data by providing input interfaces similar to what one  uses in a in spoken or written language. Shortly speaking, JAC aims to provide a powerful platform for daily use and  to extent atomic theory towards new applications or, eventually, a community platform for Just Atomic Computations.","category":"page"},{"location":"index.html#*Kinds*-of-computations","page":"Home","title":"Kinds of computations","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"In some more detail, JAC distinguishes and aims to support different kinds of computations which can be summarized  as follows:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Atomic computations, based on explicitly specified electron configurations: This kind refers to the frequently  applied computation of level energies and atomic state representations. It also supports the computation of either   (one or) several atomic properties for selected atomic levels from a given multiplet or of one selected process   at a time, if atomic levels from two or more multiplets and/or charge states are involved in some atomic transition,  such as the photo or autoionization of atoms.\nAtomic representations: This kind concerns the generation of different representations of atomic wave functions;   in particular, it includes systematically-enlarged restricted active-space (RAS) computations of atomic states   and level energies due to a pre-specified active space of orbitals as well as due to the (number and/or kind of)   virtual excitations to be taken to be into account. Such RAS computations are normally performed stepwise by making   use of the (one-electron) orbital functions from some prior step. Other atomic representations refer to approximate   atomic Green functions and, in the future, could be combined with concepts from close-coupling, (exterior) complex   scaling, DMRG or perturbation theory.\nInteractive computations: In practice, the (large set of) methods of the JAC toolbox can always be applied also   interactively, either directly at Julia's REPL or by using some – more or less – short Julia scripts in order to   compute and evaluate the desired observables (atomic parameters), such as energies, expansion coefficients, transition  matrices and amplitudes, rates, cross sections, etc. An interactive computation typically first prepares and applies   (certain instances of) JAC’s data types, such as orbitals, configuration-state functions (CSF), atomic bases, levels,   multiplets, and others. And like Julia, that is built upon many (high-level) functions and methods, JAC then provides   the required language elements for performing specific atomic computations at different degree of complexity and   sophistication.\nAtomic cascade computations: An atomic cascade typically includes ions (of one element) in three or more   different charge states. These charge states are connected to each other by different atomic processes, such as   photo ionization, radiative and dielectronic recombination, Auger decay, the photo excitation and emission, or various   others. In practice, moreover, the relative level population of these charge states is usually determined by the  specific set-up and geometry of the considered experiment. These cascade computations are usually based on some   predefined (cascade) approach that enables one to automatically select the state-space of the ions, to choose the   atomic processes to be considered for the various steps of the cascade, and to specify perhaps additional limitations  in order to keep the computations feasible. In addition, these cascade computations are generally divided into two  parts, the (cascade) computation for determining all necessary many-electron amplitudes and the (so-called)  simulations to combine the amplitudes due to the experimental scenario of interest.\nEmpirical computations: Not all atomic  properties and processes, such as the – single and multiple –   electron-impact ionization, stopping powers or tunnel ionization rates, can be efficiently described by ab-initio   many-body techniques. If needed, they are often easier computed by using empirical formulas and models.   A number of empirical computations are now supported to deal with such models; are often based on simple  electronic structure calculations, together with empirically obtained parameters. These computations are only   implemented when data are needed but no ab-initio computations of the involved processes appears to be feasible. \nPlasma computations: The notion of atoms and ions in plasma has been frequently applied to analyze the   behaviour of plasma in situations where the level structure and effective single-electron states remain partly   intact. Useful plasma computations refer to shifted photo lines, ionic mixtures in local and non-local   thermodynamic equilibria, or applications of the average-atom model.\nSymbolic evaluation of expressions from Racah's algebra: This kind refers to the algebraic transformation  and simplification of (Racah) expressions, which may generally include any number of Wigner n-j symbols   of different kind as well as (various integrals over) the spherical harmonics, the Wigner rotation matrices  and the Kronecker and triangular deltas. Of course, the complexity of such Racah expressions increases   very rapidly as more Wigner symbols are involved. A symbolic evaluation of these expressions is naturally   based on the knowledge of a large set of special values, orthogonality relations and sum rules that may include   rules with a (multiple) summation over dummy indices, cf. the monography by Varshalovich et al (1988).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Several other different kinds of computations have been prepared and will support the applications of the  JAC toolbox but come with a rather limited implementation so far.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Atomic responses: With this kind, we partly support computations in intense laser field; they also help   analyze the response of atoms to incident beams of light pulses and particles, such as field-induced   ionization processes, high-harmonic generation and several others. For these responses, the detailed   structure of atoms and ions has not been considered much until today. A partial-wave formulation of these   strong-field processes enables one to clearly distinguish between contributions due to the atomic target,  the Volkov states, or the shape and phase of the incident light.\nAtomic time-evolution of statistical tensors: We here wish to simulate the population and coherences  of (atomic) levels using the Liouville equation, when atoms and ions are irradiated by (intense) light  pulses. For these computations, however, we shall assume always that the level structure of the atoms is kept   intact. Further (decay) processes of the excited atoms and ions can be taken into account by some loss   rate, but without that the atoms can leave the pre-specified space of sublevels. In particular, we here   plan to consider the interaction of atoms and ions with pulses of different shape, polarization strength   and duration.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The development version of JAC can installed installed directly in the interactive Julia REPL (Read-Eval-Print-Loop) Press ] to enter the Julia package mode and type add https://github.com/OpenJAC/JAC.jl to install JAC.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]\n(@v1.10) pkg> add https://github.com/OpenJAC/JAC.jl","category":"page"},{"location":"index.html#Development","page":"Home","title":"Development","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"As a Scientific package users are encouraged to explore the capabilities of JAC, and modify the package as per their requirement. JAC comes with an MIT 'Expat' License.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For development purpose, user can install JAC from GitHub to their desired direcory using git clone in the terminal. This will download a copy of JAC from the development branch of GitHub repository.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"git clone https://github.com/OpenJAC/JAC.jl.git","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Next cd to the JAC.jl directory and start a new Julia session","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"shell> cd JAC.jl\nshell> julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Then activate the JAC.jl environment and install the dependancy packages of JAC.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]                   # Change to the Julia package mode\n(@v1.10) pkg> activate .\n(JAC) pkg> instantiate     # Installs the dependancy packages of JAC\n(JAC) pkg> resolve         # Required **Only if** there is a cinflict in the dependancies\n(JAC) pkg> develop .       # Adds the current directory path to Julia local Registry","category":"page"},{"location":"index.html#User-Guide-and-Manual","page":"Home","title":"User Guide and Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A detailed User Guide, Compendium & Theoretical Background to JAC  is available that describes the use and underlying atomic theory of the JAC code.","category":"page"},{"location":"contributors.html#Developers:","page":"Contributors","title":"Developers:","text":"","category":"section"},{"location":"contributors.html","page":"Contributors","title":"Contributors","text":"Fritzsche, Stephan, s.fritzsche@gsi.de (U Jena, Germany)\nSahoo, Aloka Kumar, aloka_s@ph.iitr.ac.in (HI Jena, Germany)\nHuang, Houke (Institute of Modern Physics, Lanzhou, China)\nWang, Wu (HI Jena, Germany & U Haikou, China)\nLi, Bowen (U Lanzhou, China)","category":"page"},{"location":"contributors.html#(Former)-Supporters:","page":"Contributors","title":"(Former) Supporters:","text":"","category":"section"},{"location":"contributors.html","page":"Contributors","title":"Contributors","text":"Böning, Birger (HI Jena, Germany)\nDar, Danish F. (U Jena, Germany)\nGaigalas, Gediminas (U Vilnius, Lithuania)\nGilles, Jan (PTB Braunschweig, Germany)\nHofbrucker, Jiri (U Jena, Germany)\nJiao, Li-Guang (HI Jena, Germany & Jilin U Changchun, China)\nSchippers, Stefan (U Giessen, Germany)\nSienkiwicz, Joseph (TU Gdansk, Poland)\nSurzhykov, Andrey (U Braunschweig, Germany)\nVolotka, Andrey (HI Jena, Germany & St. Petersburg, Russia)\nWang, Yuan-Cheng (HI Jena, Germany & U Shenyang, China)\nWu, Zhongwen (HI Jena, Germany & U Lanzhou, China)","category":"page"},{"location":"getting-started-jac.html#Getting-started-with-JAC-(in-REPL)","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"","category":"section"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"info: Info\nJAC user guide pdf .... link","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"using JAC","category":"page"},{"location":"getting-started-jac.html#Welcome-to-**JAC**,-the-**Jena-Atomic-Calculator**","page":"Getting started with JAC (in REPL)","title":"Welcome to JAC, the Jena Atomic Calculator","text":"","category":"section"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"... that provides various tools for performing atomic (structure) calculations of different kinds and complexities. Apart from the computation of atomic (many-electron) amplitudes, properties and processes, JAC supports interactive, restricted-active space (RAS) and cascade computations. It also help perform a few simple hydrogenic and semi-empirical estimates as well as simplify symbolic expressions from Racah's algebra. –- Let's first use  ? JAC in order to obtain more information about this toolbox:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"? JAC","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"JAC","category":"page"},{"location":"getting-started-jac.html#JAC-getting-started-jac","page":"Getting started with JAC (in REPL)","title":"JAC","text":"module JAC       ... Jena Atomic Calculator (JAC) provides tools for performing atomic (structure) calculations at various degrees of complexity          and sophistication. It has been designed to not only calculate atomic level structures and properties [such as g-factors or         hyperfine and isotope-shift parameters] but also transition amplitudes between bound-state levels [for the anapole moment, dipole          operator, electron electric-dipole moment, parity non-conservation, etc.] and, in particular, (atomic) transition probabilities,          Auger rates, photoionization cross sections, radiative and dielectronic recombination rates as well as cross sections for many          other (elementary) processes. JAC also facilitates interactive computations, the simulation of atomic cascades, the time-evolution          of statistical tensors, a few semi-empirical estimates of atomic properties as well as the simplification of symbolic expressions         from Racah's algebra. – In addition, the JAC module supports the display of level energies, electron and photon spectra,          radial orbitals and other atomic data.\n\nPerform (atomic) computations of different complexity:       JAC will eventually support ten kinds of computations which can be summarized as follows:\n\nAtomic computations, based on explicitly specified electron configurations.\nRestricted active-space computations (RAS).\nInteractive computations.\nAtomic cascade computations (partly implemented).\nAtomic representations (Green and close-coupling functions, complex rotation; partly implemented).\nAtomic responses (partly implemented).\nAtomic descriptors for machine learning algorithms (not yet implemented).\nTime-evolution of statistical tensors in (intense) light pusles (not yet implemented).\nSemi-empirical estimates of cross sections, etc. (partly implemented).\nSymbolic evaluation of expressions from Racah's algebra, etc.\n\nFurther details and information\n\n    + Kinds of atomic implementation                                       [cf. ? Details.kindsOfComputation]\n    + Atomic amplitudes (partly) implemented in JAC                        [cf. ? Details.amplitudes]\n    + Atomic level properties (partly) implemented in JAC                  [cf. ? Details.properties]\n    + Atomic processes (partly) implemented in JAC                         [cf. ? Details.processes]\n    + Interactive use of JAC procedures                                    [cf. ? Details.interactive]\n    + Design principles and limitations of the JAC program                 [cf. ? Details.design]\n    + Data types, structs and name conventions of the JAC module           [cf. ? Details.datatypes]\n    + Atomic cascade computations and approximations                       [cf. ? Details.decayCascades]\n    + Use of (em) light pulses in the time evolution of statist. tensors   [cf. ? Details.pulses]\n    + Why Julia ?                                                          [cf. ? Details.whyJulia]\n\n\n\n\n\n","category":"module"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"H'm, this tells us a lot of details which we still need to better understand. To quickly list the atomic properties, that have been (partly) considered in JAC, we can use ? Details.properties   or some other of the listed calls:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"? Details.properties","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Details.properties","category":"page"},{"location":"getting-started-jac.html#JAC.Details.properties-getting-started-jac","page":"Getting started with JAC (in REPL)","title":"JAC.Details.properties","text":"Atomic properties\n\nApart from approximate level energies and eigenvectors, JAC (will) support the computation of the following level properties:\n\nAlphaX        ... alpha variations; differential sensitivity parameters.\nEinstein      ... Einstein A, B coefficients and oscillator strength; although these coefficients are not an                    original level property, the Einstein module treats these computations within a single                    basis/multiplet and, hence, cannot include relaxation effects, etc. The Einstein                    feature of JAC can be used, however, for a quick overview to transition probabilities                    or in order to simplify cascade computations.\nFormF         ... Standard and modified atomic form factors.\nGreens        ... Greens function of an atomic level.\nHFS           ... Hyperfine A and B parameters.\nIsotope       ... Isotope shift M and F parameters.\nLandeJ        ... Lande g_J factors.\nLandeF        ... Lande g_F factors.\nPolarity      ... Static and dynamic polarizibilities of atomic levels.\nPlasma        ... CI computations including interactions from various plasma models.\nYields        ... Fluoerescence and Auger yields of atomic levels.\n\n\n\n\n\n","category":"function"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"In the design of JAC, we first of all aim for a precise language that (i) is simple enough for both, seldom and a more frequent use of this package, (ii) highlights the underlying physics and (iii) avoids most technical slang that is often unnecessary but quite common to many other codes. An intuitive picture about the level or hyperfine structure of an atom, its properties as well as possible excitation and/or decay processes should (always) come first in order to generate the desired data: By making use of suitable data types (struct), we indeed wish to introduce a language close to the underlying formalism. –- While JAC is overall based on a rather large number ( 300) of such types, a few simple examples are:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"(atomic) Shell:                 quad1s, 2s, 2p, ...\nSubshell:                       quad1s1/2, 2s1/2, 2p1/2, 2p3/2, ...\n(electron) Configuration:       quad1s^2 2s^2 2p^6 3s quad  or quad  [Ne] 3s, ...\nLevel:                          quad1s^2 2s^2  ^1S_0, ...","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"and many other terms (types) that we shall explain later.  ","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Let us simply start, for instance, with specifying and assigning the 1s and 2p shells:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"w1s = Shell(\"1s\")\nw2p = Shell(\"2p\")","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Similarly, we can readily specify and assign any (relativistic) subshell:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Subshell(\"2p_1/2\"),   Subshell(\"2p_3/2\")  ","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"In JAC, we make use of these Shell's and Subshell's whenever they will naturally occur in describing the level structure or the excitation, decay or occupation of an atom, and this both at input and output. If you have forgotten how to specify such a subshell (constructor), simply ask:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"? Subshell","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Subshell","category":"page"},{"location":"getting-started-jac.html#JAC.Basics.Subshell-getting-started-jac","page":"Getting started with JAC (in REPL)","title":"JAC.Basics.Subshell","text":"struct  Basics.Subshell  ... defines a type for the allowed values of a relativistic subhell.  \n\n+ n        ::Int64  ... principal quantum number \n+ kappa    ::Int64  ... relativistic angular quantum number\n\n\n\n\n\n","category":"type"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Of course, we can interactively also specify any electron configuration:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"? Configuration","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"wc1 = Configuration(\"1s^2 2s^2 2p^5\")\nwc2 = Configuration(\"[Ar] 4s^2 3d^5\")","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"info: Info\nFor specific processes users can find the list of types and functions in the API Reference","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"This input just shows three (very) simple examples and how the details of some computation can be readily specified in line with our basic understanding of the atomic shell model. One can use  ? Details.datatypes  in order to see a more complete list of most data structures that are speficic to the JAC module ... and which will give you a very first impression about the size of the JAC program.","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"? Details.datatypes","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Details.datatypes","category":"page"},{"location":"getting-started-jac.html#JAC.Details.datatypes-getting-started-jac","page":"Getting started with JAC (in REPL)","title":"JAC.Details.datatypes","text":"Data types, structs and name conventions of the JAC module\n\nThe use of a proper terminology and data structures has been found essential for developing the JAC module. Below, we list and briefly explain these data types and how they appear in atomic theory. Although we presently support just a (small) number of frequently requested tasks in  atomic structure and collision theory, we tried to define data types that are flexible enough to further extend these tools in the future. Following the Julia's standard conventions, all types (struct) are named in CamelCase notation.\n\nAbstract data types\n\nAbstractExcitationScheme     ... supports the selection of various (singleton) excitation schemes.\nAbstractQedModel             ... supports the selection of various (singleton) QED models.\n\nBasic data types\n\nAngularJ64                   ... (positive, half-integer) angular momentum, j = 0, 1/2, 1, 3/2, ... .\nAngularM64                   ... (half-integer) projection of ang. momentum, m = -1/2, 0, 1/2, ... can be initialized also                                   w.r.t AngularJ64().\nCartesianVector              ... Cartesian vector of given type.\nContinuumNormalization       ... method for dealing with the normalization of continuum orbitals.\nContinuumPhase               ... method for determining the phase of continuum orbitals.\nContinuumSolutions           ... method for solving continuum orbitals.\nEigen                        ... represents eigenvalues and eigenvectors if different diagonalization procedures are used.\nEmMultipole                  ... a multipole of the em field.\nEmGauge                      ... an allowed gauge form for the em field, for instance, Coulomb, Babushkin, Magnetic, ...\nEmProperty                   ... a given property in Coulomb (velocity) as well as Babushkin (length) gauge.\nEmStokes                     ... (computed) Stokes parameter for the polarization of emitted radiation.\nExpStokes                    ... (experimentally) given Stokes parameter for the polarization of incoming radiation.\nGuint                        ... specifier for dealing with graphical user interfaces (GUI).\nLevelKey                     ... data type for identifying a level by its symmetry, energy, etc.\nLevelSymmetry                ... total level symmetry (J, parity).\nLineKey                      ..  data type for identifying a line by the keys of the initial and final level, ...\nModel                        ... to keep the all nuclear parameters.\nParity                       ... standard parity values\nShell                        ... a non-relativistic shell.\nSolidAngle`                  ... defines a type for a solid angle Omega = (theta, phi).\nSubshell                     ... a relativistic subshell.\nSubshellStateR               ... a relativistic antisymmetric subshell state within the seniority scheme.\nTensorComp                   ... component of the statistical tensor as associated with an atomic level. \nUseGauge                     ... an allowed gauge form requested for explicit computations: UseCoulomb or UseBabushkin.\nWarnings                     ... for dealing with warnings that are made during a run or REPL session.\nWeightedCartesian            ... Cartesian vector with weight factor of given type.\n\nData types from many-electron theory\n\nAsfSettings                  ... settings for SCF and CI computations.\nAtomic.Computation           ... atomic computation of a multiplet, including the SCF, CI and transition properties.\nBasis                        ... (relativistic) atomic basis, including the configuration space and radial orbitals.\nBspline                      ... set of B-splines.\nConfiguration                ... (non-relativistic) electron configuration as specified by its shells and their occupation.\nConfigurationR               ... (relativistic) electron configuration as specified by its subshells and their occupation.\nLevel                        ... atomic level in terms of its quantum number, energy and a (possible) representation.\nMultiplet                    ... an ordered list of atomic levels with a name.\nOrbital                      ... (relativistic) radial orbital function that appears as 'building block' to define many-electron                                    states; more often than not, it just occurs as radial orbital on a given (radial) grid while the                                    angular dependence is given by the subshell label.\nQedPetersburg                ... singleton data type for selecting QED calculations a la St. Petersburg.\nQedSydney                    ... singleton data type for selecting QED calculations a la Sydney.\nNoneQed                      ... singleton data type if no QED corrections are to be calculated.                 \nRadial.Grid                  ... radial grid to represent the (radial) orbitals.\nRadial.Potential             ... radial potential function.\nRadial.Primitives            ... a list of radial functions, that may serve as a set of primitives in SCF computations, together                                    with several parameters for its definition.\nRadial.SingleSymOrbitals     ... a list of radial orbitals with large and small component but of the same symmetry (kappa); such a                                    list may serves as (complete) single-electron basis to deal with second- and higher-order processes.\n\nData types calculating level properties\n\nAbstractLevelProperty        ... an atomic level property that is supported by the JAC module, such as HFS, IsotopeShift, ....\nEinstein.Settings            ... settings for Einstein A and B coefficients, calculated within a single given Multiplet.\nEinstein.Outcome             ... (results of the) Einstein A and B coefficients for a single line.\nHfs.Settings                 ... settings for HFS A and B coefficients.\nHfs.Outcome                  ... (results of the) HFS A and B coefficients for a single level.\nIsotopeShift.Outcome         ... (results of the) M and F isotope-shift parameters for a single level.\nIsotopeShift.Settings        ... settings for the M and F isotope-shift parameters.\nLandeZeeman.sublevelJ        ... specifies a magnetic sublevel with well-defined J.\nLandeZeeman.sublevelF        ... specifies a magnetic hyperfine sublevel with well-defined F, M_f.\nLandeZeeman.Outcome          ... (results of the) Lande factors and Zeeman splittings for a single level.\nLandeZeeman.Settings         ... settings for the Lande factors and Zeeman splitting in an external magnetic field.\n\nData types for calculating (time-independent) atomic processes\n\nAtomicProcess                     ... an atomic process that is supported by the JAC module, such as Auger, photo, ....\nAlphaVariation.Outcome            ... outcome of a alpha-variation computation, such as the K enhancement.\nAlphaVariation.Settings           ... seetings for computing alpha variation parameters.\nAuger.Channel                     ... Auger channel of well-defined energy and partial outgoing wave.\nAuger.Line                        ... Auger line between (two) specified initial- and final-state levels and with (possible) subchannels.\nAuger.Settings                    ... settings for computing Auger lines.\nCoulombExcitation.Channel         ... Coulomb excitation channel of well-defined energy and partial wave.\nCoulombExcitation.Line            ... Coulomb excitation line with (possible) subchannels.\nCoulombExcitation.Settings        ... settings for computing Coulomb excitation  lines.\nCoulombIonization.Channel         ... Coulomb ionization channel of well-defined energy and partial wave.\nCoulombIonization.Line            ... Coulomb ionization line with (possible) subchannels.\nCoulombIonization.Settings        ... settings for computing Coulomb ionization  lines.\nDielectronic.Channel              ... dielectronic-recombination channel of well-defined multipolarity and gauge as well as energy and                                        partial incoming wave.\nDielectronic.Line                 ... dielectronic recombination line between (three) specified initial-, intermediate and final-state                                        levels and with (possible) subchannels.\nDielectronic.Resonance            ... single dielectronic resonance that summarizes all Dielectronic.Line's for some fixed intermediate                                       level within the continuum. \nDielectronic.Settings             ... settings for computing dielectronic recombination lines.\nDecayYield.Outcome                ... outcome of a decay yield computation.\nDecayYield.Settings               ... settings for computing decay yields lines.\nDoubleAutoIonization.Channel      ... DoubleAutoIonization channel of two partial outgoing waves with well-defined energy.\nDoubleAutoIonization.Line         ... DoubleAutoIonization line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.\nDoubleAutoIonization.Settings     ... settings for computing DoubleAutoIonization lines.\nDoublePhotoIonization.Channel     ... DoublePhotoIonization channel of two partial outgoing waves with well-defined energy.\nDoublePhotoIonization.Line        ... DoublePhotoIonization line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.\nDoublePhotoIonization.Settings    ... settings for computing DoublePhotoIonization lines.\nImpactExcitation.Channel          ... electron-impact excitation channel of well-defined energies. partial waves and phases of the                                        incoming and outgoing electrons.\nImpactExcitation.Line             ... electron-impact excitation line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.\nImpactExcitation.Settings         ... settings for computing electron-impact excitation lines.\nImpactExcitationAutoion.Channel   ... electron-impact excitation channel of well-defined energies, partial waves and phases of the                                        incoming and outgoing electrons.\nImpactExcitationAutoion.Pathway   ... electron-impact excitation line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.\nImpactExcitationAutoion.Settings  ... settings for computing electron-impact excitation lines.\nImpactIonization.Channel          ... electron-impact ionization channel of well-defined energies, partial waves and phases of the                                        incoming and outgoing electrons.\nImpactIonization.Line             ... electron-impact ionization line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.\nImpactIonization.Settings         ... settings for computing electron-impact ionization lines.\nMultiPhotonDeExcitation.Channel   ... multi-photon excitation or decay channel with well-defined multipolarities and gauge.\nMultiPhotonDeExcitation.Line      ... multi-photon excitation or decay line between (two) specified initial- and final-state levels                                        and with (possible) subchannels.\nMultiPhotonDeExcitation.Settings  ... settings for computing multi-photon excitation or decay lines.\nMultiPhotonIonization.Channel     ... multi-photon ionization channel with well-defined multipolarities, gauge as well as energy and                                        partial wave of the outgoing electron.\nMultiPhotonIonization.Line        ... multi-photon ionization line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.\nMultiPhotonIonization.Settings    ... settings for computing multi-photon ionization lines.\nMultiPhotonDoubleIon.Channel      ... multi-photon double ionization channel with well-defined multipolarities, gauge as well as energy                                       and partial waves of the (two) outgoing electrons.\nMultiPhotonDoubleIon.Line         ... multi-photon double ionization line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.\nMultiPhotonDoubleIon.Settings     ... settings for computing multi-photon double ionization lines.\nPairAnnihilation1Photon.Channel   ... positron-bound-electron pair annihilation (PEPA) with single-photon emission channel of                                        well-defined multipolarity, gauge as well as energy and partial incoming (positron) wave.\nPairAnnihilation1Photon.Line      ... PEPA with single-photon emission line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.\nPairAnnihilation1Photon.Settings  ... settings for computing PEPA with single-photon emission lines.\nPairAnnihilation2Photon.Channel   ... positron-bound-electron pair annihilation (PEPA) with two-photon emission channel of well-defined                                        multipolarities, gauge as well as energy and partial incoming (positron) wave.\nPairAnnihilation2Photon.Line      ... PEPA with two-photon emission line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.\nPairAnnihilation2Photon.Settings  ... settings for computing PEPA with two-photon emission lines.\nPairProduction.Channel            ... positron-bound-electron pair production (PEPP) by single-photon absorption channel of well-defined                                        multipolarity, gauge as well as energy and partial outgoing (positron) wave.\nPairProduction.Line               ... PEPP by single-photon absorption line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.\nPairProduction.Settings           ... settings for computing PEPP lines.\nPhotoExcitation.Line              ... photoexcitation line between (two) specified initial- and final- state levels and with (possible                                       JAC.PhotoEmission.Channel) subchannels.\nPhotoExcitation.Settings          ... settings for computing photoexcitation lines.\nPhotoExcitationAutoion.Channel    ... photo-excitation autoionization channel of well-defined energies of the incoming photon as well as                                        the partial wave and phase of the outgoing electron.\nPhotoExcitationAutoion.Pathway    ... photo-excitation autoionization pathways between (three) specified initial-, intermediate and                                        final-state levels and with (possible) subchannels.\nPhotoExcitationAutoion.Settings   ... settings for computing photo-excitation autoionization pathways.\nPhotoIonization.Channel           ... photoionization channel of well-defined multipolarity, gauge as well as energy and partial                                        outgoing wave.\nPhotoIonization.Line              ... photoionization line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.\nPhotoIonization.Settings          ... settings for computing photoionization lines.\nPhotoRecombination.Channel        ... Rec channel of well-defined multipolarity and gauge as well as energy and partial incoming wave.\nPhotoRecombination.Line           ... radiative electron capture line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.\nPhotoRecombination.Settings       ... settings for computing radiative electron capture lines.\nPhotoEmission.Channel                 ... radiative channel of well-defined multipolarity and gauge.\nPhotoEmission.Line                    ... radiative line between (two) specified initial- and final-state levels and with (possible) sublines.\nPhotoEmission.Settings                ... settings for computing radiative lines.\nRadiativeAuger.Channel            ... RadiativeAuger channel of a partial outgoing waves and one photon with well-defined energy.\nRadiativeAuger.Line               ... RadiativeAuger line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.\nRadiativeAuger.Settings           ... settings for computing RadiativeAuger lines.\nRadiative.Settings                ... settings for computing radiative lines.\nRayleighCompton.Channel           ... RayleighCompton channel of an incoming and outgoing photon with well-defined energy.\nRayleighCompton.Line              ... RayleighCompton line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.\nRayleighCompton.Settings          ... settings for computing RayleighCompton lines.\nREDA.Channel                      ... resonant electron-excitation (sequential) double-autoionization (REDA) channel of well-defined                                        energies, partial waves and phases of the incoming and outgoing electrons.\nREDA.Pathway                      ... resonant electron-excitation (sequential) double-autoionization (REDA) pathways.between (four)                                        specified initial-, (two) intrmediate and final-state levels and with (possible) subchannels.\nREDA.Settings                     ... settings for computing resonant electron-excitation (sequential) double-autoionization (REDA)                                        pathways.\n\nData types for calculating (time-dependent) atomic processes\n\nPulse.Envelope                       ... defines a type for the envelope (function) of an em pulse with well-defined time delay,                                            amplitude and (normalized) shape function.\nPulse.ExperimentalCharacterization   ... to characterized an experimental or physically described em pulse in terms of its                                            propagation direction, frequency, maximum intensity, pulse length or No. of cycles, time-delay,                                            polarization, etc., i.e. of what is easily accesssible by an experiment.\nPulse.Gaussian                       ... a Gaussian light pulse that is used for evaluating time-dependent statistical tensors.\nPulse.Polarization                   ... defines the polarization of an em pulse in terms of its linear and circular degrees, the                                            direction of the polarization vector or some generalized polarization coefficients.\nPulse.PolarizationType               ... defines the polarization of an experimentally described light pulse as linear, left-circular, ..\nPulse.Shape                          ... defines a shape of a general em pulse as Gaussian, SineSquared, etc.\nPulse.SineSquared                    ... a SinSquared light pulse that is used for evaluating time-dependent statistical tensors.\n\nData types for dealing wiht (time-dependent) statistical tensors\n\nStatistical.ResonanceR      ... a resonance state in the continuum with a well-defined bound-ionic core, one or several electrons                                    in the continuum, a widths as well as a loss rate due to additional decay processes that cannot be                                    accounted for explicitly.\nStatistical.Tensor          ... represents a statistical tensor of given rank k, projection q and which generally depends upon two                                    resonances.\n\nData types for advanced computations\n\nAtomic.CasComputation          ... an individual or a series of systematically enlarged SCF computations.\nAtomic.CasStep                 ... single-step in an (systematically enlarged) SCF calculation.\nAtomic.CasSettings             ... settings for CAS computation.\nCascade.Approach               ... a particular (computational) approach in which a cascade is considered.\nCascade.Block                  ... a block of configurations that are treatet together within a given cascade. \nCascade.Data                   ... all transition data of a cascade as given by a list of lines (of different type).\nCascade.Computation            ... definition of an atomic exciation/decay cascade from which the actual computations can be derived.\nCascade.Level (mutable)        ... defines a level specification for dealing with cascade transitions.\nCascade.LineIndex              ... defines a line index with regard to the various lineLists of data::Cascade.Data.\nCascade.Step                   ... an individual step of a Cascade.Computation that generally combines two ionization states of ions.\nCascade.Simulation             ... simulation of cascade data.\nCascade.SimulationSettings     ... defines settings for performing the simulation of some cascade (data).\nCascade.Settings               ... settings for cascade computations (not yet).\n\n\n\n\n\n","category":"function"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"This list gives further details why Julia (and JAC) is a very suitable and powerful framework for running – many-electron – atomic computations. ","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Of course, there are many other features that make Julia & JAC as powerful as it is: For example, the user may pre-define and overwrite the units in which he wishes to communicate with JAC. These units determine how (most of) the input data are interpreted as well as output data are displayed in tabulations or to screen. The current defaults settings for the units can be seen by typing:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Basics.display(\"settings\")","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"which show that energies are taken/printed in eV, rates in 1/s, etc. Apart from modifying these defaults directly in the source code, the can be overwritten by the user at any time of the program executation. This is done by means of the function","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"? Defaults.setDefaults","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Defaults.setDefaults","category":"page"},{"location":"getting-started-jac.html#JAC.Defaults.setDefaults","page":"Getting started with JAC (in REPL)","title":"JAC.Defaults.setDefaults","text":"Defaults.setDefaults()       ... (re-) defines some 'standard' settings which are common to all the computations with the JAC module, and which can          be 'overwritten' by the user. –- An improper setting of some variable may lead to an error message, if recognized         immediately. The following defaults apply if not specified otherwise by the user: the framework is 'relativistic',          energies are given in eV and cross sections in barn. Note that, internally, atomic units are used throughout for          all the computations within the program. nothing is returned if not indicated otherwise.\n\n+ (\"framework: relativistic\")  or  (\"framework: non-relativistic\")\n\n... to define a relativistic or non-relativistic framework for all subsequent computations.\n\n(\"method: continuum, spherical Bessel\")  or  (\"method: continuum, pure sine\")  or     (\"method: continuum, asymptotic Coulomb\")  or  (\"method: continuum, nonrelativistic Coulomb\")  or     (\"method: continuum, Galerkin\")     ... to define a a method for the generation of the continuum orbitals as (pure) spherical Bessel, pure sine,       asymptotic Coulomb, nonrelativistic Coulomb orbital or by means of the B-spline-Galerkin method.\n(\"method: normalization, pure sine\")  or  (\"method: normalization, pure Coulomb\")  or  (\"method: normalization, Ong-Russek\")      ... to define a method for the normalization of the continuum orbitals as asymptotically (pure) sine or Coulomb        functions, or following the procedure by Ong & Russek (1978).\n(\"QED model: Petersburg\")  or  (\"QED model: Sydney\")      ... to define a model for the computation of the QED corrections following the work by Shabaev et al. (2011; Petersburg)        or Flambaum and Ginges (2004; Syney).\n(\"unit: energy\", \"eV\")  or  (\"unit: energy\", \"Kayser\")  or  (\"unit: energy\", \"Hartree\")  or     (\"unit: energy\", \"Hz\")  or  (\"unit: energy\", \"Hz\")     ... to (pre-) define the energy units for all further printouts and communications with the JAC module.\n(\"unit: cross section\", \"a.u.\")  or  (\"unit: cross section\", \"barn\")  or  (\"unit: cross section\", \"Mbarn\")     ... to (pre-) define the unit for the printout of cross sections.\n(\"unit: rate\", \"a.u.\")  or  (\"unit: rate\", \"1/s\")  ... to (pre-) define the unit for the printout of rates.\n(\"unit: resonance strength\", \"a.u.\")  or  (\"unit: resonance strength\", \"barn eV\")  or     (\"unit: resonance strength\", \"cm^2 eV\")  ... to (pre-) define the unit for the printout of resonance strengths.\n(\"unit: time\", \"a.u.\")  or  (\"unit: time\", \"sec\")  or  (\"unit: time\", \"fs\")  or  (\"unit: time\", \"as\")     ... to (pre-) define the unit for the printout and communications of times with the JAC module.\n\n\n\n\n\n(\"relativistic subshell list\", subshells::Array{Subshell,1}; printout::Bool=true)     ... to (pre-) define internally the standard relativistic subshell list on which the standard order of orbitals is based.\n\n\n\n\n\n(\"standard grid\", grid::Radial.Grid; printout::Bool=true)     ... to (pre-) define internally the standard radial grid which is used to represent most orbitals.\n\n\n\n\n\n(\"continuum: potential\", scField::Basics.AbstractScField)     ... to (re-) define the potential that is applied for the generation of the continuum orbitals.\n\n\n\n\n\n(\"QED: damped-hydrogenic\", Znuc::Float64, wa::Array{Float64,1})     ... to (re-) define the lambda-C damped overlap integrals of the lowest kappa-orbitals        [ wa1s1/2, wa2p1/2, wa2p3/2, wa3d3/2, wa3d5/2 ] for the (new) nuclear charge Znuc;        nothing is returned.\n\n\n\n\n\n","category":"function"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"which enables one to re-define various global values of JAC. If we wish to enter/display energies in Kaysers or cross sections in atomic units, we can simply type:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Defaults.setDefaults(\"unit: energy\", \"Kayser\")\nDefaults.setDefaults(\"unit: cross section\", \"a.u.\")","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Here, again nothing is returned but the corresponding global constants are now changed.","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Basics.display(\"settings\")","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Apart from the default units, one can similarly overwrite the method that is use for the generation and normalization of continuum orbitals and several others. Although called global, the corresponding values can be accesses just in two ways. (i) The global constants, such as the electron mass, the speed of light, the fine-structure constant alpha, etc., are accessed via the function:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"? Defaults.getDefaults","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Defaults.getDefaults","category":"page"},{"location":"getting-started-jac.html#JAC.Defaults.getDefaults","page":"Getting started with JAC (in REPL)","title":"JAC.Defaults.getDefaults","text":"Defaults.getDefaults()       ... gives/supplies different information about the (present) framework of the computation or about some          given data; cf. Defaults.setDefaults(). \n\n(\"alpha\")  or  (\"fine-structure constant alpha\")      ... to get the (current) value::Float64 of the fine-structure constant alpha.\n(\"electron mass: kg\")  or  (\"electron mass: amu\")     ... to get the (current) value::Float64 of the electron mass in the specified unit.\n(\"framework\")  ... to give the (current) setting::String  of the overall framework.\n(\"electron rest energy\")  or  (\"mc^2\")  ... to get the electron rest energy.\n(\"electron g-factor\")  ... to give the electron g-factor g_s = 2.00232.\n(\"unit: energy\")  or  (\"unit: cross section\")  or  (\"unit: rate\")  or  (\"unit: strength\")  or  (\"unit: time\")     ... to get the corresponding (user-defined) unit::String for the current computations.\n(\"standard grid\")     ... to get the (current standard) grid::Array{Float64,1} to which all radial orbital functions usually refer.\n(\"speed of light: c\")  ... to get the speed of light in atomic units.\n(\"summary flag/stream\")     ... to get the logical flag and stream for printing a summary file; a tupel (flag, iostream) is returned.\n\n\n\n\n\n(\"ordered shell list: non-relativistic\", n_max::Int64)     ... to give an ordered list of non-relativistic shells::Array{Shell,1} up to the (maximum) principal number n_max.\n(\"ordered subshell list: relativistic\", n_max::Int64)      ... to give an ordered list of relativistic subshells::Array{Subshell,1} up to the (maximum) principal number n_max.\n\n\n\n\n\n","category":"function"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Defaults.getDefaults(\"alpha\")\nDefaults.getDefaults(\"electron rest energy\")\nDefaults.getDefaults(\"unit: energy\")","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"(ii) These global values are frequently applied in order to – internally or externally – convert physical numbers into units of the same dimension. This is done by the function:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"? Defaults.convertUnits","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Defaults.convertUnits","category":"page"},{"location":"getting-started-jac.html#JAC.Defaults.convertUnits","page":"Getting started with JAC (in REPL)","title":"JAC.Defaults.convertUnits","text":"Defaults.convertUnits()       ... converts some data from one format/unit into another one; cf. the supported keystrings and return values.\n\n(\"cross section: from atomic to predefined unit\", value::Float64)  or  (\"cross section: from atomic\", value::Float64)     ... to convert an cross section value from atomic to the predefined cross section unit; a Float64 is returned.\n(\"cross section: from barn to atomic unit\", value::Float64)    ... to convert an cross section value from barn atomic section unit; a Float64 is returned.\n(\"cross section: from atomic to barn\", value::Float64)  or  (\"cross section: from atomic to Mbarn\", value::Float64)  or   (\"cross section: from atomic to cm^2\", value::Float64)    ... to convert an energy value from atomic to the speficied cross section unit; a Float64 is returned.\n(\"cross section: from predefined to atomic unit\", value::Float64)  or  (\"cross section: to atomic\", value::Float64)   ... to convert a cross section value from the predefined to the atomic cross section unit; a Float64 is returned.\n(\"einstein B: from atomic\", value::Float64)     ... to convert a Einstein B coefficient from atomic to the speficied energy units; a Float64 is returned.\n(\"density: from [g/cm^3] to atomic\", value::Float64)     ... to convert a mass density from [g/cm^3] to atomic units [u/a_o^3]; a Float64 is returned.\n(\"energy-diff. cross section: from atomic to predefined unit\", value::Float64)  or     (\"energy-diff. cross section: from atomic\", value::Float64)     ... to convert an energy-diff. cross section value from atomic to the predefined energy-diff. cross section unit;        a Float64 is returned.\n(\"energy: from atomic to eV\", value::Float64)  or  (\"energy: from atomic to Kayser\", value::Float64)    or   (\"energy: from atomic to Hz\", value::Float64)  or  (\"energy: from atomic to Angstrom\", value::Float64)  or   (\"energy: from atomic to Ws\", value::Float64)   ... to convert an energy value from atomic to the speficied energy unit; a Float64 is returned.\n(\"energy: from predefined to atomic unit\", value::Float64)  or  (\"energy: to atomic\", value::Float64)... to convert an energy value                                                from the predefined to the atomic energy unit; a Float64 is returned.\n(\"energy: from eV to atomic\", value::Float64) ... to convert an energy value from eV to the atomic energy unit; a Float64 is returned.\n(\"energy: from wavelength [nm] to atomic\", value::Float64) ... to convert a wavelength [nm] to the atomic energy unit; a Float64 is returned.\n(\"intensity: from W/cm^2 to atomic\", value::Float64) ... to convert the intensity [in W/cm^2] to the atomic intensity unit; a Float64 is returned.\n(\"kinetic energy to wave number: atomic units\", value::Float64)  ... to convert a kinetic energy value (in a.u.) into a wave number                                               k (a.u.); a Float64 is returned.\n(\"kinetic energy to wavelength: atomic units\", value::Float64)  ... to convert a kinetic energy value (in a.u.) into a wavelength (a.u.);                                                a Float64 is returned.\n(\"length: from fm to atomic\", value::Float64)  ... to convert a length value (in fm) into a.u.;  a Float64 is returned.\n(\"length: from atomic to fm\", value::Float64)  or  (\"energy: from atomic to Kayser\", value::Float64)     ... to convert a length value (in Bohr's a.u.) to the speficied length unit;  a Float64 is returned.\n(\"rate: from atomic to predefined unit\", value::Float64)  or  (\"rate: from atomic\", value::Float64)  ... to convert a rate value                                            from atomic to the predefined rate unit; a Float64 is returned.\n(\"rate: from atomic to 1/s\", value::Float64)  ... to convert an rate value from atomic to the speficied rate unit; a Float64 is returned.\n(\"rate: from predefined to atomic unit\", value::Float64)  or  `(\"rate: to atomic\", value::Float64)'... to convert a                                               rate value from the predefined to the atomic rate unit; a Float64 is returned.\n\n(\"strength: from atomic to predefined unit\", value::Float64)  or  (\"strength: from atomic\", value::Float64)  ... to convert a (resonance)                                                strength value from atomic to the predefined rate unit; a Float64 is returned.\n(\"time: from atomic to predefined unit\", value::Float64)  or  (\"time: from atomic\", value::Float64)  ... to convert an time value                                            from atomic to the predefined time unit; a Float64 is returned.\n(\"time: from atomic to sec\", value::Float64)  or  (\"time: from atomic to fs\", value::Float64)'  or(\"time: from atomic to as\", value::Float64)`  ... to convert a time value from atomic to the speficied time unit; a Float64 is returned.\n(\"time: from predefined to atomic unit\", value::Float64)  or  `(\"time: to atomic\", value::Float64)'  ... to convert a                                           time value from the predefined to the atomic time unit; a Float64 is returned.\n(\"temperature: from Kelvin to (Hartree) units\", value::Float64)  ... to convert a temperature in Kelvin into atomic (Hartree) units;                                                a Float64 is returned.\n(\"temperature: from atomic to Kelvin\", value::Float64)  ... to convert an atomic (energy) unit into Kelvin; 1 Hartree = 315774.64 K;                                                a Float64 is returned.\n(\"wave number to total electron energy: atomic units\", value::Float64)  ... to convert a wavenumber (a.u.) into the total electron                                           energy, including the rest energy; a Float64 is returned.\n(\"wave number to kinetic energy: atomic units\", value::Float64)  ... to convert a wavenumber (a.u.) into the kinetic energy;                                            a Float64 is returned.\n\n\n\n\n\n(string, values::Array{Float64,1})     ... to convert for the same strings as above but for an list of values; a corresponding Array{Float64,1} is returned.\n\n\n\n\n\n","category":"function"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"This function is called at many places within JAC to generate tables where all physical data are printed out in the pre-specified units:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Defaults.convertUnits(\"energy: from atomic\", 1.0)","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"With the given user-selection, this is equivalent to:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"Defaults.convertUnits(\"energy: from atomic to Kayser\", 1.0)","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"In JAC, the call of this function is often combined with some proper formatting of the results, such as:","category":"page"},{"location":"getting-started-jac.html","page":"Getting started with JAC (in REPL)","title":"Getting started with JAC (in REPL)","text":"using Printf\n@sprintf(\"%.4e\", Defaults.convertUnits(\"energy: from atomic\", 1.0))","category":"page"}]
}
