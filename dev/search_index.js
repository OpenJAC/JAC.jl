var documenterSearchIndex = {"docs":
[{"location":"api-basics.html#Angular-momentum","page":"API Basics","title":"Angular momentum","text":"","category":"section"},{"location":"api-basics.html","page":"API Basics","title":"API Basics","text":"Modules = [AngularMomentum]\nOrder   = [:type, :function]","category":"page"},{"location":"api-basics.html#JAC.AngularMomentum.CL_reduced_me-Tuple{Subshell, Int64, Subshell}","page":"API Basics","title":"JAC.AngularMomentum.CL_reduced_me","text":"AngularMomentum.CL_reduced_me(suba::Subshell, L::Int64, subb::Subshell)       ... calculates the reduced matrix element of the C^L spherical tensor <suba || C^(L) || subb>; a value::Float64          is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.CL_reduced_me_rb-Tuple{Subshell, Int64, Subshell}","page":"API Basics","title":"JAC.AngularMomentum.CL_reduced_me_rb","text":"AngularMomentum.CL_reduced_me_rb(suba::Subshell, L::Int64, subb::Subshell)       ... calculates the reduced matrix element of the C^L spherical tensor <suba || C^(L) || subb>; a value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.CL_reduced_me_sms-Tuple{Subshell, Int64, Subshell}","page":"API Basics","title":"JAC.AngularMomentum.CL_reduced_me_sms","text":"AngularMomentum.CL_reduced_me_sms(suba::Subshell, L::Int64, subb::Subshell)       ... calculates the reduced matrix element of the C^L spherical tensor <suba || C^(L) || subb> for the      specific MS (SMS); a value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.ChengI-Tuple{Int64, AngularM64, Int64, AngularM64, AngularJ64, AngularM64}","page":"API Basics","title":"JAC.AngularMomentum.ChengI","text":"`AngularMomentum.ChengI\n\n(kapa::Int64, ma::AngularM64, kapb::Int64, mb::AngularM64, L::AngularJ64, M::AngularM64)`    ... evaluates the angular I (kappa m, kappa' m', LM) integral as defined by Cheng, NATO summerschool (198x),        Eq. (A4.5), and including the full magnetic (orientational) dependence. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.ChengI-Tuple{Int64, Int64, AngularJ64}","page":"API Basics","title":"JAC.AngularMomentum.ChengI","text":"(kapa::Int64, kapb::Int64, L::AngularJ64)`    ... evaluates the same angular I (kappa m, kappa' m', LM) integral but without the magnetic (orientational) dependence.        A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.ClebschGordan-NTuple{6, Any}","page":"API Basics","title":"JAC.AngularMomentum.ClebschGordan","text":"AngularMomentum.ClebschGordan(ja, ma, jb, mb, Jab, Mab)       ... calculates the Clebsch-Gordan coefficient  <ja, ma, jb, mb; Jab, Mab> for given quantum numbers by          a proper call to a Wigner 3-j symbol. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.ClebschGordan_old-Tuple{AngularJ64, AngularM64, AngularJ64, AngularM64, AngularJ64, AngularM64}","page":"API Basics","title":"JAC.AngularMomentum.ClebschGordan_old","text":"AngularMomentum.ClebschGordan_old(ja::AngularJ64, ma::AngularM64, jb::AngularJ64, mb::AngularM64, Jab::AngularJ64, Mab::AngularM64)       ... calculates the Clebsch-Gordan coefficient  <ja, ma, jb, mb; Jab, Mab> for given quantum numbers by          a proper call to a Wigner 3-j symbol; a value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.JohnsonI-Tuple{Int64, Int64, AngularJ64}","page":"API Basics","title":"JAC.AngularMomentum.JohnsonI","text":"AngularMomentum.JohnsonI(kapa::Int64, ma::AngularM64, kapb::Int64, mb::AngularM64, L::AngularJ64, M::AngularM64)      ... evaluates the angular CL (kappa m, kappa' m', L M) integral as defined in his book. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.Wigner_3j-NTuple{6, Any}","page":"API Basics","title":"JAC.AngularMomentum.Wigner_3j","text":"AngularMomentum.Wigner_3j(a, b, c, m_a, m_b, m_c)       ... calculates the value of a Wigner 3-j symbol for given quantum numbers as displayed in many texts on the theory of          angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981, p. 142);          it calls the corresponding function from the GNU Scientific Library. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.Wigner_3j_old-Tuple{AngularJ64, AngularJ64, AngularJ64, AngularM64, AngularM64, AngularM64}","page":"API Basics","title":"JAC.AngularMomentum.Wigner_3j_old","text":"AngularMomentum.Wigner_3j_old(a::AngularJ64, b::AngularJ64, c::AngularJ64, m_a::AngularM64, m_b::AngularM64, m_c::AngularM64)           ... calculates the value of a Wigner 3-j symbol  for given quantum numbers by its algebraic formulae as displayed in many texts on the              theory of angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981,              p. 142); a value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.Wigner_6j-NTuple{6, Any}","page":"API Basics","title":"JAC.AngularMomentum.Wigner_6j","text":"AngularMomentum.Wigner_6j(a, b, c, d, e, f)       ... calculates the value of a Wigner 6-j symbol for given quantum numbers as displayed in many texts on the theory of          angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981, p. 142);          it calls the corresponding function from the GNU Scientific Library. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.Wigner_6j_old-NTuple{6, AngularJ64}","page":"API Basics","title":"JAC.AngularMomentum.Wigner_6j_old","text":"AngularMomentum.Wigner_6j_old(a::AngularJ64, b::AngularJ64, c::AngularJ64, d::AngularJ64, e::AngularJ64, f::AngularJ64)           ... calculates the value of a Wigner 6-j symbol  for given quantum numbers by its algebraic formulae as displayed in many texts on the              theory of angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981,              p. 142); a value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.Wigner_9j-NTuple{9, Any}","page":"API Basics","title":"JAC.AngularMomentum.Wigner_9j","text":"AngularMomentum.Wigner_9j(a, b, c, d, e, f, g, h, i)       ... calculates the value of a Wigner 3-j symbol for given quantum numbers as displayed in many texts on the theory of          angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981, p. 142);          it calls the corresponding function from the GNU Scientific Library. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.Wigner_9j_old-NTuple{9, AngularJ64}","page":"API Basics","title":"JAC.AngularMomentum.Wigner_9j_old","text":"AngularMomentum.Wigner_9j_old(a::AngularJ64, b::AngularJ64, c::AngularJ64, d::AngularJ64, e::AngularJ64, f::AngularJ64,                                 g::AngularJ64, h::AngularJ64, i::AngularJ64)           ... calculates the value of a Wigner 6-j symbol  for given quantum numbers by its algebraic formulae as displayed in many texts on the              theory of angular momentum (see R. D. Cowan, The Theory of Atomic Structure and Spectra; University of California Press, 1981,              p. 142); a value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.Wigner_DFunction-Tuple{Any, Any, Any, Float64, Float64, Float64}","page":"API Basics","title":"JAC.AngularMomentum.Wigner_DFunction","text":"AngularMomentum.Wigner_DFunction(j, p, q, alpha::Float64, beta::Float64, gamma::Float64)       ... calculates the value of a Wigner D^j_pq (alpha, beta, gamma) for given quantum numbers and (Euler) angles          (alpha, beta, gamma). It makes use of the small Wigner d(beta) matrix as the key part.         A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.Wigner_dmatrix-Tuple{Any, Any, Any, Float64}","page":"API Basics","title":"JAC.AngularMomentum.Wigner_dmatrix","text":"AngularMomentum.Wigner_dmatrix(j, mp, m, beta::Float64)       ... calculates the value of the small Wigner d^j_m',m (beta) for given quantum numbers and the angle beta.         Wigner's formula is applied to evaluate the small Wigner matrix; a value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.allowedDoubleKappaCouplingSequence-Tuple{LevelSymmetry, LevelSymmetry, Int64}","page":"API Basics","title":"JAC.AngularMomentum.allowedDoubleKappaCouplingSequence","text":"AngularMomentum.allowedDoubleKappaCouplingSequence(syma::LevelSymmetry, symb::LevelSymmetry, maxKappa::Int64)       ... to determine all allowed coupling sequences that fulfill         syma + (kappa1, symx, kappa2) –> symb  ==  syma + kappa1 –> symx + kappa2 –> symb,         and where kappa1|, |kappa2| <= maxKappa. A list::Array{Tuple{Int64,LevelSymmetry,Int64},1}) of (kappa1, symx, kappa2)         is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.allowedDoubleKappaSymmetries-Tuple{LevelSymmetry, Int64, Int64, LevelSymmetry}","page":"API Basics","title":"JAC.AngularMomentum.allowedDoubleKappaSymmetries","text":"AngularMomentum.allowedDoubleKappaSymmetries(syma::LevelSymmetry, kappa1::Int64, kappa2::Int64, symb::LevelSymmetry)       ... to determine all allowed level symmetries symx that can be coupled to the sequence          syma + kappa1 –> {symx} + kappa2 –> symb. A list::Array{LevelSymmetry,1} of symx is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.allowedDoubleKappas-Tuple{LevelSymmetry, LevelSymmetry, Int64}","page":"API Basics","title":"JAC.AngularMomentum.allowedDoubleKappas","text":"AngularMomentum.allowedDoubleKappas(syma::LevelSymmetry, symb::LevelSymmetry, maxKappa::Int64)       ... to determine all allowed pairs of kappa that fulfill  syma + (kappa1, kappa2) –> symb,         and where |kappa1|, |kappa2| <= maxKappa. A list::Array{Tuple{Int64,Int64},1}) of (kappa1, kappa2) is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.allowedKappaSymmetries-Tuple{LevelSymmetry, LevelSymmetry}","page":"API Basics","title":"JAC.AngularMomentum.allowedKappaSymmetries","text":"AngularMomentum.allowedKappaSymmetries(syma::LevelSymmetry, symb::LevelSymmetry)       ... to determine all allowed single-electron symmetries/partial waves kappa (l,j) that can be coupled to the given          level symmetries. A list::Array{Int64,1} of kappa-values is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.allowedMultipoleSymmetries-Tuple{LevelSymmetry, EmMultipole}","page":"API Basics","title":"JAC.AngularMomentum.allowedMultipoleSymmetries","text":"AngularMomentum.allowedMultipoleSymmetries(syma::LevelSymmetry, multipole::EmMultipole)       ... to determine all allowed level symmetries for which the given multipole can give rise to a non-zero (transition)          amplitude; a symList::Array{LevelSymmetry,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.allowedTotalSymmetries-Tuple{LevelSymmetry, EmMultipole, EmMultipole, LevelSymmetry}","page":"API Basics","title":"JAC.AngularMomentum.allowedTotalSymmetries","text":"AngularMomentum.allowedTotalSymmetries(symf::LevelSymmetry, mp2::EmMultipole, mp1::EmMultipole, symi::LevelSymmetry)       ... to determine all allowed total symmetries J^P that can be constructed by coupling a multipole wave mp1 to the          initial symmetry symi, and which can be further coupled with mp2 to the final symmetry symf.          A list::Array{LevelSymmetry,1} of total symmetries is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.allowedTotalSymmetries-Tuple{LevelSymmetry, Int64}","page":"API Basics","title":"JAC.AngularMomentum.allowedTotalSymmetries","text":"AngularMomentum.allowedTotalSymmetries(syma::LevelSymmetry, kappa::Int64)       ... to determine all allowed total symmetries J^P that can be constructed by coupling a partial wave kappa (l,j)          to the given level symmetry syma. A list::Array{LevelSymmetry,1} of total symmetries is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.bracket-Tuple{Vector{AngularJ64}}","page":"API Basics","title":"JAC.AngularMomentum.bracket","text":"AngularMomentum.bracket(jList::Array{AngularJ64,1})       ... to compute the bracket [a, b, c, ... ] = (2a+1) * (2b+1) * (2b+1) * ... of the given angular momenta.          A value::Int64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.isAllowedMultipole-Tuple{LevelSymmetry, EmMultipole, LevelSymmetry}","page":"API Basics","title":"JAC.AngularMomentum.isAllowedMultipole","text":"AngularMomentum.isAllowedMultipole(syma::LevelSymmetry, multipole::EmMultipole, symb::LevelSymmetry)       ... evaluates to true if the given multipole may connect the two level symmetries, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.isTriangle-Tuple{AngularJ64, AngularJ64, AngularJ64}","page":"API Basics","title":"JAC.AngularMomentum.isTriangle","text":"AngularMomentum.isTriangle(ja::AngularJ64, jb::AngularJ64, jc::AngularJ64)       ... evaluates to true if Delta(ja,jb,jc) = 1, ie. if the angular momenta ja, jb and jc can couple to each other,          and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.isTriangle-Tuple{Int64, Int64, Int64}","page":"API Basics","title":"JAC.AngularMomentum.isTriangle","text":"AngularMomentum.isTriangle(ja::Int64, jb::Int64, jc::Int64)       ... evaluates to true if Delta(ja,jb,jc) = 1, ie. if the three integer (length) ja, jb and jc can form a triangle,          and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.kappa_j-Tuple{Int64}","page":"API Basics","title":"JAC.AngularMomentum.kappa_j","text":"AngularMomentum.kappa_j(kappa::Int64)  ... calculates the j::AngularJ64 value of a given kappa.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.kappa_l-Tuple{Int64}","page":"API Basics","title":"JAC.AngularMomentum.kappa_l","text":"AngularMomentum.kappa_l(kappa::Int64)  ... calculates the l::AngularJ64 value of a given kappa.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.m_values-Tuple{AngularJ64}","page":"API Basics","title":"JAC.AngularMomentum.m_values","text":"AngularMomentum.m_values(j::AngularJ64)  ... returns a list of m-values for given j::AngularJ64.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.oneJ-Tuple{AngularJ64}","page":"API Basics","title":"JAC.AngularMomentum.oneJ","text":"AngularMomentum.oneJ(ja::AngularJ64)  ... calculates ja; a (positive) value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.parityEmMultipolePi-Tuple{Parity, EmMultipole, Parity}","page":"API Basics","title":"JAC.AngularMomentum.parityEmMultipolePi","text":"AngularMomentum.parityEmMultipolePi(pa::Parity, multipole::EmMultipole, pb::Parity)       ... evaluates to true if the given multipole fullfills the parity selection rule pi(a, multipole, b) = 1,          and false otherwise. This includes a proper test for both, electric and magnetic multipoles, based on          multipole.electric.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.phaseFactor-Tuple{Vector{Any}}","page":"API Basics","title":"JAC.AngularMomentum.phaseFactor","text":"AngularMomentum.phaseFactor(list::Array{Any,1})      ... checks and calculates the phase factor (-1)^(ja + mb -jc ...) that occur frequently in angular momentum theory;          a value +1. or -1. is returned. Use phaseFactor([ja::Union{AngularJ64,AngularM64), -1, mb::Union{AngularJ64,AngularM64),          ..., 1, jc::Union{AngularJ64,AngularM64)]) to specify the phase.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.phaseMultipole-Tuple{ComplexF64, EmMultipole}","page":"API Basics","title":"JAC.AngularMomentum.phaseMultipole","text":"AngularMomentum.phaseMultipole(x::ComplexF64, mp::EmMultipole)       ... calculates (x)^p   with   mp = (L,p) and p = 0 (magnetic), p = 1 (electric).         A  wa ::ComplexF64  is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.sigma_reduced_me-Tuple{Subshell, Subshell}","page":"API Basics","title":"JAC.AngularMomentum.sigma_reduced_me","text":"AngularMomentum.sigma_reduced_me(suba::Subshell, subb::Subshell)       ... calculates the reduced matrix element of the sigma^(1) spherical tensor <suba || sigma^(1) || subb>;          a value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.sphericalYlm-Tuple{Int64, Int64, Float64, Float64}","page":"API Basics","title":"JAC.AngularMomentum.sphericalYlm","text":"AngularMomentum.sphericalYlm(l::Int64, m::Int64, theta::Float64, phi::Float64)       ... calculates the spherical harmonics for low l-values explicitly. A value::Complex{Float64} is returned.         Ylm = sqrt( (2l+1) / (twotwo*pi) ) * spherical_Clm(l,m,theta,phi).\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.triangularDelta-Tuple{AngularJ64, AngularJ64, AngularJ64}","page":"API Basics","title":"JAC.AngularMomentum.triangularDelta","text":"AngularMomentum.triangularDelta(ja::AngularJ64, jb::AngularJ64, jc::AngularJ64)       ... calculates the tringular Delta(ja,jb,jc). The result is 0 if the triangular condition failes and 1 otherwise. \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.AngularMomentum.triangularDelta-Tuple{Int64, Int64, Int64}","page":"API Basics","title":"JAC.AngularMomentum.triangularDelta","text":"AngularMomentum.triangularDelta(ia2::Int64, ib2::Int64, ic2::Int64)       ... calculates the tringular Delta(ja,jb,jc). The arguments in this integer function are i2a = 2*ja+1, ...          The result is 0 if the triangular condition failes and 1 otherwise. \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#Atomic-interaction-strength","page":"API Basics","title":"Atomic interaction strength","text":"","category":"section"},{"location":"api-basics.html","page":"API Basics","title":"API Basics","text":"Modules = [InteractionStrength]\nOrder   = [:type, :function]","category":"page"},{"location":"api-basics.html#JAC.InteractionStrength.XLCoefficient","page":"API Basics","title":"JAC.InteractionStrength.XLCoefficient","text":"struct  InteractionStrength.XLCoefficient  ... defines a type for coefficients of the two-electron (Breit) interaction\n\n+ kind      ::Char       ... Kind of integral, either 'S' or 'T'\n+ nu        ::Int64      ... Rank of the integral.\n+ a         ::Orbital    ... Orbitals a, b, c, d.\n+ b         ::Orbital\n+ c         ::Orbital\n+ d         ::Orbital\n+ coeff     ::Float64    ... corresponding coefficient.\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.InteractionStrength.MabEmissionJohnsony-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.MabEmissionJohnsony","text":"InteractionStrength.MabEmissionJohnsony(mp::EmMultipole, gauge::EmGauge, omega::Float64, a::Orbital, b::Orbital, grid::Radial.Grid)     ... to compute the (single-electron reduced matrix element) interaction strength <a || O^(Mp,emission) || b>          for the interaction with the Mp multipole component of the radiation field and the transition frequency omega, and          within the given gauge. A value::Float64 is returned. This procedure has been re-worked due to the book by Johnson (2007). \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.MbaAbsorptionCheng-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.MbaAbsorptionCheng","text":"InteractionStrength.MbaAbsorptionCheng(mp::EmMultipole, gauge::EmGauge, omega::Float64, b::Orbital, a::Orbital, grid::Radial.Grid)     ... to compute the (single-electron reduced matrix element) interaction strength <b || O^(Mp, absorption) || a>          for the interaction with the Mp multipole component of the radiation field and the transition frequency omega, and          within the given gauge. A value::Float64 is returned.  \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.MbaEmissionAndreyOld-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.MbaEmissionAndreyOld","text":"InteractionStrength.MbaEmissionAndrey(mp::EmMultipole, gauge::EmGauge, omega::Float64, b::Orbital, a::Orbital, grid::Radial.Grid)       ... to compute the (single-electron reduced matrix element) interaction strength <b || O^(Mp, emission) || a>           for the interaction with the Mp multipole component of the radiation field and the transition frequency omega,         and within the given gauge. A value::Float64 is returned. At present, only the magnetic matrix elements are          implemented.          This procedure has been worked out with Andrey but is currently not in use.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.MbaEmissionCheng-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.MbaEmissionCheng","text":"InteractionStrength.MbaEmissionCheng(mp::EmMultipole, gauge::EmGauge, omega::Float64, b::Orbital, a::Orbital, grid::Radial.Grid)     ... to compute the (single-electron reduced matrix element) interaction strength <b || O^(Mp,emission) || a>          for the interaction with the Mp multipole component of the radiation field and the transition frequency omega, and          within the given gauge. A value::Float64 is returned.           This procedure has been first worked out with Andrey; in this case, however, the phases are not under good control,         and this gives rise to wrong amplitudes and rates. The procedure is currently not in use.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.MbaEmissionJohnsonx-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.MbaEmissionJohnsonx","text":"InteractionStrength.MbaEmissionJohnsonx(mp::EmMultipole, gauge::EmGauge, omega::Float64, b::Orbital, a::Orbital, grid::Radial.Grid)     ... to compute the (single-electron reduced matrix element) interaction strength <b || O^(Mp,emission) || a>          for the interaction with the Mp multipole component of the radiation field and the transition frequency omega, and          within the given gauge. A value::Float64 is returned.           This procedure has been adapted from Jiri's work but modified for the Coulomb gauge which was apparently wrong following         some former implementation with RATIP.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.MbaEmissionMigdalek-Tuple{CorePolarization, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.MbaEmissionMigdalek","text":"InteractionStrength.MbaEmissionMigdalek(cp::CorePolarization, a::Orbital, b::Orbital, grid::Radial.Grid)       ... to compute the (single-electron reduced matrix element) interaction strength <b || O^(E1, emission with core-polarization) || a>           in length gauge. A value::Float64 is returned. \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.XL_Breit-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid, Union{CoulombGaunt, BreitInteraction, CoulombBreit}}","page":"API Basics","title":"JAC.InteractionStrength.XL_Breit","text":"InteractionStrength.XL_Breit(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid,                                 eeint::Union{BreitInteraction, CoulombBreit, CoulombGaunt}; keep::Bool=false)       ... computes the the effective Breit interaction strengths X^LBreit (abcd) or Gaunt interaction strengths          X^LGaunt (abcd) for given rank L and orbital functions a, b, c and d  at the given grid.          For keep=true, the procedure looks up the (global) directory GBLStorageXL_Coulomb         and returns the corresponding value without re-calculation of the interaction strength; it also 'stores' the calculated         value if not yet included. For keep=false, the interaction strength is always computed on-fly. A value::Float64 is returned.          At present, only the zero-frequency Breit or Gaunt interaction is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.XL_BreitDamped-Tuple{Float64, Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.XL_BreitDamped","text":"InteractionStrength.XL_BreitDamped(tau::Float64, L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid)       ... computes the the effective Breit interaction strengths X^L_Breit (abcd) for given rank L and orbital functions          a, b, c and d  at the given grid. A value::Float64 is returned. At present, only the zero-frequency Breit          interaction is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.XL_Breit_coefficients-Tuple{Int64, Vararg{Orbital, 4}}","page":"API Basics","title":"JAC.InteractionStrength.XL_Breit_coefficients","text":"InteractionStrength.XL_Breit_coefficients(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital; onlyGaunt::Bool=false)       ... evaluates the combinations and pre-coefficients for the zero-frequency Breit interaction           X^L_Breit (omega=0.; abcd) for given rank L and orbital functions a, b, c and d. A list of coefficients          xcList::Array{XLCoefficient,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.XL_Breit_densities-Tuple{Vector{JAC.InteractionStrength.XLCoefficient}, Float64, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.XL_Breit_densities","text":"InteractionStrength.XL_Breit_densities(xcList::Array{XLCoefficient,1}, factor::Float64, grid::Radial.Grid)       ... computes the the effective Breit interaction strengths X^L,0_Breit (abcd) for given rank L and a list of          orbital functions a, b, c, d and angular coefficients at the given grid. A value::Float64 is returned.          At present, only the zero-frequency Breit interaction is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.XL_Breit_reset_storage-Tuple{Bool}","page":"API Basics","title":"JAC.InteractionStrength.XL_Breit_reset_storage","text":"InteractionStrength.XL_Breit_reset_storage(keep::Bool; printout::Bool=false)       ... resets the global storage of XL_Breit interaction strength; nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.XL_Coulomb-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.XL_Coulomb","text":"InteractionStrength.XL_Coulomb(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid; keep::Bool=false)       ... computes the the effective Coulomb interaction strengths X^LCoulomb (abcd) for given rank L and orbital functions          a, b, c and d at the given grid. For keep=true, the procedure looks up the (global) directory GBLStorageXLCoulomb         and returns the corresponding value without re-calculation of the interaction strength; it also 'stores' the calculated         value if not yet included. For keep=false, the interaction strength is always computed on-fly. A value::Float64 is          returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.XL_CoulombDamped-Tuple{Float64, Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.XL_CoulombDamped","text":"InteractionStrength.XL_CoulombDamped(tau::Float64, L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid)       ... computes the the effective Coulomb interaction strengths X^L_Coulomb (abcd) for given rank L and orbital functions          a, b, c and d at the given grid. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.XL_Coulomb_DH-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid, Float64}","page":"API Basics","title":"JAC.InteractionStrength.XL_Coulomb_DH","text":"InteractionStrength.XL_Coulomb_DH(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid, lambda::Float64)       ... computes the the effective Coulomb-Debye-Hückel interaction strengths X^LCoulombDH (abcd) for given rank L and          orbital functions a, b, c and d at the given grid and for the given screening parameter lambda. A value::Float64 is          returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.XL_Coulomb_WO-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.XL_Coulomb_WO","text":"InteractionStrength.XL_Coulomb_WO(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, grid::Radial.Grid)       ... computes the the effective Coulomb interaction strengths X^L_Coulomb (abcd) for given rank L and orbital functions          a, b, c and d at the given grid but without optimization. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.XL_Coulomb_reset_storage-Tuple{Bool}","page":"API Basics","title":"JAC.InteractionStrength.XL_Coulomb_reset_storage","text":"InteractionStrength.XL_Coulomb_reset_storage(keep::Bool; printout::Bool=false)       ... resets the global storage of XL_Coulomb interaction strength; nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.XL_plasma_ionSphere-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, Float64}","page":"API Basics","title":"JAC.InteractionStrength.XL_plasma_ionSphere","text":"InteractionStrength.XL_plasma_ionSphere(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, lambda::Float64)       ... computes the effective interaction strengths X^L_ion-sphere (abcd) for given rank L and orbital functions          a, b, c and d and for the plasma parameter lambda. A value::Float64 is returned.  Not yet implemented !\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.X_smsA-Tuple{Orbital, Orbital, Orbital, Orbital, Model, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.X_smsA","text":"InteractionStrength.X_smsA(a::Orbital, b::Orbital, c::Orbital, d::Orbital, nm::Nuclear.Model, grid::Radial.Grid)       ... computes the the effective interaction strengths X^1_sms,A (abcd) for fixed rank 1 and orbital functions          a, b, c and d at the given grid. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.X_smsB-Tuple{Orbital, Orbital, Orbital, Orbital, Model, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.X_smsB","text":"InteractionStrength.X_smsB(a::Orbital, b::Orbital, c::Orbital, d::Orbital, nm::Nuclear.Model, grid::Radial.Grid)       ... computes the the effective interaction strengths X^1_sms,B (abcd) for fixed rank 1 and orbital functions          a, b, c and d at the given grid. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.X_smsC-Tuple{Orbital, Orbital, Orbital, Orbital, Model, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.X_smsC","text":"InteractionStrength.X_smsC(a::Orbital, b::Orbital, c::Orbital, d::Orbital, nm::Nuclear.Model, grid::Radial.Grid)      ... computes the the effective interaction strengths X^1_sms,C (abcd) for fixed rank 1 and orbital functions          a, b, c and d at the given grid. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.bosonShift-Tuple{Orbital, Orbital, Vector{Float64}, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.bosonShift","text":"InteractionStrength.bosonShift(a::Orbital, b::Orbital, potential::Array{Float64,1}, grid::Radial.Grid)       ... computes the  <a|| h^(boson-field) ||b>  reduced matrix element of the boson-field shift Hamiltonian for orbital          functions a, b. This boson-field shift Hamiltonian just refers to the effective potential of the given          isotope due to the (assumed) boson mass. A value::Float64 is returned.  \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.dipole-Tuple{Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.dipole","text":"InteractionStrength.dipole(a::Orbital, b::Orbital, grid::Radial.Grid)       ... computes the  <a|| d ||b>  reduced matrix element of the dipole operator for orbital functions a, b.          A value::Float64 is returned. \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.eMultipole-Tuple{Int64, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.eMultipole","text":"InteractionStrength.eMultipole(k::Int64, a::Orbital, b::Orbital, grid::Radial.Grid)       ... computes the  <a|| t^(Ek) ||b>  reduced matrix element of the dipole operator for orbital functions a, b.          A value::Float64 is returned. \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.fieldShift-Tuple{Orbital, Orbital, Vector{Float64}, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.fieldShift","text":"InteractionStrength.fieldShift(a::Orbital, b::Orbital, deltaPotential::Array{Float64,1}, grid::Radial.Grid)       ... computes the  <a|| h^(field-shift) ||b>  reduced matrix element of the field-shift Hamiltonian for orbital          functions a, b. This field-shift Hamiltonian just refers to the difference of the nuclear potential          deltaPotential of two isotopes, and which is already divided by the difference of the mean-square radii.          A value::Float64 is returned.  \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.hamiltonian_nms-Tuple{Orbital, Orbital, Model, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.hamiltonian_nms","text":"InteractionStrength.hamiltonian_nms(a::Orbital, b::Orbital, nm::Nuclear.Model, grid::Radial.Grid)       ... computes the  <a|| h_nms ||b>  reduced matrix element of the normal-mass-shift Hamiltonian for orbital          functions a, b. A value::Float64 is returned.  For details, see Naze et al., CPC 184 (2013) 2187, Eq. (37).\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.hfs_t1-Tuple{Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.hfs_t1","text":"InteractionStrength.hfs_t1(a::Orbital, b::Orbital, grid::Radial.Grid)       ... computes the <a|| t^(1) ||b> reduced matrix element for the HFS coupling to the magnetic-dipole moment          of the nucleus for orbital functions a, b. A value::Float64 is returned.  \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.hfs_t2-Tuple{Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.hfs_t2","text":"InteractionStrength.hfs_t2(a::Orbital, b::Orbital, grid::Radial.Grid)       ... computes the <a|| t^(2) ||b> reduced matrix element for the HFS coupling to the electric-quadrupole moment of          the nucleus for orbital functions a, b. A value::Float64 is returned.  \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.matrixL_Coulomb-Tuple{Int64, Orbital, Orbital, Orbital, Orbital, JAC.Bsplines.Primitives}","page":"API Basics","title":"JAC.InteractionStrength.matrixL_Coulomb","text":"InteractionStrength.matrixL_Coulomb(L::Int64, a::Orbital, b::Orbital, c::Orbital, d::Orbital, primitives::Bsplines.Primitives)       ... computes the partly-contracted (effective) Coulomb interaction matrices M^L_Coulomb (abcd) for given rank L and orbital functions          a, b, c and d at the given grid. The matrix M^L is defined for the primitives and contracted over the two orbitals         b, d (for a=c) or  b, c (for a=d).  An error message is issued if a != c && a != d. A matrix::Array{Float64,2} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.multipoleTransition-Tuple{EmMultipole, JAC.Basics.EmGauge, Float64, Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.multipoleTransition","text":"InteractionStrength.multipoleTransition(mp::EmMultipole, gauge::EmGauge, omega::Float64, b::Orbital, a::Orbital, grid::Radial.Grid)     ... to compute the (single-electron reduced matrix element) multipole-transition interaction strength          <b || T^(Mp, absorption) || a> due to Johnson (2007) for the interaction with the Mp multipole component of the         radiation field and the transition frequency omega, and within the given gauge. A value::Float64 is returned.  \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.schiffMoment-Tuple{Orbital, Orbital, Model, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.schiffMoment","text":"InteractionStrength.schiffMoment(a::Orbital, b::Orbital, nm::Nuclear.Model, grid::Radial.Grid)       ... computes the  <a|| h^(Schiff-moment) ||b>  reduced matrix element of the Schiff-moment Hamiltonian for orbital          functions a, b and for the nuclear density as given by the nuclear model. A value::Float64 is returned.  \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.weakCharge-Tuple{Orbital, Orbital, Model, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.weakCharge","text":"InteractionStrength.weakCharge(a::Orbital, b::Orbital, nm::Nuclear.Model, grid::Radial.Grid)       ... computes the  <a|| h^(weak-charge) ||b>  reduced matrix element of the weak-charge Hamiltonian for orbital functions          a, b and for the nuclear density as given by the nuclear model. A value::Float64 is returned.  \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.zeeman_Delta_n1-Tuple{Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.zeeman_Delta_n1","text":"InteractionStrength.zeeman_Delta_n1(a::Orbital, b::Orbital, grid::Radial.Grid)       ... computes the <a|| Delta n^(1) ||b> reduced matrix element for the Zeeman-Schwinger contribution to the coupling          to an external magnetic field for orbital functions a, b. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.InteractionStrength.zeeman_n1-Tuple{Orbital, Orbital, JAC.Radial.Grid}","page":"API Basics","title":"JAC.InteractionStrength.zeeman_n1","text":"InteractionStrength.zeeman_n1(a::Orbital, b::Orbital, grid::Radial.Grid)       ... computes the <a|| n^(1) ||b> reduced matrix element for the Zeeman coupling to an external magnetic field for          orbital functions a, b. A value::Float64 is returned. \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#Basics:-data-types","page":"API Basics","title":"Basics: data types","text":"","category":"section"},{"location":"api-basics.html","page":"API Basics","title":"API Basics","text":"Modules = [Basics]\nPages   = [\"Basics.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api-basics.html#Basics:-functions","page":"API Basics","title":"Basics: functions","text":"","category":"section"},{"location":"api-basics.html","page":"API Basics","title":"API Basics","text":"Modules = [Basics]\nPages   = [\"inc-AZ.jl\", \"inc-AG.jl\", \"inc-HP.jl\", \"inc-QZ.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api-basics.html#Basics:-compute-and-generate","page":"API Basics","title":"Basics: compute & generate","text":"","category":"section"},{"location":"api-basics.html","page":"API Basics","title":"API Basics","text":"Modules = [Basics]\nPages   = [\"inc-compute.jl\", \"inc-generate.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api-basics.html#B-Spline-basis","page":"API Basics","title":"B-Spline basis","text":"","category":"section"},{"location":"api-basics.html","page":"API Basics","title":"API Basics","text":"Modules = [BsplinesN]\nOrder   = [:type, :function]","category":"page"},{"location":"api-basics.html#JAC.BsplinesN.Bspline","page":"API Basics","title":"JAC.BsplinesN.Bspline","text":"struct  BsplinesN.Bspline       ... defines a type for a (single) B-spline that is defined on a given radial grid from r[lower:upper].         Note that only the non-zero values are specified for the B-spline function and its derivative.\n\n+ lower        ::Int64               ... lower radial index (on the radial grid.r) from where the functions is nonzero.\n+ upper        ::Int64               ... upper radial index up to which the functions is nonzero.\n+ bs           ::Array{Float64,1}    ... radial B-spline functions as defined on the predefined grid.r[lower:upper]\n+ bp           ::Array{Float64,1}    ... derivative of bs on the predefined grid grid.r[lower:upper]\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.BsplinesN.Primitives","page":"API Basics","title":"JAC.BsplinesN.Primitives","text":"struct  BsplinesN.Primitives  ... defines a type for a set of primitive functions which typically belongs to a well-defined grid.\n\n+ grid         ::Radial.Grid         ... radial grid on which the states are represented.\n+ bsplinesL    ::Array{Bspline,1}    ... set of B-splines for the large components on the given radial grid.\n+ bsplinesS    ::Array{Bspline,1}    ... set of B-splines for the small components on the given radial grid.\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.BsplinesN.computeNondiagonalD-Tuple{Int64, Int64, JAC.BsplinesN.Bspline, JAC.BsplinesN.Bspline, JAC.Radial.Grid}","page":"API Basics","title":"JAC.BsplinesN.computeNondiagonalD","text":"BsplinesN.computeNondiagonalD(pm::Int64, kappa::Int64, bspline1::BsplinesN.Bspline, bspline2::BsplinesN.Bspline, grid::Radial.Grid)       ... computes the (radial and non-diagonal) D_kappa^+/- integral two the bsplines, all defined on grid         <bspline1| +/- d/dr + kappa/r | bspline2>. – pm = +1/-1 provides the phase for taking the derivative.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.BsplinesN.computeOverlap-Tuple{JAC.BsplinesN.Bspline, JAC.BsplinesN.Bspline, JAC.Radial.Grid}","page":"API Basics","title":"JAC.BsplinesN.computeOverlap","text":"BsplinesN.computeOverlap(bspline1::BsplinesN.Bspline, bspline2::BsplinesN.Bspline, grid::Radial.Grid)       ... computes the (radial) overlap integral <bspline1|bsplines>  for two bpslines as defined on grid.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.BsplinesN.computeVlocal-Tuple{JAC.BsplinesN.Bspline, JAC.BsplinesN.Bspline, JAC.Radial.Potential, JAC.Radial.Grid}","page":"API Basics","title":"JAC.BsplinesN.computeVlocal","text":"BsplinesN.computeVlocal(bspline1::BsplinesN.Bspline, bspline2::BsplinesN.Bspline, pot::Radial.Potential, grid::Radial.Grid)       ... computes the (radial) integral <bspline1| V_pot |bsplines>  for two bpslines and the given radial potential          as defined on grid.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.BsplinesN.extractBsplineCoefficients-Tuple{Subshell, JAC.Basics.Eigen, JAC.Radial.Grid}","page":"API Basics","title":"JAC.BsplinesN.extractBsplineCoefficients","text":"BsplinesN.extractBsplineCoefficients(sh::Subshell, wc::Basics.Eigen, grid::Radial.Grid)       ... Here, it is assumed that the matrix wc contains the (column) eigenvectors as associated with a single-electron Dirac          Hamiltonian matrix for symmetry kappa in Subshell(n, kappa). The procedure then extracts the (full) vector of B-spline         coefficients for the radial orbital of subshell sh by applying the standard rules of atomic physics for the principal         quantum number n.  A  vector::Array{Float64,1}  is returned, whose length is nsL+nsS in the original basis of B-spline          functions/primitives.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.BsplinesN.generateGalerkinMatrix-Tuple{Subshell, Float64, JAC.Radial.Potential, JAC.BsplinesN.Primitives}","page":"API Basics","title":"JAC.BsplinesN.generateGalerkinMatrix","text":"BsplinesN.generateGalerkinMatrix(sh::Subshell, energy::Float64, pot::Radial.Potential, primitives::BsplinesN.Primitives)       ... generates the Galerkin-A matrix for the given potential and B-spline primitives; a matrix::Array{Float64,2} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.BsplinesN.generateOrbitalFromPrimitives-Tuple{Subshell, Float64, Int64, Vector{Float64}, JAC.BsplinesN.Primitives}","page":"API Basics","title":"JAC.BsplinesN.generateOrbitalFromPrimitives","text":"BsplinesN.generateOrbitalFromPrimitives(sh::Subshell, energy::Float64, mtp::Int64, ev::Array{Float64,1}, primitives::BsplinesN.Primitives)       ... generates the large and small components of a (relativistic) orbital for the subshell sh from the given primitives and the          eigenvector ev. A (non-normalized) orbital::Orbital is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.BsplinesN.generateOrbitalFromPrimitives-Tuple{Subshell, JAC.Basics.Eigen, JAC.BsplinesN.Primitives}","page":"API Basics","title":"JAC.BsplinesN.generateOrbitalFromPrimitives","text":"BsplinesN.generateOrbitalFromPrimitives(sh::Subshell, wc::Basics.Eigen, primitives::BsplinesN.Primitives)       ... generates the large and small components for the subshell sh from the primitives and their eigenvalues & eigenvectors.          A (normalized) orbital::Orbital is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.BsplinesN.generateOrbitals-Tuple{Vector{Subshell}, JAC.Radial.Potential, Model, JAC.BsplinesN.Primitives}","page":"API Basics","title":"JAC.BsplinesN.generateOrbitals","text":"BsplinesN.generateOrbitals(subshells::Array{Subshell,1}, pot::Radial.Potential, nm::Nuclear.Model,                              primitives::BsplinesN.Primitives; printout::Bool=true)       ... generates all single-electron orbitals from subshell list for the radial potential pot.          A set of orbitals::Dict{Subshell, Orbital} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.BsplinesN.generateOrbitalsHydrogenic-Tuple{Vector{Subshell}, Model, JAC.BsplinesN.Primitives}","page":"API Basics","title":"JAC.BsplinesN.generateOrbitalsHydrogenic","text":"BsplinesN.generateOrbitalsHydrogenic(subshells::Array{Subshell,1}, nm::Nuclear.Model, primitives::BsplinesN.Primitives; printout::Bool=true)       ... generates all single-electron orbitals from subshell list for the nuclear potential as specified by nm.         A set of orbitals::Dict{Subshell, Orbital} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.BsplinesN.generatePrimitives-Tuple{JAC.Radial.Grid}","page":"API Basics","title":"JAC.BsplinesN.generatePrimitives","text":"BsplinesN.generatePrimitives(grid::Radial.Grid)       ... generates the breaks, knots and the B-spline primitives of order k, both for the large and small components.          The function applies the given grid parameters; no primitive is defined beyond grid[n_max]. The definition of          the primitives follow the work of Zatsarinny and Froese Fischer, CPC 202 (2016) 287. –- A (set of)          primitives::BsplinesN.Primitives is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.BsplinesN.generateTTpMatrix!-Tuple{String, Int64, JAC.BsplinesN.Primitives, Dict{String, Matrix{Float64}}}","page":"API Basics","title":"JAC.BsplinesN.generateTTpMatrix!","text":"BsplinesN.generateTTpMatrix!(TTp::String, kappa::Int64, primitives::BsplinesN.Primitives, storage::Dict{String,Array{Float64,2}})       ... returns the TTp block of the (single-electron) Dirac Hamiltonian matrix for an electron with symmetry kappa         without any potential. The following TTp strings are allowed: [\"LL-overlap\", \"SS-overlap\", \"LS-Dkappa^-\", \"LS-Dkappa^+\"].\n\n    Two modes are distinguished owing to the values that are available in the storage (Dict).\n        * The TTp matrix block from the storage is returned, if an entry is known; it is assumed that this matrix\n          block belong to the given set of primitives.\n        * The TTp matrix is computed and set to the storage otherwise; from the TTp string, the key string\n          key = string(kappa) * \":\" * TTp is generated an applied in the storage dictionary.\n          \n    All B-splines are supposed to be defined for the same (radial) grid; a  matrix::Array{Float64,2}  is returned which \n    is quadratic for 'LL-overlap' and 'SS-overlap' and whose dimension depends on the number of B-splines for the large \n    and small component, otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.BsplinesN.setupLocalMatrix-Tuple{Int64, JAC.BsplinesN.Primitives, JAC.Radial.Potential, Dict{String, Matrix{Float64}}}","page":"API Basics","title":"JAC.BsplinesN.setupLocalMatrix","text":"`BsplinesN.setupLocalMatrix(kappa::Int64, primitives::BsplinesN.Primitives, pot::Radial.Potential, storage::Dict{String,Array{Float64,2}})          ...set-up the local parts of the generalized eigenvalue problem for the symmetry block kappa and the given (local) potential pot.          The B-spline (basis) functions are defined by primitivesL for the large component and primitivesS for the small one, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#Electron-continuum","page":"API Basics","title":"Electron continuum","text":"","category":"section"},{"location":"api-basics.html","page":"API Basics","title":"API Basics","text":"Modules = [Continuum]\nOrder   = [:type, :function]","category":"page"},{"location":"api-basics.html#JAC.Continuum.Settings","page":"API Basics","title":"JAC.Continuum.Settings","text":"struct  Continuum.Settings  ... defines a type for the parameters for computing continuum orbitals.\n\n+ includeExchange         ::Bool    ... True, if the exchange is to be included and false otherwise.\n+ mtp                     ::Int64   ... No of grid points for which the continuum orbital(s) are to be computed.\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.Continuum.generateOrbitalAsymptoticCoulomb-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.generateOrbitalAsymptoticCoulomb","text":"Continuum.generateOrbitalAsymptoticCoulomb(energy::Float64, sh::Subshell, pot::Radial.Potential, settings::Continuum.Settings)        ... to generate a simple relativistic and non-normalized continuum orbital but by assuming an asymptotic sin/cos behaviour          for both components at all mesh points. For this behaviour, both components and their derivatives can be calculated          analytically. The effective charge Zbar is determined for the given potential and the non-Coulombic phase shifts is set          to zero. An non-normalized cOrbital::Orbital is returned.\n\n    Warning: At present, only the real part eta.re is taken into account; check for consistency !!\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.generateOrbitalBessel-Tuple{Float64, Subshell, JAC.Radial.Grid, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.generateOrbitalBessel","text":"Continuum.generateOrbitalBessel(energy::Float64, sh::Subshell, grid::Radial.Grid, settings::Continuum.Settings)        ... to generate a simple, non-relativistic and non-normalized Bessel wave for the large component of the continuum         orbital and a small component due to the kinetic-balance condition. A (non-normalized) orbital::Orbital is returned.         While Pprime is obtained from the analytical expression of the large component, Qprime is set to zero here.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.generateOrbitalForLevel-Tuple{Float64, Subshell, Level, Model, JAC.Radial.Grid, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.generateOrbitalForLevel","text":"Continuum.generateOrbitalForLevel(energy::Float64, sh::Subshell, level::Level, nm::Nuclear.Model, grid::Radial.Grid, basis::Basis,                                     settings::Continuum.Settings)        ... to generate a continuum orbital for the (continuum) subshell sh, the energy and the effective charge within the given          potential. The continuum orbital is generated orthogonal with regard to all subshells of the same symmetry in the basis.          All further specifications about this generations are made by proper settings. A tupel of a (continuum)          (orbital::Orbital, phase::Float64) is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.generateOrbitalGalerkin-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.generateOrbitalGalerkin","text":"Continuum.generateOrbitalGalerkin(energy::Float64, sh::Subshell, pot::Radial.Potential, settings::Continuum.Settings)        ... to generate a non-normalized continuum orbital within the given local potential by using the Galerkin method and a          given B-spline basis. A (non-normalized) orbital::Orbital is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.generateOrbitalLocalPotential-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.generateOrbitalLocalPotential","text":"Continuum.generateOrbitalLocalPotential(energy::Float64, sh::Subshell, pot::Radial.Potential, settings::Continuum.Settings)        ... to generate a continuum orbital for the (continuum) subshell sh, the energy and the given potential. The effective          charge for the normalization of the continuum orbital is derived from the potential. All further specifications about          this generations are made by proper settings; however, the function termintates if the settings.includeExchange = true.          A tupel of a (continuum) (orbital::Orbital, phase::Float64, normFactor::Float64) is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.generateOrbitalNonrelativisticCoulomb-Tuple{Float64, Subshell, Float64, JAC.Radial.Grid, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.generateOrbitalNonrelativisticCoulomb","text":"Continuum.generateOrbitalNonrelativisticCoulomb(energy::Float64, sh::Subshell, Zeff::Float64, grid::Radial.Grid,                                                      settings::Continuum.Settings)        ... to generate a simple, non-relativistic and non-normalized Coulomb wave for the (continuum) subshell sh,          the small component is simply obtained by the kinetic-balance condition. A orbital::Orbital is returned.         *****         This function does not yet work because there is no Julia implementation of the hypergeometric function with          complex arguments available.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.generateOrbitalNonrelativisticCoulomb-Tuple{Float64, Subshell, JAC.Radial.Potential, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.generateOrbitalNonrelativisticCoulomb","text":"(energy::Float64, sh::Subshell, pot::Radial.Potential, settings::Continuum.Settings)      ... to generate a simple, non-relativistic and non-normalized Coulomb wave for the (continuum) subshell sh,        the small component is simply obtained by the kinetic-balance condition. A orbital::Orbital is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.generateOrbitalPureSine-Tuple{Float64, Subshell, JAC.Radial.Grid, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.generateOrbitalPureSine","text":"Continuum.generateOrbitalPureSine(energy::Float64, sh::Subshell, grid::Radial.Grid, settings::Continuum.Settings)        ... to generate a simple, non-relativistic and non-normalized Bessel wave for the large component of the continuum         orbital and a small component due to the kinetic-balance condition. A (non-normalized) orbital::Orbital is returned.         While Pprime is obtained from the analytical expression of the large component, Qprime is set to zero here.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.gridConsistency-Tuple{Float64, JAC.Radial.Grid}","page":"API Basics","title":"JAC.Continuum.gridConsistency","text":"Continuum.gridConsistency(maxEnergy::Float64, grid::Radial.Grid)        ... to check the consistency of the given grid with the maximum energy of the required continuum electrons;          an error message is issued if the grid.hp = 0.   or  15 * grid.hp < wavelength(maxEnergy)   or  if the grid has          less than 600 grid points. The function also returns the recommended grid point where the normalization and phase          is to be determined. This number is currently set to nrContinuum = grid.NoPoints - 200  ... to correct for the wrong          'phase behaviour' at large r-values.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.normalizeOrbitalAlok-Tuple{Orbital, JAC.Radial.Potential, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.normalizeOrbitalAlok","text":"Continuum.normalizeOrbitalAlok(cOrbital::Orbital, pot::Radial.Potential, settings::Continuum.Settings)        ... to normalize the given continuum orbital with regard to a (asymptotic) wave function as per Salvat Code.          The orbitasl are normalized to unit amplitude.         An ( orbital::Orbital, (δ + Δ)::Float64, N::Float64 ) is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.normalizeOrbitalCoulombSine-Tuple{Orbital, JAC.Radial.Potential, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.normalizeOrbitalCoulombSine","text":"Continuum.normalizeOrbitalCoulombSine(cOrbital::Orbital, pot::Radial.Potential, settings::Continuum.Settings)        ... to normalize the given continuum orbital with regard to a (asymptotic) pure sine-function.          An (on-energy-scale-normalized) orbital::Orbital is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.normalizeOrbitalOngRussek-Tuple{Orbital, JAC.Radial.Potential, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.normalizeOrbitalOngRussek","text":"Continuum.normalizeOrbitalOngRussek(cOrbital::Orbital, pot::Radial.Potential, settings::Continuum.Settings)        ... to normalize the given continuum orbital with regard to a (asymptotic) pure sine-function.          An (on-energy-scale-normalized) orbital::Orbital is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.normalizeOrbitalPureSine-Tuple{Orbital, JAC.Radial.Grid, JAC.Continuum.Settings}","page":"API Basics","title":"JAC.Continuum.normalizeOrbitalPureSine","text":"Continuum.normalizeOrbitalPureSine(cOrbital::Orbital, grid::Radial.Grid, settings::Continuum.Settings)        ... to normalize the given continuum orbital with regard to a (asymptotic) pure sine-function.          An (on-energy-scale-normalized) orbital::Orbital and its relative phase phi w.r.t.  sin(kr + phi) is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.Continuum.twoFzero-Tuple{ComplexF64, ComplexF64, ComplexF64}","page":"API Basics","title":"JAC.Continuum.twoFzero","text":"function twoFzero(CA::ComplexF64, CB::ComplexF64, CZ::ComplexF64)     ... Calculates the Hypergeometric function 2F0(CA,CB;1/CZ) hypergeometric asymptotic series.         Taken from Radial package by Salvat et al.         A ComplexF64 value is returned.  \n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#Hydrogenic-ions","page":"API Basics","title":"Hydrogenic ions","text":"","category":"section"},{"location":"api-basics.html","page":"API Basics","title":"API Basics","text":"Modules = [HydrogenicIon]\nOrder   = [:type, :function]","category":"page"},{"location":"api-basics.html#JAC.HydrogenicIon.energy-Tuple{Shell, Float64}","page":"API Basics","title":"JAC.HydrogenicIon.energy","text":"HydrogenicIon.energy(sh::Shell, Z::Float64)      ... to compute the (non-relativistic) energy for the given shell and for a point-like nuclear charge Z; the energy is          printed in the current energy units to screen but is returned in Hartree. A energy::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.HydrogenicIon.energy-Tuple{Subshell, Float64}","page":"API Basics","title":"JAC.HydrogenicIon.energy","text":"HydrogenicIon.energy(sh::Subshell, Z::Float64)      ... to computes the Dirac energy for the hydrogenic subshell sh and for point-like nucleus with nuclear charge Z;          a energy::Float64 in atomic units and without the rest energy of the electron is returned. That is the binding          energy of a 1s_1/2 electron for Z=1 is -0.50000665.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.HydrogenicIon.orbital-Tuple{Subshell, Model, JAC.Radial.Grid}","page":"API Basics","title":"JAC.HydrogenicIon.orbital","text":"HydrogenicIon.orbital(sh::Subshell, nm::Nuclear.Model, grid::Radial.Grid)     ... to compute a relativstic hydrogenic Dirac orbital for the given nuclear model by using an explicit diagonalization          of the Dirac Hamiltonian in a B-spline basis; an orbital::Radial.Orbital is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.HydrogenicIon.radialOrbital-Tuple{Shell, Float64, Float64}","page":"API Basics","title":"JAC.HydrogenicIon.radialOrbital","text":"HydrogenicIon.radialOrbital(sh::Shell, Z::Float64, r::Float64)     ... to compute the (non-relativistic) orbital function P(r) for the given shell and nuclear charge Z;          a value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.HydrogenicIon.radialOrbital-Tuple{Shell, Float64, JAC.Radial.Grid}","page":"API Basics","title":"JAC.HydrogenicIon.radialOrbital","text":"HydrogenicIon.radialOrbital(sh::Shell, Z::Float64, grid::Radial.Grid)     ... to compute the same but for all r-values as specified by the given grid; a PList::Array{Float64,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.HydrogenicIon.radialOrbital-Tuple{Shell, Float64, Vector{Float64}}","page":"API Basics","title":"JAC.HydrogenicIon.radialOrbital","text":"HydrogenicIon.radialOrbital(sh::Shell, Z::Float64, rlist::Array{Float64,1})     ... to compute the same but for an array of r-values [r1, r2, ...]; a PList::Array{Float64,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.HydrogenicIon.radialOrbital-Tuple{Subshell, Float64, Float64}","page":"API Basics","title":"JAC.HydrogenicIon.radialOrbital","text":"HydrogenicIon.radialOrbital(sh::Subshell, Z::Float64, r::Float64)     ... to compute a relativistic hydrogenic Dirac orbital for the given subshell and nuclear charge Z;          a value::Float64 is returned; contributed by C Naumann (2022).         Implementation of the analytical solution of the Dirac equation for a point-like nucleus following the book by         Johnson: Atomic Structure Theory.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.HydrogenicIon.radialOrbital-Tuple{Subshell, Float64, JAC.Radial.Grid}","page":"API Basics","title":"JAC.HydrogenicIon.radialOrbital","text":"HydrogenicIon.radialOrbital(sh::Subshell, Z::Float64, grid::Radial.Grid)     ... to compute a relativistic hydrogenic Dirac orbital on the given grid;          an Array with the large and small component is returned; contributed by C Naumann (2022).\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.HydrogenicIon.radialOrbital-Tuple{Subshell, Model, JAC.Radial.Grid}","page":"API Basics","title":"JAC.HydrogenicIon.radialOrbital","text":"HydrogenicIon.radialOrbital(sh::Subshell, nm::Nuclear.Model, grid::Radial.Grid)     ... to compute a relativstic hydrogenic Dirac orbital for the given nuclear model by using an explicit diagonalization          of the Dirac Hamiltonian in a B-spline basis; an orbital::Radial.Orbital is returned; contributed by C Naumann (2022).\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.HydrogenicIon.radialOrbital_old2022-Tuple{Subshell, Float64, JAC.Radial.Grid}","page":"API Basics","title":"JAC.HydrogenicIon.radialOrbital_old2022","text":"HydrogenicIon.radialOrbital_old2022(sh::Subshell, Z::Float64, grid::Radial.Grid)     ... to compute a relativstic hydrogenic Dirac orbital on the given grid by applying the kinetic-balance to a          corresponding non-relavistic orbital; an orbital::Radial.Orbital is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.HydrogenicIon.radialOrbital_old2022-Tuple{Subshell, Model, JAC.Radial.Grid}","page":"API Basics","title":"JAC.HydrogenicIon.radialOrbital_old2022","text":"HydrogenicIon.radialOrbital_old2022(sh::Subshell, nm::Nuclear.Model, grid::Radial.Grid)     ... to compute a relativstic hydrogenic Dirac orbital for the given nuclear model by using an explicit diagonalization         of the Dirac Hamiltonian in a B-spline basis; an orbital::Radial.Orbital is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.HydrogenicIon.rkExpectation-Tuple{String, Shell, Float64}","page":"API Basics","title":"JAC.HydrogenicIon.rkExpectation","text":"HydrogenicIon.rkExpectation(srk::String, sh::Shell, Z::Float64)     ... to compute the (non-relativistic) r^k expectation value for the shell sh of an ion with charge Z;         a value::Float64 [in a_o^k] is returned. The string can takes values srk = [\"r\", \"r^2\", \"1/r\"]\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#Spin-angular-coefficients","page":"API Basics","title":"Spin angular coefficients","text":"","category":"section"},{"location":"api-basics.html","page":"API Basics","title":"API Basics","text":"Modules = [SpinAngular]\nOrder   = [:type]","category":"page"},{"location":"api-basics.html#JAC.SpinAngular.AbstractAngularType","page":"API Basics","title":"JAC.SpinAngular.AbstractAngularType","text":"abstract type SpinAngular.AbstractAngularType      ... defines an abstract type and a number of data types to work with one- and two-particle operators of given rank, see also:\n\n+ struct OneParticleOperator    ... to represent a single-particle operator with well-defined spherical tensor rank.\n+ struct TwoParticleOperator    ... to represent a two-particle operator with well-defined spherical tensor rank.\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.SpinAngular.Coefficient1p","page":"API Basics","title":"JAC.SpinAngular.Coefficient1p","text":"struct  SpinAngular.Coefficient1p       ... a struct for defining a single spin-angular coefficient for a reduced one-particle matrix element <a || o^(L) || b>.\n\n+ nu       ::Int64             ... Rank (L or nu) of the single-particle interaction strength.\n+ a        ::Subshell          ... Left-hand subshell (orbital).\n+ b        ::Subshell          ... Right-hand subshell (orbital).\n+ T        ::Float64           ... (Value of) spin-angular coefficient.\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.SpinAngular.Coefficient2p","page":"API Basics","title":"JAC.SpinAngular.Coefficient2p","text":"struct  SpinAngular.Coefficient2p       ... a struct for defining a single spin-angular coefficient for a reduced two-particle matrix element <ab || o^(L) || cd>,         such as the Coulomb interaction strength.\n\n+ nu       ::Int64             ... Rank (L or nu) of the single-particle interaction strength.\n+ a        ::Subshell          ... Left-hand subshell (orbital).\n+ b        ::Subshell          ... Left-hand subshell (orbital).\n+ c        ::Subshell          ... Right-hand subshell (orbital).\n+ d        ::Subshell          ... Right-hand subshell (orbital).\n+ V        ::Float64           ... (Value of) spin-angular coefficient.\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.SpinAngular.DiagramC01","page":"API Basics","title":"JAC.SpinAngular.DiagramC01","text":"struct  SpinAngular.Diagram       ... to defines various singleton() structs in order to distinguish between different coupling schemes of the          matrix elements.\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.SpinAngular.OneParticleOperator","page":"API Basics","title":"JAC.SpinAngular.OneParticleOperator","text":"struct  SpinAngular.OneParticleOperator  <:  AbstractAngularType       ... a struct for defining the spherial tensor structure of a single-particle operator.\n\n+ rank            ::Int64             ... Rank of the operator.\n+ parity          ::Basics.Parity     ... Parity of the operator (if needed ??)\n+ sameOrbitalSet  ::Bool              ... True if orbitals for both CSF are taken from the same orbital set (if needed ??)\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.SpinAngular.OneParticleOperator-Tuple{}","page":"API Basics","title":"JAC.SpinAngular.OneParticleOperator","text":"SpinAngular.OneParticleOperator()  ... constructor for setting the default values.\n\n\n\n\n\n","category":"method"},{"location":"api-basics.html#JAC.SpinAngular.QspaceTerm","page":"API Basics","title":"JAC.SpinAngular.QspaceTerm","text":"struct  SpinAngular.QspaceTerm       ... a struct for defining a subshell term/state  |j (nu) alpha Q J> == |j (nu) Q J Nr> for a subshell with well-defined j.\n\n+ j        ::AngularJ64   ... subshell j\n+ Q        ::AngularJ64   ... quasi-spin\n+ J        ::AngularJ64   ... total J of subshell term\n+ Nr       ::Int64        ... Additional quantum number Nr = 0,1,2.\n+ min_odd  ::Int64        ... the minimal limits of the subshell terms for odd number operators in second quantization\n+ max_odd  ::Int64        ... the maximal limits of the subshell terms for odd number operators in second quantization\n+ min_even ::Int64        ... the minimal limits of the subshell terms for even number operators in second quantization\n+ max_even ::Int64        ... the maximal limits of the subshell terms for even number operators in second quantization\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.SpinAngular.SchemeEta_a","page":"API Basics","title":"JAC.SpinAngular.SchemeEta_a","text":"struct  SpinAngular.SchemeEta       ... to define various singleton structs in order to distinguish between different irreducible tensors          and matrix elements.\n\n+ Eta_a         ... a^(qj)_mq\n+ Eta_W         ... W^(k_12) = [a x a]\n+ Eta_aW        ... W^(k_12, k_2) = [a1 x [a2 x a3]]\n+ Eta_Wa        ... W^(k_12, k_2) = [[a1 x a2] x a3]\n+ Eta_WW        ... W^(kk0) = [[a1 x a2]^k x [a3 x a4]^k]^0\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.SpinAngular.TwoParticleOperator","page":"API Basics","title":"JAC.SpinAngular.TwoParticleOperator","text":"struct  SpinAngular.TwoParticleOperator       ... a struct for defining the spherial tensor structure of a two-particle operator.\n\n+ rank            ::Int64             ... Rank of the operator (if needed ??).\n+ parity          ::Basics.Parity     ... Parity of the operator (if needed ??)\n+ sameOrbitalSet  ::Bool              ... True if orbitals for both CSF are taken from the same orbital set (if needed ??)\n\n\n\n\n\n","category":"type"},{"location":"api-basics.html#JAC.SpinAngular.TwoParticleOperator-Tuple{}","page":"API Basics","title":"JAC.SpinAngular.TwoParticleOperator","text":"SpinAngular.TwoParticleOperator()  ... constructor for setting the default values.\n\n\n\n\n\n","category":"method"},{"location":"demos.html#Pluto-notebooks","page":"Demos","title":"Pluto notebooks","text":"","category":"section"},{"location":"demos.html","page":"Demos","title":"Demos","text":"info: Info\nThe demo files are designed with Pluto notebook. A detaild guideline of Pluto Installation is available at  (https://plutojl.org/#install).\nUsers can also find the files in the demo folder JAC package.","category":"page"},{"location":"demos.html","page":"Demos","title":"Demos","text":"The following Pluto.jl notebooks introduce the reader to JAC and demonstrate several features of this toolbox. –- They can be explored statically at GitHub or can be run locally after the software repository has been cloned and installed. Simply call Pluto.run() at the REPL ... and follow your Browser.","category":"page"},{"location":"demos.html#Getting-started","page":"Demos","title":"Getting started","text":"","category":"section"},{"location":"demos.html","page":"Demos","title":"Demos","text":"Getting started with Julia:               demos/A1-Pluto-notebook-basics.jl\nGetting started with Julia & JAC:         demos/A2-Pluto-getting-started-with-Julia-and-JAC.jl\nUsing JAC the first time:                 demos/A3-Pluto-using-JAC-first.jl","category":"page"},{"location":"demos.html#Atomic-structure-calculations","page":"Demos","title":"Atomic structure calculations","text":"","category":"section"},{"location":"demos.html","page":"Demos","title":"Demos","text":"SCF and CI computations for C^2+:     demos/B1-Pluto-compute-SCF+CI-carbon-III.jl","category":"page"},{"location":"demos.html#Evaluation-of-Racah-algebra-expressions","page":"Demos","title":"Evaluation of Racah algebra expressions","text":"","category":"section"},{"location":"demos.html","page":"Demos","title":"Demos","text":"Simplification of Wigner n-j symbols:     demos/F1-Pluto-evaluate-Wigner-symbols.jl)","category":"page"},{"location":"contributors.html#Developers:","page":"Contributors","title":"Developers:","text":"","category":"section"},{"location":"contributors.html","page":"Contributors","title":"Contributors","text":"Fritzsche, Stephan, s.fritzsche@gsi.de (U Jena, Germany)\nSahoo, Aloka Kumar, aloka_s@ph.iitr.ac.in (HI Jena, Germany)\nHuang, Houke (Institute of Modern Physics, Lanzhou, China)\nWang, Wu (HI Jena, Germany & U Haikou, China)\nLi, Bowen (U Lanzhou, China)","category":"page"},{"location":"contributors.html#(Former)-Supporters:","page":"Contributors","title":"(Former) Supporters:","text":"","category":"section"},{"location":"contributors.html","page":"Contributors","title":"Contributors","text":"Böning, Birger (HI Jena, Germany)\nDar, Danish F. (U Jena, Germany)\nGaigalas, Gediminas (U Vilnius, Lithuania)\nGilles, Jan (PTB Braunschweig, Germany)\nHofbrucker, Jiri (U Jena, Germany)\nJiao, Li-Guang (HI Jena, Germany & Jilin U Changchun, China)\nSchippers, Stefan (U Giessen, Germany)\nSienkiwicz, Joseph (TU Gdansk, Poland)\nSurzhykov, Andrey (U Braunschweig, Germany)\nVolotka, Andrey (HI Jena, Germany & St. Petersburg, Russia)\nWang, Yuan-Cheng (HI Jena, Germany & U Shenyang, China)\nWu, Zhongwen (HI Jena, Germany & U Lanzhou, China)","category":"page"},{"location":"api-plasma.html#Plasma-computations","page":"API Plasma computations","title":"Plasma computations","text":"","category":"section"},{"location":"api-plasma.html","page":"API Plasma computations","title":"API Plasma computations","text":"Modules = [Plasma]\nPages   = [\"Plasma.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api-plasma.html#JAC.Plasma.AbstractPlasmaScheme","page":"API Plasma computations","title":"JAC.Plasma.AbstractPlasmaScheme","text":"abstract type Plasma.AbstractPlasmaScheme      ... defines an abstract type to distinguish different kinds of plasma computations; see also:\n\n+ struct AverageAtomScheme    \n    ... to perform an average-atom computation.\n+ struct LineShiftScheme    \n    ... to compute the energy shifts and properties of atomic/ionic lines in some selected plasma model.\n+ struct RateSchemePhotoionization    \n    ... to compute (empirical) photoionization plasma rates and rate coefficients.\n+ struct RateSchemePhotorecombination    \n    ... to compute (empirical) photorecombination plasma rates and rate coefficients.\n+ struct SahaBoltzmannScheme    \n    ... to compute thermodynamic properties of a Saha-Boltzmann LTE mixture.\n\n\n\n\n\n","category":"type"},{"location":"api-plasma.html#JAC.Plasma.AverageAtomScheme","page":"API Plasma computations","title":"JAC.Plasma.AverageAtomScheme","text":"struct  Plasma.AverageAtomScheme  <:  Plasma.AbstractPlasmaScheme       ... a struct to perform an average-atom computation.\n\n+ nMax                  ::Int64                ... maximum principal quantum number for the subshells of the AA model.\n+ lMax                  ::Int64                ... maximum orbital quantum number for the subshells of the AA model.\n+ scField               ::AbstractScField      ... maximum orbital quantum number for the subshells of the AA model.\n+ calcPhotoionizationCs ::Bool                 ... True, if photoionization cross sections are to be calculated.\n+ calcFormFactor        ::Bool                 ... True, if the form factor need to be calculated.\n+ calcScatteringFactor  ::Bool                 ... True, if scattering factor need to be calculated.\n+ piSubshells           ::Array{Subshell,1}    ... Bound subshells to be included into the photoionization cross sections.\n+ omegas                ::Array{Float64,1}     ... energies for the photoionization & scattering factors [in a.u.].\n+ qValues               ::Array{Float64,1}     ... q-values for calculating the form factor [in a.u.].\n\n\n\n\n\n","category":"type"},{"location":"api-plasma.html#JAC.Plasma.AverageAtomScheme-Tuple{}","page":"API Plasma computations","title":"JAC.Plasma.AverageAtomScheme","text":"Plasma.AverageAtomScheme()  ... constructor for an 'default' instance of a Plasma.AverageAtomScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-plasma.html#JAC.Plasma.Computation","page":"API Plasma computations","title":"JAC.Plasma.Computation","text":"struct  Computation       ... defines a type for defining  (simple) plasma computation for atoms and ions in a given set of         reference configurations. It also support different atomic processes under plasma conditions.         The plasma environment is typical described in terms of its temperature, density, etc.\n\n+ scheme                         ::AbstractPlasmaScheme            ... Scheme (kind) of plasma computation.\n+ nuclearModel                   ::Nuclear.Model                   ... Model, charge and parameters of the nucleus.\n+ grid                           ::Radial.Grid                     ... The radial grid to be used for the computation.\n+ refConfigs                     ::Array{Configuration,1}          ... A list of non-relativistic configurations.\n+ asfSettings                    ::AsfSettings                     \n    ... Provides the settings for the SCF process (under plasma conditions) and the associated CI calculations.\n+ settings                       ::Plasma.Settings                 ... communicates the properties of the plasma\n\n\n\n\n\n","category":"type"},{"location":"api-plasma.html#JAC.Plasma.Computation-Tuple{Bool}","page":"API Plasma computations","title":"JAC.Plasma.Computation","text":"Plasma.Computation( ... example for plasma SCF computations)  \n\n    grid     = Radial.Grid(true)\n    nuclearM = Nuclear.Model(18., \"Fermi\")\n    ...\n    refConfigs  = [Configuration(\"[Ne] 3s^2 3p^5\")]\n    Plasma.Computation(Plasma.Computation(), grid=grid, nuclearModel=nuclearM, refConfigs=refConfigs, asfSettings=... )\n\n... These simple examples can be further improved by overwriting the corresponding parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-plasma.html#JAC.Plasma.Computation-Tuple{JAC.Plasma.Computation}","page":"API Plasma computations","title":"JAC.Plasma.Computation","text":"Plasma.Computation(comp::Plasma.Computation;\n\nscheme=..,                  nuclearModel=..,            grid=..,                refConfigs=..,              asfSettings=..,     \nsettings=..,\nprintout::Bool=false)\n                \n... constructor for modifying the given Plasma.Computation by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-plasma.html#JAC.Plasma.Computation-Tuple{}","page":"API Plasma computations","title":"JAC.Plasma.Computation","text":"Plasma.Computation()  ... constructor for an 'empty' instance::Plasma.Computation.\n\n\n\n\n\n","category":"method"},{"location":"api-plasma.html#JAC.Plasma.LineShiftScheme","page":"API Plasma computations","title":"JAC.Plasma.LineShiftScheme","text":"struct  Plasma.LineShiftScheme  <:  Plasma.AbstractPlasmaScheme       ... defines a type for the details and parameters of computing level energies with plasma interactions.\n\n+ plasmaModel      ::AbstractPlasmaModel          ... Specify a particular plasma model, e.g. ion-sphere, Debye.\n+ initialConfigs   ::Array{Configuration,1}       ... List of one or several configurations that define the initial-state multiplet.\n+ finalConfigs     ::Array{Configuration,1}       ... List of one or several configurations that define the final-state multiplet.\n+ settings         ::AbstractLineShiftSettings    ... Specify the process and settings for which line-shifts need to be computed.\n## + NoBoundElectrons ::Int64                      ... Effective number of bound electrons.\n\n\n\n\n\n","category":"type"},{"location":"api-plasma.html#JAC.Plasma.LineShiftScheme-Tuple{}","page":"API Plasma computations","title":"JAC.Plasma.LineShiftScheme","text":"Plasma.LineShiftScheme()  ... constructor for a standard instance of Plasma.LineShiftScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-plasma.html#JAC.Plasma.PartialWaveData","page":"API Plasma computations","title":"JAC.Plasma.PartialWaveData","text":"struct  Plasma.PartialWaveData       ... defines a type to collect for partial-waves (kappa) cross sections, rates, etc. at different energies\n\n+ kappa    ::Int64                            ... kappa\n+ pairs    ::Vector{Tuple{Float64, Float64}}  \n    ... vector of pairs, for instance (energy, cs), to later combine data in a proper manner.\n\n\n\n\n\n","category":"type"},{"location":"api-plasma.html#JAC.Plasma.PartialWaveData-Tuple{}","page":"API Plasma computations","title":"JAC.Plasma.PartialWaveData","text":"Plasma.PartialWaveData()  ... constructor for the default values of Plasma.PartialWaveData set\n\n\n\n\n\n","category":"method"},{"location":"api-plasma.html#JAC.Plasma.SahaBoltzmannScheme","page":"API Plasma computations","title":"JAC.Plasma.SahaBoltzmannScheme","text":"struct  Plasma.SahaBoltzmannScheme  <:  Plasma.AbstractPlasmaScheme       ... a struct to thermodynamic properties of a Saha-Boltzmann LTE mixture..\n\n+ plasmaModel           ::Basics.AbstractPlasmaModel                 \n    ... A plasma model that \"restricts\" the Saha-Boltzmann equilibrium densities by some additional parameters, for instance,\n        due to ionization-potential-depression (IPD) or others.\n+ calcLTE               ::Bool                 ... True, if the Saha-Boltzmann equilibrium densities should be calculated.         \n+ printIonLevels        ::Bool                 ... True, for printing detailed information about all ionic levels.         \n+ qRange                ::UnitRange{Int64}     ... Range of charge states q for which ions are taken into account. \n+ maxNoIonLevels        ::Int64                ... (maximum) No of ionic levels for any charge state of the ions in the mixture.\n+ NoExcitations         ::Int64                \n    ... No of excitations (S, D, T) that are taken into account with regard to the reference (ground) configuration of the ions.\n        This number is taken as a second qualifier to characterize the quality of the ionic-level data. Usually, NoExcitations = 1,2.\n+ upperShellNo          ::Int64                \n    ... upper-most princicpal quantum number n for which orbitals are taken into account into the ionic-level computations;\n        this is often chosen upperShellNo= 4..10; if ionic-level data are given, this number decides which of the levels\n        are taken into account.\n+ isotopicMixture       ::Array{Basics.IsotopicFraction,1}   \n    ... List of (non-normlized) isotopic fractions that form the requested mixture; the fractions will first be renormalized\n        to 1 in course of the Saha-Boltzmann LTE computations.\n+ isotopeFilenames      ::Array{String,1}     \n    ... set of files names from which the ionic-level data can be read in for the different isotopes (Z,A) in the mixture.\n\n\n\n\n\n","category":"type"},{"location":"api-plasma.html#JAC.Plasma.SahaBoltzmannScheme-Tuple{}","page":"API Plasma computations","title":"JAC.Plasma.SahaBoltzmannScheme","text":"Plasma.SahaBoltzmannScheme()  ... constructor for an 'default' instance of a Plasma.SahaBoltzmannScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-plasma.html#JAC.Plasma.Settings","page":"API Plasma computations","title":"JAC.Plasma.Settings","text":"struct  Plasma.Settings  ... defines a type for the details and parameters of computing photoionization lines.\n\n+ temperature               ::Float64     ... Plasma temperature in [K].\n+ density                   ::Float64     ... Plasma density in [g/cm^3].\n+ useNumberDensity          ::Bool    \n    ... true, if the density above is taken as (total ion) number density ni, and false otherwise.\n\n\n\n\n\n","category":"type"},{"location":"api-plasma.html#JAC.Plasma.Settings-Tuple{JAC.Plasma.Settings}","page":"API Plasma computations","title":"JAC.Plasma.Settings","text":"Plasma.Settings(set::Plasma.Settings;\n\n    temperature=..,         density=..,         useNumberDensity =..)\n                \n... constructor for modifying the given Plasma.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-plasma.html#JAC.Plasma.Settings-Tuple{}","page":"API Plasma computations","title":"JAC.Plasma.Settings","text":"Plasma.Settings()  ... constructor for the default values of plasma computations\n\n\n\n\n\n","category":"method"},{"location":"api-plasma.html#JAC.Basics.perform-Tuple{JAC.Plasma.Computation}","page":"API Plasma computations","title":"JAC.Basics.perform","text":"Basics.perform(comp::Plasma.Computation)       ... to set-up and perform a plasma computation that starts from a given set of reference configurations and          support both, an atomic-average SCF procedure and the computation of various plasma properties and processe.         The results of all individual steps are printed to screen but nothing is returned otherwise.\n\nBasics.perform(comp::Plasma.Computation; output::Bool=true)        ... to perform the same but to return the complete output in a dictionary;  the particular output depends on the type          and specifications of the plasma computation but can easily accessed by the keys of this dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api-plasma.html#Empirical-plasma-rates","page":"API Plasma computations","title":"Empirical plasma rates","text":"","category":"section"},{"location":"api-plasma.html","page":"API Plasma computations","title":"API Plasma computations","text":"Modules = [Cascade]\nPages   = [\"inc-empirical-rates.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api-plasma.html#Line-shift-computations","page":"API Plasma computations","title":"Line-shift computations","text":"","category":"section"},{"location":"api-plasma.html","page":"API Plasma computations","title":"API Plasma computations","text":"Modules = [Cascade]\nPages   = [\"inc-line-shifts.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api-plasma.html#Saha-Boltzmann-computations-of-ionic-mixtures","page":"API Plasma computations","title":"Saha-Boltzmann computations of ionic mixtures","text":"","category":"section"},{"location":"api-plasma.html","page":"API Plasma computations","title":"API Plasma computations","text":"Modules = [Cascade]\nPages   = [\"inc-saha-boltzmann-mixture.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"getting-started.html#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting-started.html#...-with-Julia-(in-REPL)","page":"Getting Started","title":"... with Julia (in REPL)","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Getting started with Julia (in REPL)","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"info: Info\nLink to the Pluto jl and direct start with  example...","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Here, we shall not introduce Julia's syntax and concepts for which many tutorials are available on the web.  Instead, we just wish to remind and highlight some simple (syntax) features that help to go easier around with JAC, and  especially for occasional users from experiment or teaching. This reminder aims to lower the initial threshold for users  that have been trained on other languages in the past. Here, we shall pick up some issues whose physics background  is explained only later in other tutorial. Obviously, however, Julia is a very rich and powerful language with many  features that go well beyond of what is (and will ever) needed for JAC.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"In brief, JAC provides tools for performing atomic (structure) calculations of different kind and complexity, and for  which further details are given in the tutorials below. To see anything from JAC, we shall first invoke the tools by:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"using JAC","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"a line that will appear at the beginning of all subsequent tutorials. – A first powerful and frequently needed feature  refers to Julia's help pages or just the \"?\". By typing, for instance, atom or computation","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? atom","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"search: atomic Atomic AtomicState AtomicCompass AtomicStructure @atomic @atomicswap @atomicreplace\n\nCouldn't find atom\nPerhaps you meant atomic, atan, acot, acos, htol, hton, ltoh, ntoh, Atomic, @atomic, pathof, atand, atanh, cat, \nmatch, catch, stat, acotd, acoth, add, ans, abs, abs2, acosd, acosh, acsc, all, all!, any, any!, asec, asin, axes, \nas, tan or Beam\nNo documentation found.\n\nBinding atom does not exist.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"we see, that atom itself is not a well-defined term in the JAC toolbox but that there exists a number of related  terms, such as Atomic, AtomicState (two modules of JAC) and others. We shall not enter here the modular structure  of the JAC toolbox but start much simpler with: ","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? Orbital","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Orbital","category":"page"},{"location":"getting-started.html#JAC.Radial.Orbital-getting-started","page":"Getting Started","title":"JAC.Radial.Orbital","text":"struct  Radial.Orbital       ... defines a type for a single-electron radial orbital function with a large and small component, and which can refer to         either the standard or an explicitly given grid due to the logical flag useStandardGrid. Bound-state orbitals with energy < 0 are          distinguished from free-electron orbitals by the flag isBound.\n\n+ subshell        ::Subshell          ... Relativistic subshell.\n+ isBound         ::Bool              ... Logical flag to distinguish between bound (true) and free-electron orbitals (false).\n+ useStandardGrid ::Bool              ... Logical flag for using the standard grid (true) or an explicitly given grid (false).\n+ energy          ::Float64           ... Single-electron energies of bound orbitals are always negative.\n+ P               ::Array{Float64,1}  ... Large and ..\n+ Q               ::Array{Float64,1}  ... small component of the radial orbital.\n+ Pprime          ::Array{Float64,1}  ... dP/dr.\n+ Qprime          ::Array{Float64,1}  ... dQ/dr.\n+ grid            ::Array{Float64,1}  ... explic. defined radial grid array for P, Q, if StandardGrid = false.\n\n\n\n\n\n","category":"type"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"which, apart from its formal meaning, is a particular data structure (struct) of JAC and which represents a  relativistic orbital (function) including additional information that appears helpful in the given implementation. There  are very many (say, more than 300) of such data struct's specified in the JAC toolbox, and thus quite obvious that nobody will remember the details of all these definitions. Indeed, the \"?\" is the right and a powerful means to remind  yourself and make use of these data structures whenever necessary. Special care has been taken that all data structures  and functions/methods comes with a reasonable explanation (docstring) in order to work efficiently with JAC.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"For instance, we might ask of what can be added to each other in JAC:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? add","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"add","category":"page"},{"location":"getting-started.html#JAC.Basics.add-getting-started","page":"Getting Started","title":"JAC.Basics.add","text":"Basics.add(pota::Radial.Potential, potb::Radial.Potential)       ... to add two radial potentials together that are defined on the same grid. A potential::RadialPotential is returned          that inherits its radial size from the potential that is defined in a larger range of r-values.\n\n\n\n\n\nBasics.add(ma::AngularM64, mb::AngularM64)       ... adds the projections of the angular momenta ma + mb and returns a mc::AngularM64.\n\n\n\n\n\n","category":"function"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Apart from a short explanation, these docstring always tell the user (i) in which module the method is defined;  (ii) which arguments it takes, including Julia's multiple dispatch feature as well as (iii) the type of the return  value. All these information are typically relevant to the user, especially if some input or output does not behave as  it should. Indeed, the complexity can grow quite rapidly, for instance, if we ask for help of what we can generate:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? generate","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"generate","category":"page"},{"location":"getting-started.html#JAC.Basics.generate-getting-started","page":"Getting Started","title":"JAC.Basics.generate","text":"Basics.generate(representation::AtomicState.Representation)       ... to generate an atomic representation as specified by the representation.repType::AbstractRepresentationType.         All relevant intermediate and final results are printed to screen (stdout). Nothing is returned.\n\nBasics.perform(representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(repType::AtomicState.MeanFieldBasis, representation::AtomicState.Representation)       ... to generate a mean-field basis (representation) for a set of reference configurations; all relevant intermediate          and final results are printed to screen (stdout). Nothing is returned.\n\nBasics.generate(repType::AtomicState.MeanFieldBasis, representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(repType::AtomicState.MeanFieldMultiplet, representation::AtomicState.Representation)       ... to generate a mean-field basis (representation) for a set of reference configurations; all relevant intermediate          and final results are printed to screen (stdout). Nothing is returned.\n\nBasics.generate(repType::AtomicState.MeanFieldMultiplet, representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(repType::AtomicState.OneElectronSpectrum, representation::AtomicState.Representation)       ... to generate a one-electron spectrum for the atomic potential from the (given) levels, based on a set of reference          configurations as well as for given settings. Relevant intermediate and final results are printed to screen (stdout).          Nothing is returned in this case.\n\n+ `(repType::AtomicState.OneElectronSpectrum, representation::AtomicState.Representation; output=true)`  \n... to generate the same but to return the complete output in a orbitals::Dict{Subshell, Orbital}.\n\n\n\n\n\nBasics.generate(repType::AtomicState.CiExpansion, representation::AtomicState.Representation)       ... to generate a configuration-interaction expansion for a single level symmetry and based on a set of reference configurations         and a number of pre-specified steps. All relevant intermediate and final results are printed to screen (stdout).          Nothing is returned.\n\nBasics.generate(repType::AtomicState.CiExpansion, representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the computations but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(repType::AtomicState.RasExpansion, representation::AtomicState.Representation)       ... to generate a restricted active-space expansion for a single level symmetry and based on a set of reference configurations         and a number of pre-specified steps. All relevant intermediate and final results are printed to screen (stdout).          Nothing is returned.\n\nBasics.generate(repType::AtomicState.RasExpansion, representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the computations but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(repType::AtomicState.GreenExpansion, representation::AtomicState.Representation)       ... to generate a Green (function) expansion for a given approach and excitation scheme of the electron,         based on a set of reference configurations, a list of level symmetries as well as for given settings.         All relevant intermediate and final results are printed to screen (stdout). Nothing is returned.\n\nBasics.generate(repType::AtomicState.GreenExpansion, representation::AtomicState.Representation; output=true)       ... to generate the same but to return the complete output in a dictionary; the particular output depends on the type and          specifications of the representation but can easily accessed by the keys of this dictionary.\n\n\n\n\n\nBasics.generate(\"condensed multiplet: by single weight\", multiplet::Multiplet)       ... to condense/reduce the number of CSF in the basis of the given multiplet due to a single 'weight';          a multiplet::Multiplet is returned.  Not yet implemented !\n\n\n\n\n\nBasics.generate(\"configuration list: NR, from basis\", basis::Basis)       ... to (re-) generate the list of NR configurations from the given basis; a confList::Array{Configuration,1} is returned.\n\n\n\n\n\nBasics.generate(\"configuration list: NR, single-configuration\", refConf::Configuration, NoExcitations::Int64, fromShells::Array{Shell,1},                     toShells::Array{Shell,1})       ... to generate a non-relativistic configuration list, including the given reference configuration (refConf) and with          all configurations that differ by NoExcitations from the fromShells into the toShells; an Array{Configuration,1}          is returned.\n\n\n\n\n\nBasics.generate(\"shells: ordered list for NR configurations\", confs::Array{Configuration,1})       ... to generate for confs, i.e. all the given (non-relativistic) configurations, a common and ordered shell list;          a list::Array{Shell,1} is returned.\n\n\n\n\n\nBasics.generate(\"subshells: ordered list for two bases\", basisA::Basis,  basisB::Basis)       ... to generate common and ordered subshell list for the two basis A and B; a list::Array{Subshell,1} is returned.\n\n\n\n\n\nBasics.generate(\"single-electron spectrum: STO\", N::Int64, potential::Radial.Potential, grid::Radial.Grid; N_0::Int64=30, alpha_0::Float64=1.0,                     beta_0::Float64=1.1)      ... to generate a complete one-electron spectrum with N positive and N negative states, and by using even-tempered Slater-type          orbitals (STO) with parameters lpha_i = lpha_0 eta_0^i; a spectrum::SingleElecSpectrum is returned where just          N0 positive and N_0 negative are kept for later use.  Not yet implemented !\n\nBasics.generate(\"single-electron spectrum: STO, positive\", N::Int64, potential::Radial.Potential, grid::Radial.Grid; N_0::Int64=30, alpha_0::Float64=1.0,                     beta_0::Float64=1.1)       ... to generate the same but to return only the N_0 positive states.  Not yet implemented !\n\n\n\n\n\n","category":"function"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Well, this is quite a lot, and we shall explain some of these methods below; a similar or even larger output, you can  generate by ? perform as well as few other terms that are central to the implementation of JAC.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Constructors & program control:quad Another frequent use of the (help) \"?\" concerns the data flow and control of  almost all computations. In JAC, we often make use of (so-called) Settings that enable the user to overwrite default  values or to control the computation to the extent, he or she wishes to have control. These Settings are context  dependent and are different for each atomic property or process that can be computed by the JAC toolbox. They are defined  in the various modules and need to be specified accordingly. For instance, to control the computation of transition  probabilities for the (fine-structure) levels between given initial- and final-state configuration, one has to overwrite  the (defaults) settings:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? PhotoEmission.Settings","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"PhotoEmission.Settings","category":"page"},{"location":"getting-started.html#JAC.PhotoEmission.Settings-getting-started","page":"Getting Started","title":"JAC.PhotoEmission.Settings","text":"struct  PhotoEmission.Settings  <:  AbstractProcessSettings       ... defines a type for the details and parameters of computing radiative lines.\n\n+ multipoles              ::Array{EmMultipoles}     ... Specifies the (radiat. field) multipoles to be included.\n+ gauges                  ::Array{UseGauge}         ... Gauges to be included into the computations.\n+ calcAnisotropy          ::Bool                    ... True, if the anisotropy (structure) functions are to be \n                                                        calculated and false otherwise \n+ printBefore             ::Bool                    ... True, if all energies and lines are printed before comput.\n+ corePolarization        ::CorePolarization        ... Parametrization of the core-polarization potential/contribution.\n+ lineSelection           ::LineSelection           ... Specifies the selected levels, if any.\n+ photonEnergyShift       ::Float64                 ... An overall energy shift for all photon energies.\n+ mimimumPhotonEnergy     ::Float64                 ... minimum transition energy for which (photon) transitions \n                                                        are included into the computation.\n+ maximumPhotonEnergy     ::Float64                 ... maximum transition energy for which (photon) transitions \n                                                        are included.\n\n\n\n\n\n","category":"type"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"We shall meet these and (many) other settings quite often in the tutorials below. –- Beside of Julia's help features (?), however, it is sometimes difficult to remember the right term or function name. In this case, it easy to make a <double-tab>  after the dot (notation) or to make use of the (Unix/Linux) grep command within the JAC/src directly. Similar  line-search commands will exist also at other platforms. In particular, for those of you who wishes to support and extend  the JAC toolbox, the dot expansion and the grep command will be found very helpful, perhaps more than other search tools.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"info: Info\nUsers can also refer to the API Reference section that provides a comprehensive list of JAC declared Types and Functions  for selected atomic processes.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Use of constructors:quad Another Julia feature, that is frequently applied in JAC, is the successive definition of  constructors in order to set-up complex data structures. This features is applied, for instance, in order to define an  Atomic.Computation or a Cascade.Computation as a whole. We shall explain these rather complex data types below in  different tutorials. The same issue appears however already at a much simpler level. For example, if we wish to select  (specify) a number of levels from a multiplet prior to some particular – configuration interaction – computation,  we can make use of a","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? LevelSelection","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"LevelSelection","category":"page"},{"location":"getting-started.html#JAC.Basics.LevelSelection-getting-started","page":"Getting Started","title":"JAC.Basics.LevelSelection","text":"struct  Basics.LevelSelection  <  Basics.AbstractSelection       ... defines a struct to specify a list of levels by means of their (level) indices or level symmetries.\n\n+ active       ::Bool                     ... true, if some selection has been made.\n+ indices      ::Array{Int64,1}           ... List of selected indices.\n+ symmetries   ::Array{LevelSymmetry,1}   ... List of selected symmetries\n\n\n\n\n\n","category":"type"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Apart from the logical flag active, such a level selection requires to either specify a list of level numbers (indices)  or level symmetries","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"LevelSelection(true, indices= [i for i in 1:11])","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"LevelSelection(true, symmetries= [LevelSymmetry(1//2, Basics.plus)])","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Here, we made use of a LevelSymmetry to specify the overall rotational J^P symmetry of atomic levels.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? LevelSymmetry","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"LevelSymmetry","category":"page"},{"location":"getting-started.html#JAC.Basics.LevelSymmetry-getting-started","page":"Getting Started","title":"JAC.Basics.LevelSymmetry","text":"struct  Basics.LevelSymmetry  <  AbstractAngularMomentum  ... defines a struct for defining the overall J^P symmetry of a level.\n\n+ J          ::AngularJ64  ... total angular momentum of a level\n+ parity     ::Parity      ... total parity of the level\n\n\n\n\n\n","category":"type"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"As seen from this definition, the level symmetry just comprises the total angular momentum (of type AngularJ64) and  the parity of the level (of type Parity). Therefore, the specification of a list of level symmetries in LevelSelection  already requires to nest four constructors in order make the level selection explicit: (i) For the angular momentum,  (ii) the parity, (iii) the level symmetry and (iv) to create a list (array) of such level symmetries. All the constructors  can be specified and built together also in subsequent steps, such as:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"J1    = AngularJ64(1//2);           J2 = AngularJ64(5//2)  \npl    = Basics.plus;                mn = Basics.minus\nlsym1 = LevelSymmetry(J1, pl);      lsym2 = LevelSymmetry(J2, mn)\nlevelsyms = [lsym1, lsym2]","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"or simply by nesting all the information within a single step","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"levelsyms = [LevelSymmetry(AngularJ64(1//2), Basics.plus), LevelSymmetry(AngularJ64(5//2), Basics.minus)]","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Both way have their pros and cons, and often some mixture is applied where complex constructors are first assigned to  some variables, and which are later utilized to built up constructors of higher complexity. –- To finally specify aǹ  instance of a LevelSelection, we use (onc more) its second constructor above:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"LevelSelection(true, indices=[1,2,3], symmetries=levelsyms)","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"and which will tell the JAC program to compute the lowest three levels (1, 2, 3) as well as all levels with 1/2+ and 5/2-  symmetry. Apart from the selection of individual levels, it is often helpful for the computation of atomic processes to  make a prior LineSelection and in some cases even a PathwaySelection as, for instance, for dielectronic recombination  processes. Some of these features will be explained below in subsequent tutorials of JAC:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Functions & methods:quad Like most other languages, Julia is based on the successive work through functions and  methods; a function is first of all specified by its name and it maps a tuple of argument values upon a return value.  For instance, the function","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"function addSomething(a, b)\n    c = a + b\nend\naddSomething(3.1, 5//2)","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"can be used to add two numbers, rather independent of their particular type, and which are infered here automatically.  However, additional type declarations might help to specialize a function and to ensure type stability:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"function addSomething(a::Int64, b::Int64, c::Int64)\n    d = a + b + c\nend","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"While the function name is the same in both of these examples above, Julia carefully distinguishes between these two  methods of the function addSomething that may differ by the type and/or the number of arguments. This multiple  use (dispatch) of function name enables the user to write highly specialized code. Although a proper (and specialized)  definition of functions is often very important for the performance of the program, we shall not discuss such technical  issues here. Let us just mention, that a function/method may also return nothing:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"typeof(nothing)","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"In JAC, the value nothing is usually returned by all display functions that print some selected data or tabulation  to screen or elsewhere but does not return a value otherwise.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Code failures:quad Beside of its large flexibility and user-friendliness, JAC might terminate from time to time  for non-obvious reasons. Since JAC is first of all a physics code, no attempt has been made that all possible errors  are fully captured and recovered by the program. Wrong input parameters or an inappropriate use of contructors will often  lead to errors that cannot be resolved by the program. While some of this input can be readily recognized as wrong, and  then lead to a proper error message, other wrong data may appear dynamically and cannot be captured with a reasonable  overhead of the code.  In JAC, therefore, several conditional if ... elseif ... else ... end blocks include an additional  clause error(\"stop a\") or similar; these are clauses, which due to a first design of a function should never be entered,  but this appears not to be true in all cases. The use of these (fully) non-instructive error message have still a great  advantage due to Julia: If not switched-off explicitly, Julia always reports for all program failures the hierarchy of  call's, that are made before the error occurs, and lists these calls together with the file and line number of source code. For this reason, an error(\"stop a\") readily shows the position where something unexpected occurs. A short inspection of  the corresponding (line of the) source code often help to understand of what went wrong internally.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Julia macros:quad  What can one do, if the (source) code itself does not tell so much about the problem ? –-  In this case, it is often useful to include some additional printouts  near to the line in question into the code  and to re-run it again. There are different ways (@show, print(), println()) to place printout in the code;  cf. https://julialang.org/learning/  A particular quick and useful way makes use of the Julia macro:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"@show levelsyms","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"which simply repeats the names of the variables together with their values. Of course, the values of several such  variables can be shown within the same call:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"wa = 5;   wb = [2.0, pi];   wc = ones(3)\n@show wa, wb, wc","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Indeed, this @show macro makes printout very easy. There are many macros (all starting with @) in Julia which need  not to be considered here. We just mention that @time in front of a Julia command (block) will take and display the CPU  time that is necessary to run this line(s):","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"@time rand(50000)   ;","category":"page"},{"location":"getting-started.html#...-with-JAC-(in-REPL)","page":"Getting Started","title":"... with JAC (in REPL)","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Getting started with JAC (in REPL)","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"info: Info\nJAC user guide pdf .... link","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"using JAC","category":"page"},{"location":"getting-started.html#Welcome-to-**JAC**,-the-**Jena-Atomic-Calculator**","page":"Getting Started","title":"Welcome to JAC, the Jena Atomic Calculator","text":"","category":"section"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"... that provides various tools for performing atomic (structure) calculations of different kinds and complexities.  Apart from the computation of atomic (many-electron) amplitudes, properties and processes, JAC supports interactive,  restricted-active space (RAS) and cascade computations. It also help perform a few simple hydrogenic and  semi-empirical estimates as well as simplify symbolic expressions from Racah's algebra. –-  Let's first use  ? JAC in order to obtain more information about this toolbox:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? JAC","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"JAC","category":"page"},{"location":"getting-started.html#JAC-getting-started","page":"Getting Started","title":"JAC","text":"module JAC       ... Jena Atomic Calculator (JAC) provides tools for performing atomic (structure) calculations at various degrees of complexity          and sophistication. It has been designed to not only calculate atomic level structures and properties [such as g-factors or         hyperfine and isotope-shift parameters] but also transition amplitudes between bound-state levels [for the anapole moment, dipole          operator, electron electric-dipole moment, parity non-conservation, etc.] and, in particular, (atomic) transition probabilities,          Auger rates, photoionization cross sections, radiative and dielectronic recombination rates as well as cross sections for many          other (elementary) processes. JAC also facilitates interactive computations, the simulation of atomic cascades, the time-evolution          of statistical tensors, a few semi-empirical estimates of atomic properties as well as the simplification of symbolic expressions         from Racah's algebra. – In addition, the JAC module supports the display of level energies, electron and photon spectra,          radial orbitals and other atomic data.\n\nPerform (atomic) computations of different complexity:       JAC will eventually support ten kinds of computations which can be summarized as follows:\n\nAtomic computations, based on explicitly specified electron configurations.\nRestricted active-space computations (RAS).\nInteractive computations.\nAtomic cascade computations (partly implemented).\nAtomic representations (Green and close-coupling functions, complex rotation; partly implemented).\nAtomic responses (partly implemented).\nAtomic descriptors for machine learning algorithms (not yet implemented).\nTime-evolution of statistical tensors in (intense) light pusles (not yet implemented).\nSemi-empirical estimates of cross sections, etc. (partly implemented).\nSymbolic evaluation of expressions from Racah's algebra, etc.\n\nFurther details and information\n\n    + Kinds of atomic implementation                                       [cf. ? Details.kindsOfComputation]\n    + Atomic amplitudes (partly) implemented in JAC                        [cf. ? Details.amplitudes]\n    + Atomic level properties (partly) implemented in JAC                  [cf. ? Details.properties]\n    + Atomic processes (partly) implemented in JAC                         [cf. ? Details.processes]\n    + Interactive use of JAC procedures                                    [cf. ? Details.interactive]\n    + Design principles and limitations of the JAC program                 [cf. ? Details.design]\n    + Data types, structs and name conventions of the JAC module           [cf. ? Details.datatypes]\n    + Atomic cascade computations and approximations                       [cf. ? Details.decayCascades]\n    + Use of (em) light pulses in the time evolution of statist. tensors   [cf. ? Details.pulses]\n    + Why Julia ?                                                          [cf. ? Details.whyJulia]\n\n\n\n\n\n","category":"module"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"H'm, this tells us a lot of details which we still need to better understand. To quickly list the atomic properties,  that have been (partly) considered in JAC, we can use ? Details.properties   or some other of the listed calls:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? Details.properties","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Details.properties","category":"page"},{"location":"getting-started.html#JAC.Details.properties-getting-started","page":"Getting Started","title":"JAC.Details.properties","text":"Atomic properties\n\nApart from approximate level energies and eigenvectors, JAC (will) support the computation of the following level properties:\n\nAlphaX        ... alpha variations; differential sensitivity parameters.\nEinstein      ... Einstein A, B coefficients and oscillator strength; although these coefficients are not an                    original level property, the Einstein module treats these computations within a single                    basis/multiplet and, hence, cannot include relaxation effects, etc. The Einstein                    feature of JAC can be used, however, for a quick overview to transition probabilities                    or in order to simplify cascade computations.\nFormF         ... Standard and modified atomic form factors.\nGreens        ... Greens function of an atomic level.\nHFS           ... Hyperfine A and B parameters.\nIsotope       ... Isotope shift M and F parameters.\nLandeJ        ... Lande g_J factors.\nLandeF        ... Lande g_F factors.\nPolarity      ... Static and dynamic polarizibilities of atomic levels.\nPlasma        ... CI computations including interactions from various plasma models.\nYields        ... Fluoerescence and Auger yields of atomic levels.\n\n\n\n\n\n","category":"function"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"In the design of JAC, we first of all aim for a precise language that (i) is simple enough for both, seldom  and a more frequent use of this package, (ii) highlights the underlying physics and (iii) avoids most technical  slang that is often unnecessary but quite common to many other codes. An intuitive picture about the level or hyperfine  structure of an atom, its properties as well as possible excitation and/or decay processes should (always) come first  in order to generate the desired data: By making use of suitable data types (struct), we indeed wish to  introduce a language close to the underlying formalism. –- While JAC is overall based on a rather large  number ( 300) of such types, a few simple examples are:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"(atomic) Shell:                 quad1s, 2s, 2p, ...\nSubshell:                       quad1s1/2, 2s1/2, 2p1/2, 2p3/2, ...\n(electron) Configuration:       quad1s^2 2s^2 2p^6 3s quad  or quad  [Ne] 3s, ...\nLevel:                          quad1s^2 2s^2  ^1S_0, ...","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"and many other terms (types) that we shall explain later.  ","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Let us simply start, for instance, with specifying and assigning the 1s and 2p shells:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"w1s = Shell(\"1s\")\nw2p = Shell(\"2p\")","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Similarly, we can readily specify and assign any (relativistic) subshell:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Subshell(\"2p_1/2\"),   Subshell(\"2p_3/2\")  ","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"In JAC, we make use of these Shell's and Subshell's whenever they will naturally occur in describing the level  structure or the excitation, decay or occupation of an atom, and this both at input and output. If you have  forgotten how to specify such a subshell (constructor), simply ask:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? Subshell","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Subshell","category":"page"},{"location":"getting-started.html#JAC.Basics.Subshell-getting-started","page":"Getting Started","title":"JAC.Basics.Subshell","text":"struct  Basics.Subshell  ... defines a type for the allowed values of a relativistic subhell.  \n\n+ n        ::Int64  ... principal quantum number \n+ kappa    ::Int64  ... relativistic angular quantum number\n\n\n\n\n\n","category":"type"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Of course, we can interactively also specify any electron configuration:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? Configuration","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"wc1 = Configuration(\"1s^2 2s^2 2p^5\")\nwc2 = Configuration(\"[Ar] 4s^2 3d^5\")","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"info: Info\nFor specific processes users can find the list of types and functions in the API Reference","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"This input just shows three (very) simple examples and how the details of some computation can be readily specified  in line with our basic understanding of the atomic shell model. One can use  ? Details.datatypes  in order to see a  more complete list of most data structures that are speficic to the JAC module ... and which will give you a very  first impression about the size of the JAC program.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? Details.datatypes","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Details.datatypes","category":"page"},{"location":"getting-started.html#JAC.Details.datatypes-getting-started","page":"Getting Started","title":"JAC.Details.datatypes","text":"Data types, structs and name conventions of the JAC module\n\nThe use of a proper terminology and data structures has been found essential for developing the JAC module. Below, we list and briefly explain these data types and how they appear in atomic theory. Although we presently support just a (small) number of frequently requested tasks in  atomic structure and collision theory, we tried to define data types that are flexible enough to further extend these tools in the future. Following the Julia's standard conventions, all types (struct) are named in CamelCase notation.\n\nAbstract data types\n\nAbstractExcitationScheme     ... supports the selection of various (singleton) excitation schemes.\nAbstractQedModel             ... supports the selection of various (singleton) QED models.\n\nBasic data types\n\nAngularJ64                   ... (positive, half-integer) angular momentum, j = 0, 1/2, 1, 3/2, ... .\nAngularM64                   ... (half-integer) projection of ang. momentum, m = -1/2, 0, 1/2, ... can be initialized also                                   w.r.t AngularJ64().\nCartesianVector              ... Cartesian vector of given type.\nContinuumNormalization       ... method for dealing with the normalization of continuum orbitals.\nContinuumPhase               ... method for determining the phase of continuum orbitals.\nContinuumSolutions           ... method for solving continuum orbitals.\nEigen                        ... represents eigenvalues and eigenvectors if different diagonalization procedures are used.\nEmMultipole                  ... a multipole of the em field.\nEmGauge                      ... an allowed gauge form for the em field, for instance, Coulomb, Babushkin, Magnetic, ...\nEmProperty                   ... a given property in Coulomb (velocity) as well as Babushkin (length) gauge.\nEmStokes                     ... (computed) Stokes parameter for the polarization of emitted radiation.\nExpStokes                    ... (experimentally) given Stokes parameter for the polarization of incoming radiation.\nGuint                        ... specifier for dealing with graphical user interfaces (GUI).\nLevelKey                     ... data type for identifying a level by its symmetry, energy, etc.\nLevelSymmetry                ... total level symmetry (J, parity).\nLineKey                      ..  data type for identifying a line by the keys of the initial and final level, ...\nModel                        ... to keep the all nuclear parameters.\nParity                       ... standard parity values\nShell                        ... a non-relativistic shell.\nSolidAngle`                  ... defines a type for a solid angle Omega = (theta, phi).\nSubshell                     ... a relativistic subshell.\nSubshellStateR               ... a relativistic antisymmetric subshell state within the seniority scheme.\nTensorComp                   ... component of the statistical tensor as associated with an atomic level. \nUseGauge                     ... an allowed gauge form requested for explicit computations: UseCoulomb or UseBabushkin.\nWarnings                     ... for dealing with warnings that are made during a run or REPL session.\nWeightedCartesian            ... Cartesian vector with weight factor of given type.\n\nData types from many-electron theory\n\nAsfSettings                  ... settings for SCF and CI computations.\nAtomic.Computation           ... atomic computation of a multiplet, including the SCF, CI and transition properties.\nBasis                        ... (relativistic) atomic basis, including the configuration space and radial orbitals.\nBspline                      ... set of B-splines.\nConfiguration                ... (non-relativistic) electron configuration as specified by its shells and their occupation.\nConfigurationR               ... (relativistic) electron configuration as specified by its subshells and their occupation.\nLevel                        ... atomic level in terms of its quantum number, energy and a (possible) representation.\nMultiplet                    ... an ordered list of atomic levels with a name.\nOrbital                      ... (relativistic) radial orbital function that appears as 'building block' to define many-electron                                    states; more often than not, it just occurs as radial orbital on a given (radial) grid while the                                    angular dependence is given by the subshell label.\nQedPetersburg                ... singleton data type for selecting QED calculations a la St. Petersburg.\nQedSydney                    ... singleton data type for selecting QED calculations a la Sydney.\nNoneQed                      ... singleton data type if no QED corrections are to be calculated.                 \nRadial.Grid                  ... radial grid to represent the (radial) orbitals.\nRadial.Potential             ... radial potential function.\nRadial.Primitives            ... a list of radial functions, that may serve as a set of primitives in SCF computations, together                                    with several parameters for its definition.\nRadial.SingleSymOrbitals     ... a list of radial orbitals with large and small component but of the same symmetry (kappa); such a                                    list may serves as (complete) single-electron basis to deal with second- and higher-order processes.\n\nData types calculating level properties\n\nAbstractLevelProperty        ... an atomic level property that is supported by the JAC module, such as HFS, IsotopeShift, ....\nEinstein.Settings            ... settings for Einstein A and B coefficients, calculated within a single given Multiplet.\nEinstein.Outcome             ... (results of the) Einstein A and B coefficients for a single line.\nHfs.Settings                 ... settings for HFS A and B coefficients.\nHfs.Outcome                  ... (results of the) HFS A and B coefficients for a single level.\nIsotopeShift.Outcome         ... (results of the) M and F isotope-shift parameters for a single level.\nIsotopeShift.Settings        ... settings for the M and F isotope-shift parameters.\nLandeZeeman.sublevelJ        ... specifies a magnetic sublevel with well-defined J.\nLandeZeeman.sublevelF        ... specifies a magnetic hyperfine sublevel with well-defined F, M_f.\nLandeZeeman.Outcome          ... (results of the) Lande factors and Zeeman splittings for a single level.\nLandeZeeman.Settings         ... settings for the Lande factors and Zeeman splitting in an external magnetic field.\n\nData types for calculating (time-independent) atomic processes\n\nAtomicProcess                     ... an atomic process that is supported by the JAC module, such as Auger, photo, ....\nAlphaVariation.Outcome            ... outcome of a alpha-variation computation, such as the K enhancement.\nAlphaVariation.Settings           ... seetings for computing alpha variation parameters.\nAuger.Channel                     ... Auger channel of well-defined energy and partial outgoing wave.\nAuger.Line                        ... Auger line between (two) specified initial- and final-state levels and with (possible) subchannels.\nAuger.Settings                    ... settings for computing Auger lines.\nCoulombExcitation.Channel         ... Coulomb excitation channel of well-defined energy and partial wave.\nCoulombExcitation.Line            ... Coulomb excitation line with (possible) subchannels.\nCoulombExcitation.Settings        ... settings for computing Coulomb excitation  lines.\nCoulombIonization.Channel         ... Coulomb ionization channel of well-defined energy and partial wave.\nCoulombIonization.Line            ... Coulomb ionization line with (possible) subchannels.\nCoulombIonization.Settings        ... settings for computing Coulomb ionization  lines.\nDielectronic.Channel              ... dielectronic-recombination channel of well-defined multipolarity and gauge as well as energy and                                        partial incoming wave.\nDielectronic.Line                 ... dielectronic recombination line between (three) specified initial-, intermediate and final-state                                        levels and with (possible) subchannels.\nDielectronic.Resonance            ... single dielectronic resonance that summarizes all Dielectronic.Line's for some fixed intermediate                                       level within the continuum. \nDielectronic.Settings             ... settings for computing dielectronic recombination lines.\nDecayYield.Outcome                ... outcome of a decay yield computation.\nDecayYield.Settings               ... settings for computing decay yields lines.\nDoubleAutoIonization.Channel      ... DoubleAutoIonization channel of two partial outgoing waves with well-defined energy.\nDoubleAutoIonization.Line         ... DoubleAutoIonization line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.\nDoubleAutoIonization.Settings     ... settings for computing DoubleAutoIonization lines.\nDoublePhotoIonization.Channel     ... DoublePhotoIonization channel of two partial outgoing waves with well-defined energy.\nDoublePhotoIonization.Line        ... DoublePhotoIonization line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.\nDoublePhotoIonization.Settings    ... settings for computing DoublePhotoIonization lines.\nImpactExcitation.Channel          ... electron-impact excitation channel of well-defined energies. partial waves and phases of the                                        incoming and outgoing electrons.\nImpactExcitation.Line             ... electron-impact excitation line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.\nImpactExcitation.Settings         ... settings for computing electron-impact excitation lines.\nImpactExcitationAutoion.Channel   ... electron-impact excitation channel of well-defined energies, partial waves and phases of the                                        incoming and outgoing electrons.\nImpactExcitationAutoion.Pathway   ... electron-impact excitation line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.\nImpactExcitationAutoion.Settings  ... settings for computing electron-impact excitation lines.\nImpactIonization.Channel          ... electron-impact ionization channel of well-defined energies, partial waves and phases of the                                        incoming and outgoing electrons.\nImpactIonization.Line             ... electron-impact ionization line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.\nImpactIonization.Settings         ... settings for computing electron-impact ionization lines.\nMultiPhotonDeExcitation.Channel   ... multi-photon excitation or decay channel with well-defined multipolarities and gauge.\nMultiPhotonDeExcitation.Line      ... multi-photon excitation or decay line between (two) specified initial- and final-state levels                                        and with (possible) subchannels.\nMultiPhotonDeExcitation.Settings  ... settings for computing multi-photon excitation or decay lines.\nMultiPhotonIonization.Channel     ... multi-photon ionization channel with well-defined multipolarities, gauge as well as energy and                                        partial wave of the outgoing electron.\nMultiPhotonIonization.Line        ... multi-photon ionization line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.\nMultiPhotonIonization.Settings    ... settings for computing multi-photon ionization lines.\nMultiPhotonDoubleIon.Channel      ... multi-photon double ionization channel with well-defined multipolarities, gauge as well as energy                                       and partial waves of the (two) outgoing electrons.\nMultiPhotonDoubleIon.Line         ... multi-photon double ionization line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.\nMultiPhotonDoubleIon.Settings     ... settings for computing multi-photon double ionization lines.\nPairAnnihilation1Photon.Channel   ... positron-bound-electron pair annihilation (PEPA) with single-photon emission channel of                                        well-defined multipolarity, gauge as well as energy and partial incoming (positron) wave.\nPairAnnihilation1Photon.Line      ... PEPA with single-photon emission line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.\nPairAnnihilation1Photon.Settings  ... settings for computing PEPA with single-photon emission lines.\nPairAnnihilation2Photon.Channel   ... positron-bound-electron pair annihilation (PEPA) with two-photon emission channel of well-defined                                        multipolarities, gauge as well as energy and partial incoming (positron) wave.\nPairAnnihilation2Photon.Line      ... PEPA with two-photon emission line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.\nPairAnnihilation2Photon.Settings  ... settings for computing PEPA with two-photon emission lines.\nPairProduction.Channel            ... positron-bound-electron pair production (PEPP) by single-photon absorption channel of well-defined                                        multipolarity, gauge as well as energy and partial outgoing (positron) wave.\nPairProduction.Line               ... PEPP by single-photon absorption line between (two) specified initial- and final-state levels and                                        with (possible) subchannels.\nPairProduction.Settings           ... settings for computing PEPP lines.\nPhotoExcitation.Line              ... photoexcitation line between (two) specified initial- and final- state levels and with (possible                                       JAC.PhotoEmission.Channel) subchannels.\nPhotoExcitation.Settings          ... settings for computing photoexcitation lines.\nPhotoExcitationAutoion.Channel    ... photo-excitation autoionization channel of well-defined energies of the incoming photon as well as                                        the partial wave and phase of the outgoing electron.\nPhotoExcitationAutoion.Pathway    ... photo-excitation autoionization pathways between (three) specified initial-, intermediate and                                        final-state levels and with (possible) subchannels.\nPhotoExcitationAutoion.Settings   ... settings for computing photo-excitation autoionization pathways.\nPhotoIonization.Channel           ... photoionization channel of well-defined multipolarity, gauge as well as energy and partial                                        outgoing wave.\nPhotoIonization.Line              ... photoionization line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.\nPhotoIonization.Settings          ... settings for computing photoionization lines.\nPhotoRecombination.Channel        ... Rec channel of well-defined multipolarity and gauge as well as energy and partial incoming wave.\nPhotoRecombination.Line           ... radiative electron capture line between (two) specified initial- and final-state levels and with                                        (possible) subchannels.\nPhotoRecombination.Settings       ... settings for computing radiative electron capture lines.\nPhotoEmission.Channel                 ... radiative channel of well-defined multipolarity and gauge.\nPhotoEmission.Line                    ... radiative line between (two) specified initial- and final-state levels and with (possible) sublines.\nPhotoEmission.Settings                ... settings for computing radiative lines.\nRadiativeAuger.Channel            ... RadiativeAuger channel of a partial outgoing waves and one photon with well-defined energy.\nRadiativeAuger.Line               ... RadiativeAuger line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.\nRadiativeAuger.Settings           ... settings for computing RadiativeAuger lines.\nRadiative.Settings                ... settings for computing radiative lines.\nRayleighCompton.Channel           ... RayleighCompton channel of an incoming and outgoing photon with well-defined energy.\nRayleighCompton.Line              ... RayleighCompton line between (two) specified initial- and final-state levels and with (possible)                                        subchannels.\nRayleighCompton.Settings          ... settings for computing RayleighCompton lines.\nREDA.Channel                      ... resonant electron-excitation (sequential) double-autoionization (REDA) channel of well-defined                                        energies, partial waves and phases of the incoming and outgoing electrons.\nREDA.Pathway                      ... resonant electron-excitation (sequential) double-autoionization (REDA) pathways.between (four)                                        specified initial-, (two) intrmediate and final-state levels and with (possible) subchannels.\nREDA.Settings                     ... settings for computing resonant electron-excitation (sequential) double-autoionization (REDA)                                        pathways.\n\nData types for calculating (time-dependent) atomic processes\n\nPulse.Envelope                       ... defines a type for the envelope (function) of an em pulse with well-defined time delay,                                            amplitude and (normalized) shape function.\nPulse.ExperimentalCharacterization   ... to characterized an experimental or physically described em pulse in terms of its                                            propagation direction, frequency, maximum intensity, pulse length or No. of cycles, time-delay,                                            polarization, etc., i.e. of what is easily accesssible by an experiment.\nPulse.Gaussian                       ... a Gaussian light pulse that is used for evaluating time-dependent statistical tensors.\nPulse.Polarization                   ... defines the polarization of an em pulse in terms of its linear and circular degrees, the                                            direction of the polarization vector or some generalized polarization coefficients.\nPulse.PolarizationType               ... defines the polarization of an experimentally described light pulse as linear, left-circular, ..\nPulse.Shape                          ... defines a shape of a general em pulse as Gaussian, SineSquared, etc.\nPulse.SineSquared                    ... a SinSquared light pulse that is used for evaluating time-dependent statistical tensors.\n\nData types for dealing wiht (time-dependent) statistical tensors\n\nStatistical.ResonanceR      ... a resonance state in the continuum with a well-defined bound-ionic core, one or several electrons                                    in the continuum, a widths as well as a loss rate due to additional decay processes that cannot be                                    accounted for explicitly.\nStatistical.Tensor          ... represents a statistical tensor of given rank k, projection q and which generally depends upon two                                    resonances.\n\nData types for advanced computations\n\nAtomic.CasComputation          ... an individual or a series of systematically enlarged SCF computations.\nAtomic.CasStep                 ... single-step in an (systematically enlarged) SCF calculation.\nAtomic.CasSettings             ... settings for CAS computation.\nCascade.Approach               ... a particular (computational) approach in which a cascade is considered.\nCascade.Block                  ... a block of configurations that are treatet together within a given cascade. \nCascade.Data                   ... all transition data of a cascade as given by a list of lines (of different type).\nCascade.Computation            ... definition of an atomic exciation/decay cascade from which the actual computations can be derived.\nCascade.Level (mutable)        ... defines a level specification for dealing with cascade transitions.\nCascade.LineIndex              ... defines a line index with regard to the various lineLists of data::Cascade.Data.\nCascade.Step                   ... an individual step of a Cascade.Computation that generally combines two ionization states of ions.\nCascade.Simulation             ... simulation of cascade data.\nCascade.SimulationSettings     ... defines settings for performing the simulation of some cascade (data).\nCascade.Settings               ... settings for cascade computations (not yet).\n\n\n\n\n\n","category":"function"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"This list gives further details why Julia (and JAC) is a very suitable and powerful framework for running  – many-electron – atomic computations. ","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Of course, there are many other features that make Julia & JAC as powerful as it is: For example, the user may pre-define  and overwrite the units in which he wishes to communicate with JAC. These units determine how (most of) the input  data are interpreted as well as output data are displayed in tabulations or to screen. The current defaults settings  for the units can be seen by typing:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Basics.display(\"settings\")","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"which show that energies are taken/printed in eV, rates in 1/s, etc. Apart from modifying these defaults directly in the  source code, the can be overwritten by the user at any time of the program executation. This is done by means of  the function","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? Defaults.setDefaults","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Defaults.setDefaults","category":"page"},{"location":"getting-started.html#JAC.Defaults.setDefaults","page":"Getting Started","title":"JAC.Defaults.setDefaults","text":"Defaults.setDefaults()       ... (re-) defines some 'standard' settings which are common to all the computations with the JAC module, and which can          be 'overwritten' by the user. –- An improper setting of some variable may lead to an error message, if recognized         immediately. The following defaults apply if not specified otherwise by the user: the framework is 'relativistic',          energies are given in eV and cross sections in barn. Note that, internally, atomic units are used throughout for          all the computations within the program. nothing is returned if not indicated otherwise.\n\n+ (\"framework: relativistic\")  or  (\"framework: non-relativistic\")\n\n... to define a relativistic or non-relativistic framework for all subsequent computations.\n\n(\"method: continuum, spherical Bessel\")  or  (\"method: continuum, pure sine\")  or     (\"method: continuum, asymptotic Coulomb\")  or  (\"method: continuum, nonrelativistic Coulomb\")  or     (\"method: continuum, Galerkin\")     ... to define a a method for the generation of the continuum orbitals as (pure) spherical Bessel, pure sine,       asymptotic Coulomb, nonrelativistic Coulomb orbital or by means of the B-spline-Galerkin method.\n(\"method: normalization, pure sine\")  or  (\"method: normalization, pure Coulomb\")  or  (\"method: normalization, Ong-Russek\")      ... to define a method for the normalization of the continuum orbitals as asymptotically (pure) sine or Coulomb        functions, or following the procedure by Ong & Russek (1978).\n(\"QED model: Petersburg\")  or  (\"QED model: Sydney\")      ... to define a model for the computation of the QED corrections following the work by Shabaev et al. (2011; Petersburg)        or Flambaum and Ginges (2004; Syney).\n(\"unit: energy\", \"eV\")  or  (\"unit: energy\", \"Kayser\")  or  (\"unit: energy\", \"Hartree\")  or     (\"unit: energy\", \"Hz\")  or  (\"unit: energy\", \"Hz\")     ... to (pre-) define the energy units for all further printouts and communications with the JAC module.\n(\"unit: cross section\", \"a.u.\")  or  (\"unit: cross section\", \"barn\")  or  (\"unit: cross section\", \"Mbarn\")     ... to (pre-) define the unit for the printout of cross sections.\n(\"unit: rate\", \"a.u.\")  or  (\"unit: rate\", \"1/s\")  ... to (pre-) define the unit for the printout of rates.\n(\"unit: resonance strength\", \"a.u.\")  or  (\"unit: resonance strength\", \"barn eV\")  or     (\"unit: resonance strength\", \"cm^2 eV\")  ... to (pre-) define the unit for the printout of resonance strengths.\n(\"unit: time\", \"a.u.\")  or  (\"unit: time\", \"sec\")  or  (\"unit: time\", \"fs\")  or  (\"unit: time\", \"as\")     ... to (pre-) define the unit for the printout and communications of times with the JAC module.\n\n\n\n\n\n(\"relativistic subshell list\", subshells::Array{Subshell,1}; printout::Bool=true)     ... to (pre-) define internally the standard relativistic subshell list on which the standard order of orbitals is based.\n\n\n\n\n\n(\"standard grid\", grid::Radial.Grid; printout::Bool=true)     ... to (pre-) define internally the standard radial grid which is used to represent most orbitals.\n\n\n\n\n\n(\"continuum: potential\", scField::Basics.AbstractScField)     ... to (re-) define the potential that is applied for the generation of the continuum orbitals.\n\n\n\n\n\n(\"QED: damped-hydrogenic\", Znuc::Float64, wa::Array{Float64,1})     ... to (re-) define the lambda-C damped overlap integrals of the lowest kappa-orbitals        [ wa1s1/2, wa2p1/2, wa2p3/2, wa3d3/2, wa3d5/2 ] for the (new) nuclear charge Znuc;        nothing is returned.\n\n\n\n\n\n","category":"function"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"which enables one to re-define various global values of JAC. If we wish to enter/display energies in Kaysers or  cross sections in atomic units, we can simply type:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Defaults.setDefaults(\"unit: energy\", \"Kayser\")\nDefaults.setDefaults(\"unit: cross section\", \"a.u.\")","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Here, again nothing is returned but the corresponding global constants are now changed.","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Basics.display(\"settings\")","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Apart from the default units, one can similarly overwrite the method that is use for the generation and normalization  of continuum orbitals and several others. Although called global, the corresponding values can be accesses just in  two ways. (i) The global constants, such as the electron mass, the speed of light, the fine-structure constant alpha,  etc., are accessed via the function:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? Defaults.getDefaults","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Defaults.getDefaults","category":"page"},{"location":"getting-started.html#JAC.Defaults.getDefaults","page":"Getting Started","title":"JAC.Defaults.getDefaults","text":"Defaults.getDefaults()       ... gives/supplies different information about the (present) framework of the computation or about some          given data; cf. Defaults.setDefaults(). \n\n(\"alpha\")  or  (\"fine-structure constant alpha\")      ... to get the (current) value::Float64 of the fine-structure constant alpha.\n(\"electron mass: kg\")  or  (\"electron mass: amu\")     ... to get the (current) value::Float64 of the electron mass in the specified unit.\n(\"framework\")  ... to give the (current) setting::String  of the overall framework.\n(\"electron rest energy\")  or  (\"mc^2\")  ... to get the electron rest energy.\n(\"electron g-factor\")  ... to give the electron g-factor g_s = 2.00232.\n(\"unit: energy\")  or  (\"unit: cross section\")  or  (\"unit: rate\")  or  (\"unit: strength\")  or  (\"unit: time\")     ... to get the corresponding (user-defined) unit::String for the current computations.\n(\"standard grid\")     ... to get the (current standard) grid::Array{Float64,1} to which all radial orbital functions usually refer.\n(\"speed of light: c\")  ... to get the speed of light in atomic units.\n(\"summary flag/stream\")     ... to get the logical flag and stream for printing a summary file; a tupel (flag, iostream) is returned.\n\n\n\n\n\n(\"ordered shell list: non-relativistic\", n_max::Int64)     ... to give an ordered list of non-relativistic shells::Array{Shell,1} up to the (maximum) principal number n_max.\n(\"ordered subshell list: relativistic\", n_max::Int64)      ... to give an ordered list of relativistic subshells::Array{Subshell,1} up to the (maximum) principal number n_max.\n\n\n\n\n\n","category":"function"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Defaults.getDefaults(\"alpha\")\nDefaults.getDefaults(\"electron rest energy\")\nDefaults.getDefaults(\"unit: energy\")","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"(ii) These global values are frequently applied in order to – internally or externally – convert physical numbers  into units of the same dimension. This is done by the function:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"? Defaults.convertUnits","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Defaults.convertUnits","category":"page"},{"location":"getting-started.html#JAC.Defaults.convertUnits","page":"Getting Started","title":"JAC.Defaults.convertUnits","text":"Defaults.convertUnits()       ... converts some data from one format/unit into another one; cf. the supported keystrings and return values.\n\n(\"cross section: from atomic to predefined unit\", value::Float64)  or  (\"cross section: from atomic\", value::Float64)     ... to convert an cross section value from atomic to the predefined cross section unit; a Float64 is returned.\n(\"cross section: from barn to atomic unit\", value::Float64)    ... to convert an cross section value from barn atomic section unit; a Float64 is returned.\n(\"cross section: from atomic to barn\", value::Float64)  or  (\"cross section: from atomic to Mbarn\", value::Float64)  or   (\"cross section: from atomic to cm^2\", value::Float64)    ... to convert an energy value from atomic to the speficied cross section unit; a Float64 is returned.\n(\"cross section: from predefined to atomic unit\", value::Float64)  or  (\"cross section: to atomic\", value::Float64)   ... to convert a cross section value from the predefined to the atomic cross section unit; a Float64 is returned.\n(\"einstein B: from atomic\", value::Float64)     ... to convert a Einstein B coefficient from atomic to the speficied energy units; a Float64 is returned.\n(\"density: from [g/cm^3] to atomic\", value::Float64)     ... to convert a mass density from [g/cm^3] to atomic units [u/a_o^3]; a Float64 is returned.\n(\"energy-diff. cross section: from atomic to predefined unit\", value::Float64)  or     (\"energy-diff. cross section: from atomic\", value::Float64)     ... to convert an energy-diff. cross section value from atomic to the predefined energy-diff. cross section unit;        a Float64 is returned.\n(\"energy: from atomic to eV\", value::Float64)  or  (\"energy: from atomic to Kayser\", value::Float64)    or   (\"energy: from atomic to Hz\", value::Float64)  or  (\"energy: from atomic to Angstrom\", value::Float64)  or   (\"energy: from atomic to Ws\", value::Float64)   ... to convert an energy value from atomic to the speficied energy unit; a Float64 is returned.\n(\"energy: from predefined to atomic unit\", value::Float64)  or  (\"energy: to atomic\", value::Float64)... to convert an energy value                                                from the predefined to the atomic energy unit; a Float64 is returned.\n(\"energy: from eV to atomic\", value::Float64) ... to convert an energy value from eV to the atomic energy unit; a Float64 is returned.\n(\"energy: from wavelength [nm] to atomic\", value::Float64) ... to convert a wavelength [nm] to the atomic energy unit; a Float64 is returned.\n(\"intensity: from W/cm^2 to atomic\", value::Float64) ... to convert the intensity [in W/cm^2] to the atomic intensity unit; a Float64 is returned.\n(\"kinetic energy to wave number: atomic units\", value::Float64)  ... to convert a kinetic energy value (in a.u.) into a wave number                                               k (a.u.); a Float64 is returned.\n(\"kinetic energy to wavelength: atomic units\", value::Float64)  ... to convert a kinetic energy value (in a.u.) into a wavelength (a.u.);                                                a Float64 is returned.\n(\"length: from fm to atomic\", value::Float64)  ... to convert a length value (in fm) into a.u.;  a Float64 is returned.\n(\"length: from atomic to fm\", value::Float64)  or  (\"energy: from atomic to Kayser\", value::Float64)     ... to convert a length value (in Bohr's a.u.) to the speficied length unit;  a Float64 is returned.\n(\"rate: from atomic to predefined unit\", value::Float64)  or  (\"rate: from atomic\", value::Float64)  ... to convert a rate value                                            from atomic to the predefined rate unit; a Float64 is returned.\n(\"rate: from atomic to 1/s\", value::Float64)  ... to convert an rate value from atomic to the speficied rate unit; a Float64 is returned.\n(\"rate: from predefined to atomic unit\", value::Float64)  or  `(\"rate: to atomic\", value::Float64)'... to convert a                                               rate value from the predefined to the atomic rate unit; a Float64 is returned.\n\n(\"strength: from atomic to predefined unit\", value::Float64)  or  (\"strength: from atomic\", value::Float64)  ... to convert a (resonance)                                                strength value from atomic to the predefined rate unit; a Float64 is returned.\n(\"time: from atomic to predefined unit\", value::Float64)  or  (\"time: from atomic\", value::Float64)  ... to convert an time value                                            from atomic to the predefined time unit; a Float64 is returned.\n(\"time: from atomic to sec\", value::Float64)  or  (\"time: from atomic to fs\", value::Float64)'  or(\"time: from atomic to as\", value::Float64)`  ... to convert a time value from atomic to the speficied time unit; a Float64 is returned.\n(\"time: from predefined to atomic unit\", value::Float64)  or  `(\"time: to atomic\", value::Float64)'  ... to convert a                                           time value from the predefined to the atomic time unit; a Float64 is returned.\n(\"temperature: from Kelvin to (Hartree) units\", value::Float64)  ... to convert a temperature in Kelvin into atomic (Hartree) units;                                                a Float64 is returned.\n(\"temperature: from atomic to Kelvin\", value::Float64)  ... to convert an atomic (energy) unit into Kelvin; 1 Hartree = 315774.64 K;                                                a Float64 is returned.\n(\"wave number to total electron energy: atomic units\", value::Float64)  ... to convert a wavenumber (a.u.) into the total electron                                           energy, including the rest energy; a Float64 is returned.\n(\"wave number to kinetic energy: atomic units\", value::Float64)  ... to convert a wavenumber (a.u.) into the kinetic energy;                                            a Float64 is returned.\n\n\n\n\n\n(string, values::Array{Float64,1})     ... to convert for the same strings as above but for an list of values; a corresponding Array{Float64,1} is returned.\n\n\n\n\n\n","category":"function"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"This function is called at many places within JAC to generate tables where all physical data are printed out in the  pre-specified units:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Defaults.convertUnits(\"energy: from atomic\", 1.0)","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"With the given user-selection, this is equivalent to:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"Defaults.convertUnits(\"energy: from atomic to Kayser\", 1.0)","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"In JAC, the call of this function is often combined with some proper formatting of the results, such as:","category":"page"},{"location":"getting-started.html","page":"Getting Started","title":"Getting Started","text":"using Printf\n@sprintf(\"%.4e\", Defaults.convertUnits(\"energy: from atomic\", 1.0))","category":"page"},{"location":"api-cascades.html#Cascade-computations","page":"API Cascade computations","title":"Cascade computations","text":"","category":"section"},{"location":"api-cascades.html","page":"API Cascade computations","title":"API Cascade computations","text":"Modules = [Cascade]\nOrder   = [:type, :function]","category":"page"},{"location":"api-cascades.html#JAC.Cascade.AbsorptionCrossSection","page":"API Cascade computations","title":"JAC.Cascade.AbsorptionCrossSection","text":"struct  Cascade.AbsorptionCrossSection       ... defines the absorption cross section for a particular (incident) photon energy in terms of its discrete and          (direct photoionization) contributions. Of course, this absorption cross section depends on the relative population         of the initial levels.\n\n+ photonEnergy ::Float64              ... incident photon energy/photon-energy dependence of the absorption spectrum.\n+ excitationCS ::Basics.EmProperty    ... contribution due to discrete excitation processes.\n+ ionizationCS ::Basics.EmProperty    ... contribution due to contineous ionization processes.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.AbstractCascadeApproach","page":"API Cascade computations","title":"JAC.Cascade.AbstractCascadeApproach","text":"abstract type Cascade.AbstractCascadeApproach      ... defines an abstract and a number of singleton types for the computational approach/model that is applied in order to          generate and evaluate all many-electron amplitudes of a given cascade.\n\n+ struct AverageSCA         \n... all levels in the cascade are described in single-configuration and single-CSF approximation; this (rather crude) approach \n    neglects all configuration-interactions and also applies just a single set of one-electron orbitals (from the least-ionized charge\n    state) for all considered charge states.\n    \n+ struct SCA                \n... all levels in the cascade are described in single-configuration approximation but with 'mixtures' within the configuration;\n    an individual mean-field is generated for each charge state and all continuum orbitals are generated for the correct transition\n    energy in the field of the remaining ion. Moreover, all the fine-structure transitions are calculated individually.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.AbstractCascadeScheme","page":"API Cascade computations","title":"JAC.Cascade.AbstractCascadeScheme","text":"abstract type Cascade.AbstractCascadeScheme      ... defines an abstract type to distinguish different excitation, ionization and decay schemes of an atomic cascade; see also:\n\n+ struct DielectronicCaptureScheme  \n    ... to model just the (dielectronic) capture and the formation of doubly-excited levels up to a maximum excitation \n        energy and for a given list of subshells; the excitation energy refers to the lowest level of the reference \n        configurations, and the cascade blocks are built only by means of the given subshells.\n        NOTE: The original DielectronicCaptureScheme --> DielectronicRecombinationScheme has been renamed in \n        August 2023 in order to enlarge the consistency of the notations and code !!\n+ struct DielectronicRecombinationScheme  \n    ... to model the (dielectronic) recombination of an electron up to a maximum excitation energy and for a given \n        list of subshells; the excitation energy refers to the lowest level of the reference configurations, and \n        cascade blocks are built only by means of the given subshells.\n+ struct ElectronExcitationScheme  \n    ... to model the electron excitation spectra in terms of the direct (EIE) and resonant contributions, i.e. the \n        dielectronic capture of an electron with subsequent re-autoionization. Typical electron-excitation properties are \n        energy-dependent EIE cross sections, effective collision strengths, EIE plasma rate coefficients, and several\n        others (not yet).\n+ struct ElectronIonizationScheme  \n    ... to model the electron ionization spectra including the direct (EII) and resonant contributions, i.e. the \n        dielectronic capture of an electron with subsequent double-autoionization. For this double autoionization, a \n        branching factor will just be estimated. Typical electron-ionization properties are energy-dependent EII cross \n        sections, effective collision strengths for impact-ionization, EII plasma rate coefficients, and several others \n        (not yet).\n+ struct ExpansionOpacityScheme  \n    ... to model the expansion opacity of an ion in its ground or some low-lying state; this scheme takes a maximum photon\n        (transition) energy and the excitation from the fromShells to the toShells in order to select the relevant \n        configurations. These shell lists refer to the given set of reference configurations.\n+ struct HollowIonScheme    \n    ... to model the capture of one or several electrons into a list of subshells; various distributions of the\n        electron among these shells are supported. For the subsequent decay, the list of decay shells need to be specified\n        as well.\n+ struct ImpactExcitationScheme    \n    ... to model the (direct) electron-impact excitation  (collision strength) of atoms from some initial to final \n        fine-structure level, and for a list of impact energies (not yet).\n+ struct ImpactIonizationScheme    \n    ... to model the (direct) electron-impact ionization  (collision strength) of atoms from some initial to final \n        fine-structure level, and for a list of impact energies. It typically applies some empirical cross sections \n        (not yet).\n+ struct PhotoAbsorptionScheme    \n    ... to model photoabsortion spectra, including the direct and resonant contributions, i.e. the photoexcitation\n        of an inner-shell electron with subsequent electron emission. Typical photoabsorption properties are the\n        energy-dependent photoionization cross sections, photoabsorption spectra, PI plasma rate coefficients, and \n        several others.\n+ struct PhotoExcitationScheme    \n    ... to model the (prior) photo-excitation part of an overall photoabsorption process; it considers a set of \n        inner-shell excitations with regard to the list of reference configurations. This cascade scheme is mainly\n        used to compute the resonant contributions to photoabsorption or the initial excitations for a subsequent\n        decay cascade.\n+ struct PhotoIonizationScheme    \n    ... to model the photoionization a basic part of photoabsortion. Typical photoionization properties are the \n        energy-dependent partial and total photoionization cross sections for a range of photon energies\n        and several others.\n+ struct RadiativeRecombinationScheme  \n    ... to model the radiative recombination (capture) of an electron up to a maximum free-electron energy as well as\n        for a given list of shells (intoShells), into which the capture is considered; the energy of the emitted photons then\n        refer to the levels of the reference configurations, and all cascade blocks are built only with the given intoShells.\n+ struct StepwiseDecayScheme       \n    ... to model a standard decay scheme in terms of radiative and non-radiative transitions by starting from \n        the levels of one or several initial multiplets. Typical decay properties are ion distributions as well as\n        photon and electron spectra from such cascades.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.AbstractOpacityDependence","page":"API Cascade computations","title":"JAC.Cascade.AbstractOpacityDependence","text":"abstract type  Cascade.AbstractOpacityDependence`       ... defines an abstract type to distinguish different dependencies for the opacity; see also:\n\n+ struct FrequencyOpacityDependence     ... to deal with omega-dependence opacities [omega].\n+ struct WavelengthOpacityDependence    ... to deal with wavelength-dependence opacities [lambda].\n+ struct TemperatureOpacityDependence   ... to deal with temperature-normalized dependent opacities [u].\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.AbstractSimulationMethod","page":"API Cascade computations","title":"JAC.Cascade.AbstractSimulationMethod","text":"abstract type  Cascade.AbstractSimulationMethod`       ... defines a abstract and a list of singleton data types for the properties that can be 'simulated' from a given         list of lines.\n\n+ struct ProbPropagation     ... to propagate the (occupation) probabilites of the levels until no further changes occur.\n+ struct MonteCarlo          ... to simulate the cascade decay by a Monte-Carlo approach of possible pathes (not yet considered).\n+ struct RateEquations       ... to solve the cascade by a set of rate equations (not yet considered).\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.AbstractSimulationProperty","page":"API Cascade computations","title":"JAC.Cascade.AbstractSimulationProperty","text":"abstract type  Cascade.AbstractSimulationProperty       ... defines an abstract and various singleton types for the different properties that can be obtained from the simulation of          cascade data.\n\n+ struct DecayPathes                ... determine the major 'decay pathes' of the cascade.\n+ struct DrRateCoefficients         ... simulate the DR (plasma) rate coefficients for given plasma temperatures. \n+ struct ElectronCoincidence        ... simulate electron-coincidence spectra (not yet).\n+ struct FinalLevelDistribution     ... simulate the 'final-level distribution' as it is found after all cascade \n                                        processes are completed.\n+ struct IonDistribution            ... simulate the 'ion distribution' as it is found after all cascade processes are completed.\n+ struct MeanLineWidths             ... simulate the mean line widths of a line near to a given energy (not yet). \n+ struct MeanRelaxationTime         ... simulate the mean relaxation times in which 70%, 80%, of the occupied levels\n                                        decay to the ground configuration.        \n+ struct ElectronIntensities        ... simulate the electron-line intensities as function of electron energy.\n+ struct PhotoAbsorptionCS          ... simulate the (total) photoabsorption cross sections for a given set of photo-excitation \n                                        and ionization processes.\n+ struct PhotoResonances            ... simulate the position and strength of photo-resonances for a given set of photo-excitation \n                                        amplitudes & cross sections (not yet).\n+ struct PhotonIntensities          ... simulate the photon-line intensities as function of electron energy. \n+ struct PiRateCoefficients         ... simulate the PI (plasma) rate coefficients for given plasma temperatures (not yet). \n+ struct TimeBinnedPhotonIntensity  ... simulate the photon-line intensities as function of electron energy \n                                        in a given time interval (not yet).\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.Block","page":"API Cascade computations","title":"JAC.Cascade.Block","text":"struct  Cascade.Block       ... defines a type for an individual block of configurations that are treatet together within the cascade. Such an block is given          by a list of configurations that may occur as initial- and/or final-state configurations in some step of the canscade and that          give rise to a common multiplet in order to allow for configuration interactions but to avoid 'double counting' of individual          levels in the cascade.\n\n+ NoElectrons     ::Int64                     ... Number of electrons in this block.\n+ confs           ::Array{Configuration,1}    ... List of one or several configurations that define the multiplet.\n+ hasMultiplet    ::Bool                      \n    ... true if the (level representation in the) multiplet has already been computed and false otherwise.\n+ multiplet       ::Multiplet                 ... Multiplet of the this block.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.Block-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.Block","text":"Cascade.Block()  ... constructor for an 'empty' instance of a Cascade.Block.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.Computation","page":"API Cascade computations","title":"JAC.Cascade.Computation","text":"struct  Cascade.Computation       ... defines a type for a cascade computation, i.e. for the computation of a whole photon excitation, photon ionization and/or          decay cascade. The – input and control – data from this computation can be modified, adapted and refined to the practical needs,          and before the actual computations are carried out explictly. Initially, this struct just contains the physical meta-data about the          cascade, that is to be calculated, but a new instance of the same Cascade.Computation gets later enlarged in course of the          computation in order to keep also wave functions, level multiplets, etc.\n\n+ name               ::String                          ... A name for the cascade\n+ nuclearModel       ::Nuclear.Model                   ... Model, charge and parameters of the nucleus.\n+ grid               ::Radial.Grid                     ... The radial grid to be used for the computation.\n+ asfSettings        ::AsfSettings                     ... Provides the settings for the SCF process.\n+ scheme             ::Cascade.AbstractCascadeScheme   ... Scheme of the atomic cascade (photoionization, decay, ...)\n+ approach           ::Cascade.AbstractCascadeApproach \n    ... Computational approach/model that is applied to generate and evaluate the cascade; possible approaches are: \n        {AverageSCA(), SCA(), ...}\n+ initialConfs       ::Array{Configuration,1}          \n    ... List of one or several configurations that contain the level(s) from which the cascade starts.\n+ initialMultiplets  ::Array{Multiplet,1}              \n    ... List of one or several (initial) multiplets; either initialConfs 'xor' initialMultiplets can  be specified \n        for a given cascade computation.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.Computation-Tuple{JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Cascade.Computation","text":"Cascade.Computation(comp::Cascade.Computation;\n\n        name=..,               nuclearModel=..,             grid=..,              asfSettings=..,     \n        scheme=..,             approach=..,                 initialConfigs=..,    initialMultiplets=..)\n        \n... constructor for re-defining the computation::Cascade.Computation.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.Computation-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.Computation","text":"Cascade.Computation()  ... constructor for an 'default' instance of a Cascade.Computation.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.Data","page":"API Cascade computations","title":"JAC.Cascade.Data","text":"struct  Cascade.Data{T}  ... defines a type for communicating different line lists to the cascade simulations\n\n+ lines    ::Array{T,1}       ... List of lines to type T.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.DielectronicCaptureScheme","page":"API Cascade computations","title":"JAC.Cascade.DielectronicCaptureScheme","text":"struct  Cascade.DielectronicCaptureScheme  <:  Cascade.AbstractCascadeScheme       ... to model just the (dielectronic) capture and the formation of doubly-excited levels up to a maximum excitation          energy and for a given list of subshells; the excitation energy refers to the lowest level of the reference          configurations, and the cascade blocks are built only by means of the given subshells.         NOTE: The original DielectronicCaptureScheme –> DielectronicRecombinationScheme has been renamed in          August 2023 in order to enlarge the consistency of the notations and code !!\n\n+ maxExcitationEnergy   ::Float64                 \n    ... Maximum excitation energy [in a.u.] with regard to the reference configurations/levels that restrict the number \n        of excited configurations to be taken into accout. This maximum excitation energy has to be derived from the maximum \n        temperature for which DR coefficients need to be derived and is typically set to 5x T_e,max.\n+ electronEnergyShift   ::Float64                 \n    ... Energy shift for all resonance energies; this is realized by shifting the initial level energies by the negative amount.\n        The shift is taken in the user-defined units.\n+ NoExcitations         ::Int64                 \n    ... (Maximum) Number of electron replacements in the doubly-excited configuration with regard to the initial \n        configurations/multiplets, apart from one additional electron due to the electron capture itself.\n+ excitationFromShells  ::Array{Shell,1}    \n    ... List of shells from which excitations are to be considered.\n+ excitationToShells  ::Array{Shell,1}    \n    ... List of shells to which (core-shell) excitations are to be considered.\n+ intoShells            ::Array{Shell,1}\n    ... List of shells into which electrons are initially placed (captured).\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.DielectronicCaptureScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.DielectronicCaptureScheme","text":"Cascade.DielectronicCaptureScheme()  ... constructor for an 'default' instance of a Cascade.DielectronicCaptureScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.DielectronicRecombinationScheme","page":"API Cascade computations","title":"JAC.Cascade.DielectronicRecombinationScheme","text":"struct  Cascade.DielectronicRecombinationScheme  <:  Cascade.AbstractCascadeScheme       ... a struct to define and describe the dielectronic recombination of electrons for an atom in some initial state/configuration;         for such a scheme, the doubly-excited configurations due to the electron capture are generated automatically due to         given maximal numbers of the (into-) shells (nl) as well as the maximum displacement with regard to the initial configuration.         An additional maximum excitation energy need to be provided due to the maximum temperatures for which DR plasma rate coefficients         are to be determined, cf. Basics.convert().\n\n+ multipoles            ::Array{EmMultipole}           \n    ... Multipoles of the radiation field that are to be included into the radiative stabilization processes.\n+ maxExcitationEnergy   ::Float64                 \n    ... Maximum excitation energy [in a.u.] with regard to the reference configurations/levels that restrict the number \n        of excited configurations to be taken into accout. This maximum excitation energy has to be derived from the maximum \n        temperature for which DR coefficients need to be derived and is typically set to 5x T_e,max.\n+ electronEnergyShift   ::Float64                 \n    ... Energy shift for all resonance energies; this is realized by shifting the initial level energies by the negative amount.\n        The shift is taken in the user-defined units.\n+ minPhotonEnergy       ::Float64                 \n    ... Minimum (mean) photon energy [in a.u.] in the radiative stabilization of the doubly-excited configurations; \n        If cascade blocks are separated be less than this energy, the radiative stabilization is neglected.\n+ NoExcitations         ::Int64                 \n    ... (Maximum) Number of electron replacements in the doubly-excited configuration with regard to the initial \n        configurations/multiplets, apart from one additional electron due to the electron capture itself.\n+ excitationFromShells  ::Array{Shell,1}    \n    ... List of shells from which excitations are to be considered.\n+ excitationToShells  ::Array{Shell,1}    \n    ... List of shells to which (core-shell) excitations are to be considered.\n+ intoShells            ::Array{Shell,1}\n    ... List of shells into which electrons are initially placed (captured).\n+ decayShells           ::Array{Shell,1}\n    ... List of shells into which electrons the electrons can decay (apart from the core shells).\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.DielectronicRecombinationScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.DielectronicRecombinationScheme","text":"Cascade.DielectronicRecombinationScheme()  ... constructor for an 'default' instance of a Cascade.DielectronicRecombinationScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.DrRateCoefficients","page":"API Cascade computations","title":"JAC.Cascade.DrRateCoefficients","text":"struct  Cascade.DrRateCoefficients   <:  Cascade.AbstractSimulationProperty       ... defines a type for simulating the DR plasma rate coefficients as function of the (free) electron energy and         plasma temperature.\n\n+ initialLevelNo      ::Int64       ... Level No of initial level for which rate coefficients are to be computed.\n+ electronEnergyShift ::Float64     \n    ... (total) energy shifts that apply to all resonances when alpha^(DR) is computed.\n+ temperatures        ::Array{Float64,1}\n    ... temperatures [K] for which the DR plasma rate coefficieints to be calculated.\n+ nDetailed           ::Int64       \n    ... principal quantum of the `last' shell for which Auger and radiatiative amplitudes have been calculated\n        by the Cascade.Computation; all contributions of this shell are scaled for nDetailed < n <= nMax\n        also for higher shells by a simple scaling rule.\n+ nMax                ::Int64 \n    ... Maximum n (principal quantum number), for which contributions are scaled; NO scaling is taken\n        into account for nMax <= nDetailed.\n+ resonanceSelection  ::DielectronicRecombination.ResonanceSelection\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.DrRateCoefficients-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.DrRateCoefficients","text":"Cascade.DrRateCoefficients()  ... (simple) constructor for cascade DrRateCoefficients.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.ElectronExcitationScheme","page":"API Cascade computations","title":"JAC.Cascade.ElectronExcitationScheme","text":"struct  Cascade.ElectronExcitationScheme  <:  Cascade.AbstractCascadeScheme           ... to compute electron excitation spectra including the direct (EIE) and resonant contributions, i.e. the dielectronic             capture with subsequent re-autoionization. Typical electron-excitation properties are energy-dependent              EIE cross sections, effective collision strengths, EIE plasma rate coefficients, and others.\n\n+ processes             ::Array{Basics.AbstractProcess,1} \n    ... List of the atomic processes that are supported and should be included into the cascade.\n+ electronEnergies      ::Array{Float64,1}                \n    ... List of electron energies for which this electron-impact excitation scheme is to be calculated.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.ElectronExcitationScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.ElectronExcitationScheme","text":"Cascade.ElectronExcitationScheme()  ... constructor for an 'default' instance of a Cascade.ElectronExcitationScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.ElectronIntensities","page":"API Cascade computations","title":"JAC.Cascade.ElectronIntensities","text":"struct  Cascade.ElectronIntensities   <:  Cascade.AbstractSimulationProperty       ... defines a type for simulating the electron-line intensities as function of electron energy.\n\n+ minElectronEnergy   ::Float64     ... Minimum electron energy for the simulation of electron spectra.\n+ maxElectronEnergy   ::Float64     ... Maximum electron energy for the simulation of electron spectra.\n+ initialOccupations  ::Array{Tuple{Int64,Float64},1}   \n    ... List of one or several (tupels of) levels in the overall cascade tree together with their relative population.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.ElectronIntensities-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.ElectronIntensities","text":"Cascade.ElectronIntensities()  ... (simple) constructor for cascade ElectronIntensities.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.ElectronIonizationScheme","page":"API Cascade computations","title":"JAC.Cascade.ElectronIonizationScheme","text":"struct  Cascade.ElectronIonizationScheme  <:  Cascade.AbstractCascadeScheme           ... to compute electron ionization spectra including the direct (EII) and resonant contributions, i.e. the dielectronic             capture with subsequent double-autoionization. For this double autoionization, a branching factor is estimated.             Typical electron-ionization properties are energy-dependent EII cross sections, effective collision strengths,              EII plasma rate coefficients, and others (not yet).\n\n+ processes             ::Array{Basics.AbstractProcess,1} \n    ... List of the atomic processes that are supported and should be included into the cascade.\n+ electronEnergies      ::Array{Float64,1}                \n    ... List of electron energies for which this electron-impact excitation scheme is to be calculated.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.ElectronIonizationScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.ElectronIonizationScheme","text":"Cascade.ElectronIonizationScheme()  ... constructor for an 'default' instance of a Cascade.ElectronIonizationScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.ExpansionOpacities","page":"API Cascade computations","title":"JAC.Cascade.ExpansionOpacities","text":"struct  Cascade.ExpansionOpacities   <:  Cascade.AbstractSimulationProperty       ... defines a type for simulating the expansion opacity as function of the wavelength as well as (parametrically) the density         and expansion time.\n\n+ levelPopulation        ::Basics.AbstractLevelPopulation  \n    ... to specify the kind of level population that is considered for the given opacity calculations.\n+ opacityDependence      ::Cascade.AbstractOpacityDependence    \n    ... to specify the dependence of the opacities [omega, lambda, (temperature-normalized) u]\n+ ionDensity             ::Float64       ... ion density [in g/cm^3]\n+ temperature            ::Float64       ... temperature [in K]\n+ expansionTime          ::Float64       ... (expansion/observation) time [in sec]\n+ transitionEnergyShift  ::Float64     \n    ... (total) energy shifts that apply to all transition energies; the amplitudes are re-scaled accordingly.\n+ dependencyValues       ::Array{Float64,1}\n    ... values [in a.u.] for which the expansion opacity is to be calculated.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.ExpansionOpacities-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.ExpansionOpacities","text":"Cascade.ExpansionOpacities()  ... (simple) constructor for expansion opacity simulations.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.ExpansionOpacityScheme","page":"API Cascade computations","title":"JAC.Cascade.ExpansionOpacityScheme","text":"struct  Cascade.ExpansionOpacityScheme  <:  Cascade.AbstractCascadeScheme       ... a struct to define and describe the expansion opacity of ions in some initial state/configuration; for this scheme,         the excited (even- and odd-parity) configurations due to the photoabsorption and emission in a plasma are generated automatically          in terms of the chosen excitation scheme and a maximum photon (transition) energy that is taken into account.\n\n+ multipoles            ::Array{EmMultipole}           \n    ... Multipoles of the radiation field that are to be included for the radiative transitions in the plasma.\n+ minPhotonEnergy       ::Float64                 \n    ... Minimum photon (transition) energy [in a.u.] that are taken into account for all absorption lines; \n        this transition energy refers to the longest wavelength for which transition amplitudes are calculated.\n+ maxPhotonEnergy       ::Float64                 \n    ... Maximum photon (transition) energy [in a.u.] that are taken into account for all absorption lines; \n        this transition energy refers to the shortest wavelength for which the opacity is needed.\n+ meanEnergyShift       ::Float64                 \n    ... Energy shift for all excited configurations [in a.u.]; this allows to correct for missing correlation \n        contributions.\n+ NoExcitations         ::Int64                 \n    ... (Maximum) Number of electron replacements in the excited configuration with regard to the initial configurations/multiplets.\n+ excitationFromShells  ::Array{Shell,1}    \n    ... List of shells from which excitations are to be considered.\n+ excitationToShells    ::Array{Shell,1}    \n    ... List of shells to which excitations are to be considered.\n+ printTransitions      ::Bool      ... Print transition data for comparison, if true.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.ExpansionOpacityScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.ExpansionOpacityScheme","text":"Cascade.ExpansionOpacityScheme()  ... constructor for an 'default' instance of a Cascade.ExpansionOpacityScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.FinalLevelDistribution","page":"API Cascade computations","title":"JAC.Cascade.FinalLevelDistribution","text":"struct  Cascade.FinalLevelDistribution   <:  Cascade.AbstractSimulationProperty       ... defines a type for simulating the 'final-level distribution' as it is found after all cascade processes are completed.\n\n+ initialOccupations  ::Array{Tuple{Int64,Float64},1}   \n    ... List of one or several (tupels of) levels in the overall cascade tree together with their relative population.\n+ leadingConfigs      ::Array{Configuration,1}   \n    ... List of leading configurations whose levels are equally populated, either initially or ....\n+ finalConfigs        ::Array{Configuration,1}   \n    ... List of final configurations whose level population are to be \"listed\" finally; these configuration\n        only determine the printout but not the propagation of the probabilities. If this list is empty, all \n        the levels are shown.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.FinalLevelDistribution-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.FinalLevelDistribution","text":"Cascade.FinalLevelDistribution()  ... (simple) constructor for cascade FinalLevelDistribution.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.FrequencyOpacityDependence","page":"API Cascade computations","title":"JAC.Cascade.FrequencyOpacityDependence","text":"struct  Cascade.FrequencyOpacityDependence   <:  Cascade.AbstractOpacityDependence       ... to deal with omega-dependence opacities [omega] and a binning that need to be given in Hartree.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.HollowIonScheme","page":"API Cascade computations","title":"JAC.Cascade.HollowIonScheme","text":"struct  Cascade.HollowIonScheme  <:  Cascade.AbstractCascadeScheme       ... a struct to define and describe the formation and decay of a hollow ion, e.g. an electronic core configuration          into which one or several additional electrons are captured into (high) nl shells. Both the shell (lists) for          the initial capture (intoShells) and the subsequent decay (decayShells) need to be specified explicitly to          readily control the size of the computations.\n\n+ processes             ::Array{Basics.AbstractProcess,1} \n    ... List of the atomic processes that are supported and should be included into the decay scheme.  \n+ multipoles            ::Array{EmMultipole,1}           \n    ... Multipoles of the radiation field that are to be included into the radiative stabilization processes.\n+ NoCapturedElectrons   ::Int64   \n    ... Number of captured electrons, e.g. placed in the intoShells.\n+ intoShells            ::Array{Shell,1}\n    ... List of shells into which electrons are initially placed (captured).\n+ decayShells           ::Array{Shell,1}\n    ... List of shells into which electrons the electrons can decay (apart from the core shells).\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.HollowIonScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.HollowIonScheme","text":"Cascade.HollowIonScheme()  ... constructor for an 'default' instance of a Cascade.HollowIonScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.ImpactExcitationScheme","page":"API Cascade computations","title":"JAC.Cascade.ImpactExcitationScheme","text":"struct  Cascade.ImpactExcitationScheme  <:  Cascade.AbstractCascadeScheme           ... to compute the (direct) electron-impact excitation spectrum for a list of impact energies (not yet).\n\n+ processes              ::Array{Basics.AbstractProcess,1} \n    ... List of the atomic processes that are supported and should be included into the cascade.\n+ fromShells             ::Array{Shell,1}    \n    ... List of shells from which impact-excitations are to be considered.\n+ toShells               ::Array{Shell,1}    \n    ... List of shells into which impact-excitations are to be considered, including possibly already occupied shells.\n+ electronEnergies       ::Array{Float64,1}                \n    ... List of electron energies for which this electron-impact excitation scheme is to be calculated.\n+ lValues                ::Array{Int64,1}\n    ... Orbital angular momentum values of the free-electrons, for which partial waves are considered for the RR.\n+ NoFreeElectronEnergies ::Int64             \n    ... Number of free-electron energies that a chosen for a Gauss-Laguerre integration.\n+ maxFreeElectronEnergy  ::Float64             \n    ... Maximum free-electron energies [in a.u.] that restrict the energy of free-electron orbitals; this maximum energy has to \n        be derived from the maximum temperature for which RR plasma coefficients need to be obtained and is typically set to \n        about 5x T_e,max.\n+ electronEnergyShift    ::Float64                 \n    ... Energy shift for all bound-state energies relative to the levels from the reference configuration; this is realized by \n        shifting the initial level energies by the negative amount. The shift is taken in the user-defined units.\n        \nEither a list of electronEnergies or the NoFreeElectronEnergies can be specified; the program terminates, if \"non-zero\"\nentries appears for these two subfields.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.ImpactExcitationScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.ImpactExcitationScheme","text":"Cascade.ImpactExcitationScheme()  ... constructor for an 'default' instance of a Cascade.ImpactExcitationScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.ImpactIonizationScheme","page":"API Cascade computations","title":"JAC.Cascade.ImpactIonizationScheme","text":"struct  Cascade.ImpactIonizationScheme  <:  Cascade.AbstractCascadeScheme           ... to compute the (direct) electron-impact excitation spectrum for a list of impact energies (not yet).\n\n+ processes             ::Array{Basics.AbstractProcess,1} \n    ... List of the atomic processes that are supported and should be included into the cascade.\n+ electronEnergies      ::Array{Float64,1}                \n    ... List of electron energies for which this electron-impact excitation scheme is to be calculated.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.ImpactIonizationScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.ImpactIonizationScheme","text":"Cascade.ImpactIonizationScheme()  ... constructor for an 'default' instance of a Cascade.ImpactIonizationScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.IonDistribution","page":"API Cascade computations","title":"JAC.Cascade.IonDistribution","text":"struct  Cascade.IonDistribution   <:  Cascade.AbstractSimulationProperty       ... defines a type for simulating the 'ion distribution' as it is found after all cascade processes are completed.\n\n+ initialOccupations  ::Array{Tuple{Int64,Float64},1}   \n    ... List of one or several (tupels of) levels in the overall cascade tree together with their relative population.\n+ leadingConfigs      ::Array{Configuration,1}   \n    ... List of leading configurations whose levels are equally populated, either initially or ....\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.IonDistribution-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.IonDistribution","text":"Cascade.IonDistribution()  ... (simple) constructor for cascade IonDistribution data.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.Level","page":"API Cascade computations","title":"JAC.Cascade.Level","text":"mutable struct  Cascade.Level  ... defines a level specification for dealing with cascade transitions.\n\n+ energy       ::Float64                     ... energy of the level.\n+ J            ::AngularJ64                  ... total angular momentum of the level\n+ parity       ::Basics.Parity               ... total parity of the level\n+ NoElectrons  ::Int64                       ... total number of electrons of the ion to which this level belongs.\n+ majorConfig  ::Configuration               ... major (dominant) configuration of this level.\n+ relativeOcc  ::Float64                     ... relative occupation  \n+ parents      ::Array{Cascade.LineIndex,1}  ... list of parent lines that (may) populate the level.     \n+ daugthers    ::Array{Cascade.LineIndex,1}  ... list of daugther lines that (may) de-populate the level.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.LineIndex","page":"API Cascade computations","title":"JAC.Cascade.LineIndex","text":"struct  Cascade.LineIndex{T}  ... defines a line index with regard to the various lineLists of data::Cascade.LineIndex.\n\n+ lines        ::Array{T,1}              ... refers to the line list for which this index is defined.\n+ process      ::Basics.AbstractProcess  ... refers to the particular lineList of cascade (data).\n+ index        ::Int64                   ... index of the corresponding line.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.MeanRelaxationTime","page":"API Cascade computations","title":"JAC.Cascade.MeanRelaxationTime","text":"struct  Cascade.MeanRelaxationTime   <:  Cascade.AbstractSimulationProperty       ... defines a type for simulating the mean relaxation times in which 70%, 80%, of the occupied levels decay to the          ground configuration.\n\n+ timeStep            ::Float64     ... Time-step for following the decay of levels [a.u.]\n+ initialOccupations  ::Array{Tuple{Int64,Float64},1}   \n    ... List of one or several (tupels of) levels in the overall cascade tree together with their relative population.\n+ leadingConfigs      ::Array{Configuration,1}   \n    ... List of leading configurations whose levels are equally populated, either initially or ....\n+ groundConfigs       ::Array{Configuration,1}   \n    ... List of ground configurations into which the decay is considered.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.MeanRelaxationTime-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.MeanRelaxationTime","text":"Cascade.MeanRelaxationTime()  ... (simple) constructor for cascade MeanRelaxationTime.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.PhotoAbsorptionScheme","page":"API Cascade computations","title":"JAC.Cascade.PhotoAbsorptionScheme","text":"struct  Cascade.PhotoAbsorptionScheme  <:  Cascade.AbstractCascadeScheme       ... a struct to define and describe a photo-absorption calculation for an atom in some initial state/configuration         and for a given range of photon energies, processes and multipoles, etc.\n\n+ multipoles            ::Array{EmMultipole}           \n    ... Multipoles of the radiation field that are to be included into the excitation/ionization processes.\n+ photonEnergies        ::Array{Float64,1}\n    ... List of photon energies (in user-selected units) for which absorption cross sections/spectra are to be\n        calculated; this describes the list, distribution and resolution of energies. It is checked that either\n        photonEnergies or electronEnergies are given only\n+ electronEnergies       ::Array{Float64,1}\n    ... List of electron energies (in user-selected units) for which absorption cross sections/spectra are to be\n        calculated; this describes the list, distribution and resolution of energies.\n+ excitationFromShells  ::Array{Shell,1}    \n    ... List of shells from which photo-excitations are to be considered.\n+ excitationToShells    ::Array{Shell,1}    \n    ... List of shells into which photo-excitations are to be considered, including possibly already occupied shells.\n+ initialLevelSelection ::LevelSelection    \n    ... Specifies the selected initial levels of some given initial-state configurations; these initial level numbers/\n        symmetries always refer to the set of initial configurations.\n+ lValues               ::Array{Int64,1}\n    ... Orbital angular momentum values of the free-electrons, for which partial waves are considered for the PI.\n+ calcDirect            ::Bool      ... True, if the direct contributions need to be calculated.                \n+ calcResonant          ::Bool      ... True, if the resonant contributions need to be calculated.                \n+ electronEnergyShift   ::Float64                 \n    ... Energy shift for all bound-state energies relative to the levels from the reference configuration; this is realized by \n        shifting the initial level energies by the negative amount. The shift is taken in the user-defined units.\n+ minCrossSection       ::Float64                 \n    ... minimum cross section (in user-selected units) for which contributions are accounted for in the list of\n        photoionization lines.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.PhotoAbsorptionScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.PhotoAbsorptionScheme","text":"Cascade.PhotoAbsorptionScheme()  ... constructor for an 'default' instance of a Cascade.PhotoAbsorptionScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.PhotoAbsorptionSpectrum","page":"API Cascade computations","title":"JAC.Cascade.PhotoAbsorptionSpectrum","text":"struct  Cascade.PhotoAbsorptionSpectrum   <:  Cascade.AbstractSimulationProperty       ... defines a type for simulating the total photo-absorption cross sections in a given interval of photon energies         as well as for a given set of photo-ionization and photo-excitation cross sections\n\n+ includeIonization   ::Bool             ... True, if photo-ionization cross sections are to be considered.\n+ includeExcitation   ::Bool             ... True, if photo-excitation lines are to be considered.\n+ resonanceWidth      ::Float64          ... Widths of the resonances (user-defined units)\n+ csScaling           ::Float64          ... Scaling factor do enhance the strengths of resonances (default=1.0)\n+ photonEnergies      ::Array{Float64,1} ... Photon energies (in user-selected units) for the simulation of photon spectra\n                                                to describe the interval and resolution of the absorption cross sections.\n+ shells              ::Array{Shell,1}   \n    ... Shells that should be included for a partial absorption cross sections; a cross section contribution is considered,\n        if the occupation of one of these shells is lowered in the leading configurations.\n+ initialOccupations  ::Array{Tuple{Int64,Float64},1}   \n    ... List of one or several (tupels of) levels in the overall cascade tree together with their relative population;\n        at least one of these tuples must be given.\n+ leadingConfigs      ::Array{Configuration,1}   \n    ... List of leading configurations whose levels are equally populated, either initially or ....\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.PhotoAbsorptionSpectrum-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.PhotoAbsorptionSpectrum","text":"Cascade.PhotoAbsorptionSpectrum()  ... (simple) constructor for cascade PhotoAbsorptionSpectrum.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.PhotoExcitationScheme","page":"API Cascade computations","title":"JAC.Cascade.PhotoExcitationScheme","text":"struct  Cascade.PhotoExcitationScheme  <:  Cascade.AbstractCascadeScheme       ... a struct to define and describe a photo-excitation calculation for an atom in some initial state/configuration         and for a given set of shell-excitations\n\n+ multipoles            ::Array{EmMultipole}           \n    ... Multipoles of the radiation field that are to be included into the excitation processes.\n+ minPhotonEnergy       ::Float64                 \n    ... Minimum photon energy [in a.u.] that restrict the number of excited configurations to be taken into accout.\n+ maxPhotonEnergy       ::Float64                 \n    ... Maximum photon energy [in a.u.] that restrict the number of excited configurations to be taken into accout.\n+ NoExcitations         ::Int64                 \n    ... (Maximum) Number of electron replacements with regard to the initial configurations/multiplets.\n+ excitationFromShells  ::Array{Shell,1}    \n    ... List of shells from which photo-excitations are to be considered.\n+ excitationToShells    ::Array{Shell,1}    \n    ... List of shells into which photo-excitations are to be considered, including possibly already occupied shells.\n+ initialLevelSelection ::LevelSelection    \n    ... Specifies the selected initial levels of some given initial-state configurations; these initial level numbers/\n        symmetries always refer to the set of initial configurations.\n+ lValues               ::Array{Int64,1}\n    ... Orbital angular momentum values of the free-electrons, for which partial waves are considered for the PI.\n+ electronEnergyShift   ::Float64                 \n    ... Energy shift for all bound-state energies relative to the levels from the reference configuration; this is realized by \n        shifting the initial level energies by the negative amount. The shift is taken in the user-defined units.\n+ minCrossSection       ::Float64                 \n    ... minimum cross section (in user-selected units) for which contributions are accounted for in the list of\n        photoionization lines. This may seriously restrict the amount of data that is prepared for the subsequent simulation \n        of photoabsorption spectra.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.PhotoExcitationScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.PhotoExcitationScheme","text":"Cascade.PhotoExcitationScheme()  ... constructor for an 'default' instance of a Cascade.PhotoExcitationScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.PhotoIonizationScheme","page":"API Cascade computations","title":"JAC.Cascade.PhotoIonizationScheme","text":"struct  Cascade.PhotoIonizationScheme  <:  Cascade.AbstractCascadeScheme       ... a struct to define and describe a photo-absorption calculation for an atom in some initial state/configuration         and for a given range of photon energies and multipoles, etc.\n\n+ multipoles            ::Array{EmMultipole}           \n    ... Multipoles of the radiation field that are to be included into the excitation/ionization processes.\n+ photonEnergies        ::Array{Float64,1}\n    ... List of photon energies (in user-selected units) for which absorption cross sections/spectra are to be\n        calculated; this describes the list, distribution and resolution of energies. It is checked that either\n        photonEnergies or electronEnergies are given only.\n+ electronEnergies       ::Array{Float64,1}\n    ... List of electron energies (in user-selected units) for which absorption cross sections/spectra are to be\n        calculated; this describes the list, distribution and resolution of energies.\n+ excitationFromShells  ::Array{Shell,1}    \n    ... List of shells from which photo-excitations are to be considered.\n+ excitationToShells    ::Array{Shell,1}    \n    ... List of shells into which photo-excitations are to be considered, including possibly already occupied shells.\n+ initialLevelSelection ::LevelSelection    \n    ... Specifies the selected initial levels of some given initial-state configurations; these initial level numbers/\n        symmetries always refer to the set of initial configurations.\n+ lValues               ::Array{Int64,1}\n    ... Orbital angular momentum values of the free-electrons, for which partial waves are considered for the PI.\n+ electronEnergyShift   ::Float64                 \n    ... Energy shift for all bound-state energies relative to the levels from the reference configuration; this is realized by \n        shifting the initial level energies by the negative amount. The shift is taken in the user-defined units.\n+ minCrossSection       ::Float64                 \n    ... minimum cross section (in user-selected units) for which contributions are accounted for in the list of\n        photoionization lines.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.PhotoIonizationScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.PhotoIonizationScheme","text":"Cascade.PhotoIonizationScheme()  ... constructor for an 'default' instance of a Cascade.PhotoIonizationScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.PhotonIntensities","page":"API Cascade computations","title":"JAC.Cascade.PhotonIntensities","text":"struct  Cascade.PhotonIntensities   <:  Cascade.AbstractSimulationProperty       ... defines a type for simulating the photon-line intensities as function of photon energy.\n\n+ minPhotonEnergy     ::Float64     ... Minimum photon energy for the simulation of photon spectra.\n+ maxPhotonEnergy     ::Float64     ... Maximum photon energy for the simulation of photon spectra.\n+ initialOccupations  ::Array{Tuple{Int64,Float64},1}   \n    ... List of one or several (tupels of) levels in the overall cascade tree together with their relative population.\n+ leadingConfigs      ::Array{Configuration,1}   \n    ... List of leading configurations whose levels are equally populated, either initially or ....\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.PhotonIntensities-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.PhotonIntensities","text":"Cascade.PhotonIntensities()  ... (simple) constructor for cascade PhotonIntensities.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.PiRateCoefficients","page":"API Cascade computations","title":"JAC.Cascade.PiRateCoefficients","text":"struct  Cascade.PiRateCoefficients   <:  Cascade.AbstractSimulationProperty       ... defines a type for simulating the PI plasma rate coefficients as function of the (free) photon energy distribution and         the plasma temperature. These coefficients included a convolution of the direct photoionization cross sections over the          Maxwell distribution of electron and (if requested) add the pre-evaluated resonant parts afterwards.\n\n    For the implementation: (1) Perform GL integration over free-electron contributions analog to the photoabsorption;\n    (2) for the resonant part, simply add convoluted summation terms for all final states (to be worked out in detail);\n    (3) use a electronEnergies grid ... instead of the photonEnergies grid.\n    (4) in the direct part, sum over the final states before convolution\n\n+ includeResonantPart ::Bool        ... True, if the resonant contributions are to be included.\n+ initialLevelNo      ::Int64       ... Level No of initial level for which rate coefficients are to be computed.\n+ temperatures        ::Array{Float64,1}\n    ... temperatures [K] for which the DR plasma rate coefficieints to be calculated.\n+ multipoles          ::Array{EmMultipole}           \n    ... Multipoles of the radiation field that are to be included into the photoionization processes.\n+ finalConfigurations ::Array{Configuration,1}\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.PiRateCoefficients-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.PiRateCoefficients","text":"Cascade.PiRateCoefficients()  ... (simple) constructor for cascade PiRateCoefficients.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.RadiativeRecombinationScheme","page":"API Cascade computations","title":"JAC.Cascade.RadiativeRecombinationScheme","text":"struct  Cascade.RadiativeRecombinationScheme  <:  Cascade.AbstractCascadeScheme       ... a struct to define and describe the radiative recombination of electrons for an atom in some initial state/configuration;         for such a scheme, the configurations due to the electron capture are generated automatically due to given maximal numbers          of the (into-) shells (nl) as well as the maximum displacement with regard to the initial configuration.         An additional maximum excitation energy need to be provided due to the maximum temperatures for which RR plasma rate coefficients         are to be determined, cf. Basics.convert().\n\n+ multipoles             ::Array{EmMultipole}           \n    ... Multipoles of the radiation field that are to be included into the radiative stabilization processes.\n+ lValues                ::Array{Int64,1}\n    ... Orbital angular momentum values of the free-electrons, for which partial waves are considered for the RR.\n+ NoFreeElectronEnergies ::Int64             \n    ... Number of free-electron energies that a chosen for a Gauss-Laguerre integration.\n+ maxFreeElectronEnergy  ::Float64             \n    ... Maximum free-electron energies [in a.u.] that restrict the energy of free-electron orbitals; this maximum energy has to \n        be derived from the maximum temperature for which RR plasma coefficients need to be obtained and is typically set to \n        about 5x T_e,max.\n+ electronEnergyShift    ::Float64                 \n    ... Energy shift for all bound-state energies relative to the levels from the reference configuration; this is realized by \n        shifting the initial level energies by the negative amount. The shift is taken in the user-defined units.\n+ minPhotonEnergy       ::Float64                 \n    ... Minimum (mean) photon energy [in a.u.] for which the radiative decay is taken into account.\n+ intoShells            ::Array{Shell,1}\n    ... List of shells into which electrons are initially placed (captured).\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.RadiativeRecombinationScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.RadiativeRecombinationScheme","text":"Cascade.RadiativeRecombinationScheme()  ... constructor for an 'default' instance of a Cascade.RadiativeRecombinationScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.RosselandOpacities","page":"API Cascade computations","title":"JAC.Cascade.RosselandOpacities","text":"struct  Cascade.RosselandOpacities   <:  Cascade.AbstractSimulationProperty       ... defines a type for simulating the Rosseland opacity as function of the temperature or density as well as (parametrically)          the expansion time. Usually, different values are given for either the temperature or density.\n\n+ levelPopulation        ::Basics.AbstractLevelPopulation  \n    ... to specify the kind of level population that is considered for the given opacity calculations.\n+ opacityDependence      ::Cascade.TemperatureOpacityDependence    \n    ... to specify the dependence of the opacities in terms of (the temperature-normalized) u]\n+ ionDensities           ::Array{Float64,1}      ... list of ion densities [in g/cm^3]\n+ temperatures           ::Array{Float64,1}      ... list of temperatures [in K]\n+ expansionTime          ::Float64               ... (expansion/observation) time [in sec]\n+ transitionEnergyShift  ::Float64     \n    ... (total) energy shifts that apply to all transition energies; the amplitudes are re-scaled accordingly.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.RrRateCoefficients","page":"API Cascade computations","title":"JAC.Cascade.RrRateCoefficients","text":"struct  Cascade.RrRateCoefficients   <:  Cascade.AbstractSimulationProperty       ... defines a type for simulating the RR plasma rate coefficients as function of the (free) electron energy and         plasma temperature.\n\n+ initialLevelNo      ::Int64       ... Level No of initial level for which rate coefficients are to be computed.\n+ temperatures        ::Array{Float64,1}\n    ... temperatures [K] for which the DR plasma rate coefficieints to be calculated.\n+ multipoles          ::Array{EmMultipole}           \n    ... Multipoles of the radiation field that are to be included into the excitation processes.\n+ finalLevelSelection ::LevelSelection    \n    ... Specifies the selected final levels of some given final-state configurations; these final level numbers/\n        symmetries always refer to single configurations.\n+ finalConfigurations ::Array{Configuration,1}\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.RrRateCoefficients-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.RrRateCoefficients","text":"Cascade.RrRateCoefficients()  ... (simple) constructor for cascade RrRateCoefficients.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.Simulation","page":"API Cascade computations","title":"JAC.Cascade.Simulation","text":"struct  Cascade.Simulation  ... defines a simulation on some given cascade (data).\n\n+ name            ::String                              ... Name of the simulation\n+ property        ::Cascade.AbstractSimulationProperty \n    ... Property that is to be considered in this simulation of the cascade (data).\n+ method          ::Cascade.AbstractSimulationMethod    \n    ... Method that is used in the cascade simulation; cf. Cascade.SimulationMethod.\n+ settings        ::Cascade.SimulationSettings          ... Settings for performing these simulations.\n+ computationData ::Array{Dict{String,Any},1}           ... Date on which the simulations are performed\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.Simulation-Tuple{JAC.Cascade.Simulation}","page":"API Cascade computations","title":"JAC.Cascade.Simulation","text":"Cascade.Simulation(sim::Cascade.Simulation;\n\n        name=..,               property=..,             method=..,              settings=..,     computationData=.. )\n        \n... constructor for re-defining the computation::Cascade.Simulation.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.Simulation-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.Simulation","text":"Cascade.Simulation()  ... constructor for an 'default' instance of a Cascade.Simulation.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.SimulationSettings","page":"API Cascade computations","title":"JAC.Cascade.SimulationSettings","text":"struct  Cascade.SimulationSettings  ... defines settings for performing the simulation of some cascade (data).\n\n+ printTree           ::Bool        ... Print the cascade tree in a short form\n+ printLongTree       ::Bool        ... Print the cascade tree in a long form\n+ initialPhotonEnergy ::Float64     ... Photon energy for which photoionization data are considered.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.SimulationSettings-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.SimulationSettings","text":"Cascade.SimulationSettings()  ... constructor for an 'empty' instance of a Cascade.Block.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.Step","page":"API Cascade computations","title":"JAC.Cascade.Step","text":"struct  Cascade.Step       ... defines a type for an individual step of an excitation and/or decay cascade. Such a step is determined by the two lists          of initial- and final-state configuration as well as by the atomic process, such as Auger, PhotoEmission, or others, which related         the initial- and final-state levels to each other. Since the (lists of) initial- and final-state configurations treated (each)         by a single multiplet (for parities and total angular momenta), a cascade step supports full configuration interaction within         the multiplet but also help  avoid 'double counting' of individual levels. Indeed, each electron configuration may occur only in         one cascade block. In contrast, each list of initial- and final-state multiplets (cascade blocks) can occur in quite different          steps due to the considered processes and parallel decay pathes in a cascade.\n\n+ process          ::JBasics.AbstractProcess   ... Atomic process that 'acts' in this step of the cascade.\n+ settings         ::Union{PhotoEmission.Settings, AutoIonization.Settings, PhotoIonization.Settings, PhotoExcitation.Settings,\n                            DielectronicCapture.Settings}        \n                                                ... Settings for this step of the cascade.\n+ initialConfigs   ::Array{Configuration,1}    ... List of one or several configurations that define the initial-state multiplet.\n+ finalConfigs     ::Array{Configuration,1}    ... List of one or several configurations that define the final-state multiplet.\n+ initialMultiplet ::Multiplet                 ... Multiplet of the initial-state levels of this step of the cascade.\n+ finalMultiplet   ::Multiplet                 ... Multiplet of the final-state levels of this step of the cascade.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.Step-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.Step","text":"Cascade.Step()  ... constructor for an 'empty' instance of a Cascade.Step.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.StepwiseDecayScheme","page":"API Cascade computations","title":"JAC.Cascade.StepwiseDecayScheme","text":"struct  Cascade.StepwiseDecayScheme  <:  Cascade.AbstractCascadeScheme       ... a struct to represent (and generate) a mean-field orbital basis.\n\n+ processes             ::Array{Basics.AbstractProcess,1} \n    ... List of the atomic processes that are supported and should be included into the cascade.\n+ maxElectronLoss       ::Int64             \n    ... (Maximum) Number of electrons in which the initial- and final-state configurations can differ from each other; \n        this also determines the maximal steps of any particular decay path.\n+ chargeStateShifts     ::Dict{Int64,Float64} \n    ... (N => en) total energy shifts of all levels with N electrons; these shifts [in a.u.] help open/close decay \n        channels by simply shifting the total energies of all levels.\n+ NoShakeDisplacements  ::Int64             \n    ... Maximum number of electron displacements due to shake-up  or shake-down processes in any individual step of cascade.\n+ decayShells           ::Array{Shell,1}        ... List of shells that may occur during the decay.\n+ shakeFromShells       ::Array{Shell,1}        ... List of shells from which shake transitions may occur.\n+ shakeToShells         ::Array{Shell,1}        ... List of shells into which shake transitions may occur.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.StepwiseDecayScheme-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.StepwiseDecayScheme","text":"Cascade.StepwiseDecayScheme()  ... constructor for an 'default' instance of a Cascade.StepwiseDecayScheme.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.TemperatureOpacityDependence","page":"API Cascade computations","title":"JAC.Cascade.TemperatureOpacityDependence","text":"struct  Cascade.TemperatureOpacityDependence   <:  Cascade.AbstractOpacityDependence       ... to deal with temperature-normalized dependent opacities [u] and a binning that need to be given Hartree.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#JAC.Cascade.WavelengthOpacityDependence","page":"API Cascade computations","title":"JAC.Cascade.WavelengthOpacityDependence","text":"struct  Cascade.WavelengthOpacityDependence   <:  Cascade.AbstractOpacityDependence       ... to deal with wavelength-dependence opacities [lambda] and a binning that need always to be given in nm.\n\n\n\n\n\n","category":"type"},{"location":"api-cascades.html#Base.:==-Tuple{JAC.Cascade.Level, JAC.Cascade.Level}","page":"API Cascade computations","title":"Base.:==","text":"Base.:(==)(leva::Cascade.Level, levb::Cascade.Level)  ... returns true if both levels are equal and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Basics.extractLeadingConfiguration-Tuple{JAC.Cascade.Level}","page":"API Cascade computations","title":"JAC.Basics.extractLeadingConfiguration","text":"Basics.extractLeadingConfiguration(cLevel::Cascade.Level)       ... extract the leading configuration of the given level; a conf::Configuration is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Basics.isSimilar-Tuple{JAC.Basics.LevelKey, JAC.Basics.LevelKey, Float64}","page":"API Cascade computations","title":"JAC.Basics.isSimilar","text":"Basics.isSimilar()  ... returns true if two instances are similar to each other, and false otherwise.\n\n(keya::LevelKey, keyb::LevelKey, relAcc::Float64)     ... returns true if two level keys refer to the same level, i.e. level with the same symmetry and       if the relative energy abs( (Ea - Eb)/E_a ) < relAcc. It returns false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Basics.perform-Tuple{JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Basics.perform","text":"Basics.perform(comp::Cascade.Computation)       ... to set-up and perform a cascade computation that starts from a given set of initial configurations and proceeds via          various steps until a given number of electrons has been removed or the decay stops at some stable levels with regard          to the given atomic processes. The results of all individual steps are printed to screen but nothing is returned          otherwise.\n\nBasics.perform(comp::Cascade.Computation; output::Bool=true, outputToFile::Bool=true)        ... to perform the same but to return the complete output in a dictionary;  the particular output depends on the type          and specifications of the cascade but can easily accessed by the keys of this dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Basics.perform-Tuple{JAC.Cascade.Simulation}","page":"API Cascade computations","title":"JAC.Basics.perform","text":"Basics.perform(comp::Cascade.Simulation)       ... to set-up and perform a cascade computation that starts from a given set of initial configurations and proceeds via          various steps until a given number of electrons has been removed or the decay stops at some stable levels with regard          to the given atomic processes. The results of all individual steps are printed to screen but nothing is returned          otherwise.\n\nBasics.perform(comp::Cascade.Simulation; output=true)        ... to perform the same but to return the complete output in a dictionary;  the particular output depends on the type          and specifications of the cascade but can easily accessed by the keys of this dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.RosselandOpacitiesOpacities-Tuple{}","page":"API Cascade computations","title":"JAC.Cascade.RosselandOpacitiesOpacities","text":"Cascade.RosselandOpacities()  ... (simple) constructor for RosselandOpacities opacity simulations.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.addLevels-Tuple{Vector{JAC.Cascade.Level}, Vector{JAC.Cascade.Level}}","page":"API Cascade computations","title":"JAC.Cascade.addLevels","text":"Cascade.addLevels(levelsA::Array{Cascade.Level,1}, levelsB::Array{Cascade.Level,1})      ... adds two sets of levels so that each levels occurs only 'once' in the list; in practice, however, this 'addition' requires also          that the parent and daughter processes are added properly so that all information is later available for the simulations.         It is assumed here that all daugther and parent (processes) appear only once if levels from different data sets         (Cascade.DecayData, Cascade.PhotoIonData) are added to each other. A message is issued about the number of levels before and          after this 'addition', and how many of the levels have been modified by this method. Note that all relative occucations are          set to zero in this addition; a newlevels::Array{Cascade.Level,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.assignOccupation!-Tuple{Vector{JAC.Cascade.Level}, JAC.Cascade.AbstractSimulationProperty}","page":"API Cascade computations","title":"JAC.Cascade.assignOccupation!","text":"Cascade.assignOccupation!(levels::Array{Cascade.Level,1}, property::AbstractSimulationProperty)      ... assigns the occupation due to the given property\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.combineEnergiesIntensities-Tuple{Float64, Vector{Tuple{Float64, Float64}}, Float64, Vector{Tuple{Float64, Float64}}}","page":"API Cascade computations","title":"JAC.Cascade.combineEnergiesIntensities","text":"Cascade.combineEnergiesIntensities(w1::Float64, w1enInts::Array{Tuple{Float64,Float64},1},                                      w2::Float64, w2enInts::Array{Tuple{Float64,Float64},1})      ... combines w1 * w1enInts + w2 * w2enInts; a newEnergiesInts::Array{Tuple{Float64,Float64},1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeContinuumOrbitals-Tuple{JAC.Cascade.RadiativeRecombinationScheme, JAC.Cascade.Computation, Level}","page":"API Cascade computations","title":"JAC.Cascade.computeContinuumOrbitals","text":"Cascade.computeContinuumOrbitals(scheme::Cascade.RadiativeRecombinationScheme, comp::Cascade.Computation, level::ManyElectron.Level)      ... computes in turn all the necessary continuum orbitals for the given energy grid and maxKappa value; a set of orbitals         cOrbitals::Dict{Subshell, Orbital} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeDecayProbabilities-Tuple{JAC.DecayYield.Outcome, Vector{JAC.PhotoEmission.Line}, Vector{JAC.AutoIonization.Line}, JAC.DecayYield.Settings}","page":"API Cascade computations","title":"JAC.Cascade.computeDecayProbabilities","text":"Cascade.computeDecayProbabilities(outcome::DecayYield.Outcome, linesR::Array{PhotoEmission.Line,1},                                      linesA::Array{AutoIonization.Line,1}, settings::DecayYield.Settings)      ... to compute the decay probabilities for all pairs and triples of subshells; these probabilities only depend         on the holes in different subshells and are sumed over all final levels that share the same subshell occupation.         The results are printed in neat tables to screen but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeDecayYieldOutcome-Tuple{JAC.DecayYield.Outcome, Vector{JAC.PhotoEmission.Line}, Vector{JAC.AutoIonization.Line}, JAC.DecayYield.Settings}","page":"API Cascade computations","title":"JAC.Cascade.computeDecayYieldOutcome","text":"Cascade.computeDecayYieldOutcome(outcome::DecayYield.Outcome, linesR::Array{PhotoEmission.Line,1},                                      linesA::Array{AutoIonization.Line,1}, settings::DecayYield.Settings)      ... to compute the flourescence and Auger yields for a single decay yield outcome as specified by the corresponding         level; an outcome::DecayYield.Outcome is returned in which all physical parameters are now specified for the given         decay-yield.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeSteps-Tuple{JAC.Cascade.DielectronicRecombinationScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Step}}","page":"API Cascade computations","title":"JAC.Cascade.computeSteps","text":"Cascade.computeSteps(scheme::Cascade.DielectronicRecombinationScheme, comp::Cascade.Computation, stepList::Array{Cascade.Step,1})      ... computes in turn all the requested capture & transition amplitudes as well as DielectronicCapture.Line's, AutoIonization.Line's,          etc. for all pre-specified decay steps of the cascade. When compared with standard computations of these atomic          processes, however, the amount of output is largely reduced and often just printed into the summary file.          A set of  data::Cascade.CaptureData  is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeSteps-Tuple{JAC.Cascade.ExpansionOpacityScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Step}}","page":"API Cascade computations","title":"JAC.Cascade.computeSteps","text":"Cascade.computeSteps(scheme::Cascade.ExpansionOpacityScheme, comp::Cascade.Computation, stepList::Array{Cascade.Step,1})      ... computes in turn all the requested photon excitation/absorption amplitudes as well as PhotoExcitation.Line's for all          pre-specified decay steps of the cascade. When compared with standard computations of photoexcitation, however, the amount          of output is largely reduced and often just printed into the summary file.          A set of  data::Cascade.ExcitationData  is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeSteps-Tuple{JAC.Cascade.HollowIonScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Step}}","page":"API Cascade computations","title":"JAC.Cascade.computeSteps","text":"Cascade.computeSteps(scheme::Cascade.HollowIonScheme, comp::Cascade.Computation, stepList::Array{Cascade.Step,1})      ... computes in turn all the requested (decay) transition amplitudes as well as AutoIonization.Line's, etc. for all          pre-specified decay steps of the cascade. When compared with standard computations of these atomic          processes, however, the amount of output is largely reduced and often just printed into the summary file.          A set of  data::Cascade.DecayData  is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeSteps-Tuple{JAC.Cascade.ImpactExcitationScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Step}}","page":"API Cascade computations","title":"JAC.Cascade.computeSteps","text":"Cascade.computeSteps(scheme::Cascade.ImpactExcitationScheme, comp::Cascade.Computation, stepList::Array{Cascade.Step,1})      ... computes in turn all the requested transition amplitudes as well as ImpactExcitation.Line's, etc. for all pre-specified          excitation steps of the cascade. When compared with standard excitation computations, however, the amount of output is          largely reduced and often just printed into the summary file. A set of  data::Cascade.Data  is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeSteps-Tuple{JAC.Cascade.PhotoExcitationScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Step}}","page":"API Cascade computations","title":"JAC.Cascade.computeSteps","text":"Cascade.computeSteps(scheme::Cascade.PhotoExcitationScheme, comp::Cascade.Computation, stepList::Array{Cascade.Step,1})      ... computes in turn all the requested transition amplitudes as well as PhotoExcitation.Line's, etc. for all pre-specified          excitation steps of the cascade. When compared with standard excitation computations, however, the amount of output is          largely reduced and often just printed into the summary file. A set of  data::Cascade.ExcitationData  is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeSteps-Tuple{JAC.Cascade.PhotoIonizationScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Step}}","page":"API Cascade computations","title":"JAC.Cascade.computeSteps","text":"Cascade.computeSteps(scheme::Cascade.PhotoIonizationScheme, comp::Cascade.Computation, stepList::Array{Cascade.Step,1})      ... computes in turn all the requested transition amplitudes as well as PhotoExcitation.Line's, etc. for all pre-specified          excitation steps of the cascade. When compared with standard excitation computations, however, the amount of output is          largely reduced and often just printed into the summary file. A set of  data::Cascade.ExcitationData  is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeSteps-Tuple{JAC.Cascade.RadiativeRecombinationScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Step}}","page":"API Cascade computations","title":"JAC.Cascade.computeSteps","text":"Cascade.computeSteps(scheme::Cascade.RadiativeRecombinationScheme, comp::Cascade.Computation, stepList::Array{Cascade.Step,1})      ... computes in turn all the requested capture amplitudes as well as PhotoRecombination.Line's, etc. for all pre-specified          radiative recombination steps of the cascade. When compared with standard computations of these atomic processes, however,          the amount of output is largely reduced and often just printed into the summary file.          A set of  data::Cascade.CaptureData  is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeSteps-Tuple{JAC.Cascade.StepwiseDecayScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Step}}","page":"API Cascade computations","title":"JAC.Cascade.computeSteps","text":"Cascade.computeSteps(scheme::Cascade.StepwiseDecayScheme, comp::Cascade.Computation, stepList::Array{Cascade.Step,1})      ... computes in turn all the requested transition amplitudes as well as PhotoEmission.Line's, AutoIonization.Line's,          etc. for all pre-specified decay steps of the cascade. When compared with standard computations of these atomic          processes, however, the amount of output is largely reduced and often just printed into the summary file.          A set of  data::Cascade.DecayData  is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeTotalAugerRate-Tuple{JAC.Cascade.Level}","page":"API Cascade computations","title":"JAC.Cascade.computeTotalAugerRate","text":"Cascade.computeTotalAugerRate(level::Cascade.Level)      ... computes the total Auger rate of level as given by its daugther levels; a rate::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.computeTotalPhotonRate-Tuple{JAC.Cascade.Level}","page":"API Cascade computations","title":"JAC.Cascade.computeTotalPhotonRate","text":"Cascade.computeTotalPhotonRate(level::Cascade.Level)      ... computes the total photon (radiative) rate of level as given by its daugther levels; a rate::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.determineSteps-Tuple{JAC.Cascade.DielectronicRecombinationScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Block}, Vector{JAC.Cascade.Block}, Vector{JAC.Cascade.Block}}","page":"API Cascade computations","title":"JAC.Cascade.determineSteps","text":"Cascade.determineSteps(scheme::Cascade.DielectronicRecombinationScheme, comp::Cascade.Computation,                          initialList::Array{Cascade.Block,1}, captureList::Array{Cascade.Block,1}, decayList::Array{Cascade.Block,1})       ... determines all step::Cascade.Step's that need to be computed for this dielectronic cascade. It considers the autoionization         between the blocks from the captureList and initialList as well as the radiative stabilization between the blocks from the          captureList and decayList. It checks that at least on pair of levels supports either an electron-capture' orradiative stabilization' within the step. A stepList::Array{Cascade.Step,1} is returned, and for which subsequently all          required transition amplitudes and rates/cross sections are computed.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.determineSteps-Tuple{JAC.Cascade.ExpansionOpacityScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Block}}","page":"API Cascade computations","title":"JAC.Cascade.determineSteps","text":"Cascade.determineSteps(scheme::Cascade.ExpansionOpacityScheme, comp::Cascade.Computation, blockList::Array{Cascade.Block,1})       ... determines all step::Cascade.Step's that need to be computed for this expansion opacity cascade.          It considers the pairwise photoexcitation between all blocks and checks that at least one transition is allowed for these blocks.         A stepList::Array{Cascade.Step,1} is returned, and for which subsequently all required transition amplitudes and oscillator strengths         are computed.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.determineSteps-Tuple{JAC.Cascade.HollowIonScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Block}}","page":"API Cascade computations","title":"JAC.Cascade.determineSteps","text":"Cascade.determineSteps(scheme::Cascade.HollowIonScheme, comp::Cascade.Computation, capturedList::Array{Cascade.Block,1})       ... determines all step::Cascade.Step's that need to be computed for this decay cascade. It cycles through all decay processes          of the given scheme and selects all pairs of blocks due to the selected cascade approach. It checks that at least          on pair of levels supports a decay within the step. A stepList::Array{Cascade.Step,1} is returned, and for which subsequently          all required transition amplitudes and rates/cross sections are computed.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.determineSteps-Tuple{JAC.Cascade.ImpactExcitationScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Block}, Vector{JAC.Cascade.Block}}","page":"API Cascade computations","title":"JAC.Cascade.determineSteps","text":"Cascade.determineSteps(scheme::Cascade.ImpactExcitationScheme, comp::Cascade.Computation,                          initialList::Array{Cascade.Block,1}, excitedList::Array{Cascade.Block,1})       ... determines all step::Cascade.Step's that need to be computed for this decay cascade. It cycles through all processes of the given         decay scheme and selects all pairs of blocks due to the selected cascade approach. It checks that at least on pair of levels         supports a `electron-impact excitation' within the step. A stepList::Array{Cascade.Step,1} is returned, and for which          subsequently all required transition amplitudes and rates/cross sections are computed.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.determineSteps-Tuple{JAC.Cascade.PhotoExcitationScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Block}, Vector{JAC.Cascade.Block}}","page":"API Cascade computations","title":"JAC.Cascade.determineSteps","text":"Cascade.determineSteps(scheme::Cascade.PhotoExcitationScheme, comp::Cascade.Computation,                          initialList::Array{Cascade.Block,1}, excitedList::Array{Cascade.Block,1})       ... determines all step::Cascade.Step's that need to be computed for this decay cascade. It cycles through all processes of the given         decay scheme and selects all pairs of blocks due to the selected cascade approach. It checks that at least on pair of levels         supports a `photo-excitation' within the step. A stepList::Array{Cascade.Step,1} is returned, and for which subsequently all          required transition amplitudes and rates/cross sections are computed.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.determineSteps-Tuple{JAC.Cascade.PhotoIonizationScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Block}, Vector{JAC.Cascade.Block}}","page":"API Cascade computations","title":"JAC.Cascade.determineSteps","text":"Cascade.determineSteps(scheme::Cascade.PhotoIonizationScheme, comp::Cascade.Computation,                          initialList::Array{Cascade.Block,1}, ionizedList::Array{Cascade.Block,1}, excitedList::Array{Cascade.Block,1})       ... determines all step::Cascade.Step's that need to be computed for this decay cascade. It cycles through all processes of the given         decay scheme and selects all pairs of blocks due to the selected processes and cascade approach. It checks that at least on          pair of levels supports either a photo-ionization' orphoto-excitation' within the step. A stepList::Array{Cascade.Step,1}          is returned, and for which subsequently all required transition amplitudes and rates/cross sections are computed.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.determineSteps-Tuple{JAC.Cascade.RadiativeRecombinationScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Block}, Vector{JAC.Cascade.Block}}","page":"API Cascade computations","title":"JAC.Cascade.determineSteps","text":"Cascade.determineSteps(scheme::Cascade.RadiativeRecombinationScheme, comp::Cascade.Computation,                          initialList::Array{Cascade.Block,1}, captureList::Array{Cascade.Block,1})       ... determines all step::Cascade.Step's that need to be computed for this radiative recombination cascade. It considers the          radiative recombination between the blocks from the initialList and captureList. It checks that at least on pair of         levels supports such a `radiative stabilization' within the step. A stepList::Array{Cascade.Step,1} is returned, and          for which subsequently all required capture amplitudes and rates/cross sections are computed.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.determineSteps-Tuple{JAC.Cascade.StepwiseDecayScheme, JAC.Cascade.Computation, Vector{JAC.Cascade.Block}}","page":"API Cascade computations","title":"JAC.Cascade.determineSteps","text":"Cascade.determineSteps(scheme::Cascade.StepwiseDecayScheme, comp::Cascade.Computation, blockList::Array{Cascade.Block,1})       ... determines all step::Cascade.Step's that need to be computed for this decay cascade. It cycles through all processes of the given         decay scheme and selects all pairs of blocks due to the selected cascade approach. It is checked that the (averaged) energies          each block or level supports a `decay' within the step. A stepList::Array{Cascade.Step,1} is returned, and for which subsequently         all required transition amplitudes and rates are computed.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displayBlocks-Tuple{IO, Vector{JAC.Cascade.Block}}","page":"API Cascade computations","title":"JAC.Cascade.displayBlocks","text":"Cascade.displayBlocks(stream::IO, blockList::Array{Cascade.Block,1}; sa::String=\"\")      ... group & display the blocks of the cascade with same No. of electrons; this blocks are displayed with the         minimum and maximum energy of each multiplet. The optional sa::String can be used to display some details         about the given blocks. nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displayDecayProbabilities-Tuple{IO, JAC.DecayYield.Outcome, Dict{Subshell, Float64}, Dict{Tuple{Subshell, Subshell}, Float64}, JAC.DecayYield.Settings}","page":"API Cascade computations","title":"JAC.Cascade.displayDecayProbabilities","text":"Cascade.displayDecayProbabilities(stream::IO, outcome::DecayYield.Outcome, rProbabilities::Dict{Subshell,Float64},                                     aProbabilities::Dict{Tuple{Subshell,Subshell},Float64}, settings::DecayYield.Settings)       ... displays the – radiative and Auger – decay probabilities in a neat table and a format close to the geant4 input         files. However, here the subshells are still displayed in the standard form. If suitable output files are selected,         these – radiative and Auger – decay probabilities are also dumped independently into two ASCII files by using a         format very similar to GEANT4. Overall this procedure is rather specific in that the level of each outcome          is given by a single relativistic configuration and with just a single core hole (subshell). The many-electron rates          are then brought back to a single-particle subshell notation.          A neat table is printed to the given stream but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displayExpansionOpacities-Tuple{IO, String, JAC.Cascade.ExpansionOpacities, Tuple{Float64, Float64}, Vector{JAC.Basics.EmProperty}}","page":"API Cascade computations","title":"JAC.Cascade.displayExpansionOpacities","text":"Cascade.displayExpansionOpacities(stream::IO, sc::String, property::Cascade.ExpansionOpacities,                                      energyInterval::Tuple{Float64, Float64}, kappas::Array{Basics.EmProperty,1})      ... displays the expansion opacities in a neat table. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displayFinalLevelDistribution-Tuple{IO, String, Vector{JAC.Cascade.Level}, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.displayFinalLevelDistribution","text":"Cascade.displayFinalLevelDistribution(stream::IO, sc::String, levels::Array{Cascade.Level,1}, finalConfigs::Array{Configuration,1})      ... displays the (current or final) level distribution in a neat table. Only those levels with a non-zero          occupation are displayed here. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displayIntensities-Tuple{IO, JAC.Cascade.PhotonIntensities, Vector{Tuple{Float64, Float64}}}","page":"API Cascade computations","title":"JAC.Cascade.displayIntensities","text":"Cascade.displayIntensities(stream::IO, property::PhotonIntensities, energiesIntensities::Array{Tuple{Float64,Float64},1})      ... displays the (tuples of) energiesIntensities in a neat table. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displayIonDistribution-Tuple{IO, String, Vector{JAC.Cascade.Level}}","page":"API Cascade computations","title":"JAC.Cascade.displayIonDistribution","text":"Cascade.displayIonDistribution(stream::IO, sc::String, levels::Array{Cascade.Level,1})      ... displays the (current or final) ion distribution in a neat table. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displayLevelTree-Tuple{IO, Vector{JAC.Cascade.Level}}","page":"API Cascade computations","title":"JAC.Cascade.displayLevelTree","text":"Cascade.displayLevelTree(stream::IO, levels::Array{Cascade.Level,1}; extended::Bool=false)      ... displays all defined levels  in a neat table, together with their No. of electrons, symmetry, level energy,          current (relative) population as well as analogue information about their parents and daugther levels. This          enables one to recognize (and perhaps later add) missing parent and daughter levels. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displayLevels-Tuple{IO, Vector{Multiplet}}","page":"API Cascade computations","title":"JAC.Cascade.displayLevels","text":"Cascade.displayLevels(stream::IO, multiplets::Array{Multiplet,1}; sa::String=\"\")       ... display on stream the initial configurations as well as the calculated levels for all initial multiplets.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displayPhotoAbsorptionSpectrum-Tuple{IO, Vector{Float64}, Vector{JAC.Basics.EmProperty}, JAC.Cascade.PhotoAbsorptionSpectrum}","page":"API Cascade computations","title":"JAC.Cascade.displayPhotoAbsorptionSpectrum","text":"Cascade.displayPhotoAbsorptionSpectrum(stream::IO, pEnergies::Array{Float64,1}, crossSections::Array{EmProperty,1},                                         property::Cascade.PhotoAbsorptionSpectrum)      ... displays the photoabsorption cross sections a neat table. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displayRelativeOccupation-Tuple{IO, Vector{JAC.Cascade.Level}, JAC.Cascade.SimulationSettings}","page":"API Cascade computations","title":"JAC.Cascade.displayRelativeOccupation","text":"Cascade.displayRelativeOccupation(stream::IO, levels::Array{Cascade.Level,1}, settings::Cascade.SimulationSettings)      ... displays the (initial) relative occupation of the levels in a neat table; an error message is issued if the population is         given for those levels in the settings, which do not exist in the present simulation. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displayRelativeOccupation-Tuple{IO, Vector{JAC.Cascade.Level}}","page":"API Cascade computations","title":"JAC.Cascade.displayRelativeOccupation","text":"Cascade.displayRelativeOccupation(stream::IO, levels::Array{Cascade.Level,1})      ... displays the (initial) relative occupation of the levels in a neat table. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.displaySteps-Tuple{IO, Vector{JAC.Cascade.Step}}","page":"API Cascade computations","title":"JAC.Cascade.displaySteps","text":"Cascade.displaySteps(stream::IO, steps::Array{Cascade.Step,1}; sa::String=\"\")      ... displays all predefined steps in a neat table and supports to delete individual steps from the list.         sa::String can be used to display details about the given steps\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.dumpDecayProbabilities-Tuple{IO, JAC.DecayYield.Outcome, Dict{Subshell, Float64}, Dict{Subshell, Float64}, JAC.DecayYield.Settings}","page":"API Cascade computations","title":"JAC.Cascade.dumpDecayProbabilities","text":"Cascade.dumpDecayProbabilities(stream::IO, outcome::DecayYield.Outcome, subshEnergies::Dict{Subshell,Float64},                                 rProbabilities::Dict{Subshell,Float64},settings::DecayYield.Settings)       ... dumps the radiative decay probabilities to a selected data file in geant4 form; this is caused by the          geant4 boolean of the DecayYield.Settings; this procedure is rather specific in that a single relativistic          configuration with a single core hole (subshell) is assumed and that the many-electron rates have been brought back          to a single-particle subshell notation. A neat table is printed to the given stream but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.dumpDecayProbabilities-Tuple{IO, JAC.DecayYield.Outcome, Dict{Subshell, Float64}, Dict{Tuple{Subshell, Subshell}, Float64}, JAC.DecayYield.Settings}","page":"API Cascade computations","title":"JAC.Cascade.dumpDecayProbabilities","text":"Cascade.dumpDecayProbabilities(stream::IO, outcome::DecayYield.Outcome, subshEnergies::Dict{Subshell,Float64},                                 aProbabilities::Dict{Tuple{Subshell,Subshell},Float64},settings::DecayYield.Settings)       ... dumps the Auger decay probabilities to a selected data file in geant4 form; this is caused by the          geant4 boolean of the DecayYield.Settings; this procedure is rather specific in that a single relativistic          configuration with a single core hole (subshell) is assumed and that the many-electron rates have been brought back          to a single-particle subshell notation. A neat table is printed to the given stream but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.dumpGeant4Index-Tuple{Subshell}","page":"API Cascade computations","title":"JAC.Cascade.dumpGeant4Index","text":"Cascade.dumpGeant4Index(subsh::Subshell)       ... returns the (integer) index of subshell in the Geant4 convention; an i::Int64 is returned\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.extractLevels-Tuple{Vector{JAC.Cascade.Data}, JAC.Cascade.SimulationSettings}","page":"API Cascade computations","title":"JAC.Cascade.extractLevels","text":"Cascade.extractLevels(data::Array{Cascade.Data,1}, settings::Cascade.SimulationSettings)      ... extracts and sorts all levels from the given cascade data into a new levelList::Array{Cascade.Level,1} to simplify the          propagation of the probabilities. In this list, every level of the overall cascade just occurs just once, together          with its parent lines (which may populate the level) and the daugther lines (to which the pobability may decay).          A levelList::Array{Cascade.Level,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.extractOccupation-Tuple{Vector{JAC.Cascade.Level}, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.extractOccupation","text":"Cascade.extractOccupation(levels::Array{Cascade.Level,1}, groundConfigs::Array{Configuration,1})      ... determines the total occupation of the levels in (one of) the groundConfigs. A occ::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.extractPhotoExcitationData-Tuple{Vector{Dict{String, Any}}}","page":"API Cascade computations","title":"JAC.Cascade.extractPhotoExcitationData","text":"Cascade.extractPhotoExcitationData(dataDicts::Array{Dict{String,Any},1})      ... returns the available photoexcitation data.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.extractPhotoIonizationData-Tuple{Vector{Dict{String, Any}}}","page":"API Cascade computations","title":"JAC.Cascade.extractPhotoIonizationData","text":"Cascade.extractPhotoIonizationData(dataDicts::Array{Dict{String,Any},1})      ... returns the available photoionization data.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.findLevelIndex-Tuple{JAC.Cascade.Level, Vector{JAC.Cascade.Level}}","page":"API Cascade computations","title":"JAC.Cascade.findLevelIndex","text":"Cascade.findLevelIndex(level::Cascade.Level, levels::Array{Cascade.Level,1})      ... find the index of the given level within the given list of levels; an idx::Int64 is returned and an error message is          issued if the level is not found in the list.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateBlocks-Tuple{JAC.Cascade.Computation, Vector{Configuration}, Dict{Subshell, Orbital}}","page":"API Cascade computations","title":"JAC.Cascade.generateBlocks","text":"Cascade.generateBlocks(comp::Cascade.Computation, confs::Array{Configuration,1}, initalOrbitals::Dict{Subshell, Orbital};                          sa::String=\"\", printout::Bool=true)       ... generate all block::Cascade.Block's, that need to be computed for this cascade, and compute also the corresponding multiplets.         The different cascade approches enables one to realized follow different strategies how these block are selected and computed.          A blockList::Array{Cascade.Block,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateBlocks-Tuple{JAC.Cascade.DielectronicRecombinationScheme, JAC.Cascade.Computation, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.generateBlocks","text":"Cascade.generateBlocks(scheme::Cascade.DielectronicRecombinationScheme, comp::Cascade.Computation, confs::Array{Configuration,1}; printout::Bool=true)       ... generate all block::Cascade.Block's, that need to be computed for this electron-capture and subsequent stabilization (DR) cascade,          and compute also the corresponding multiplets. The different cascade approches realized different strategies how these blocks are          selected and computed. A blockList::Array{Cascade.Block,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateBlocks-Tuple{JAC.Cascade.ExpansionOpacityScheme, JAC.Cascade.Computation, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.generateBlocks","text":"Cascade.generateBlocks(scheme::Cascade.ExpansionOpacityScheme, comp::Cascade.Computation, confs::Array{Configuration,1}; printout::Bool=true)       ... generate all block::Cascade.Block's, that need to be computed for this expansion opacity cascade, and compute also the corresponding          multiplets. The different cascade approches realizes different strategies how these blocks are selected and computed.          A blockList::Array{Cascade.Block,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateBlocks-Tuple{JAC.Cascade.HollowIonScheme, JAC.Cascade.Computation, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.generateBlocks","text":"Cascade.generateBlocks(scheme::Cascade.HollowIonScheme, comp::Cascade.Computation, confs::Array{Configuration,1}; printout::Bool=true)       ... generate all block::Cascade.Block's, that need to be computed for this electron-capture and subsequent stabilization (DR) cascade,          and compute also the corresponding multiplets. The different cascade approches realized different strategies how these block are          selected and computed. A blockList::Array{Cascade.Block,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateBlocks-Tuple{JAC.Cascade.ImpactExcitationScheme, JAC.Cascade.Computation, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.generateBlocks","text":"Cascade.generateBlocks(scheme::Cascade.ImpactExcitationScheme, comp::Cascade.Computation, confs::Array{Configuration,1}; printout::Bool=true)       ... generate all block::Cascade.Block's, that need to be computed for this impact-excitation cascade, and compute also          the corresponding multiplets. The different cascade approches realized different strategies how these block are selected          and computed. A blockList::Array{Cascade.Block,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateBlocks-Tuple{JAC.Cascade.PhotoExcitationScheme, JAC.Cascade.Computation, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.generateBlocks","text":"Cascade.generateBlocks(scheme::Cascade.PhotoExcitationScheme, comp::Cascade.Computation, confs::Array{Configuration,1}; printout::Bool=true)       ... generate all block::Cascade.Block's, that need to be computed for this excitation cascade, and compute also the corresponding multiplets.         The different cascade approches realized different strategies how these block are selected and computed. A blockList::Array{Cascade.Block,1}          is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateBlocks-Tuple{JAC.Cascade.PhotoIonizationScheme, JAC.Cascade.Computation, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.generateBlocks","text":"Cascade.generateBlocks(scheme::Cascade.PhotoIonizationScheme, comp::Cascade.Computation, confs::Array{Configuration,1}; printout::Bool=true)       ... generate all block::Cascade.Block's, that need to be computed for this excitation cascade, and compute also the corresponding multiplets.         The different cascade approaches realizes different strategies how these block are selected and computed.          A blockList::Array{Cascade.Block,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateBlocks-Tuple{JAC.Cascade.RadiativeRecombinationScheme, JAC.Cascade.Computation, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.generateBlocks","text":"Cascade.generateBlocks(scheme::Cascade.RadiativeRecombinationScheme, comp::Cascade.Computation, confs::Array{Configuration,1}; printout::Bool=true)       ... generate all block::Cascade.Block's, that need to be computed for this radiative recombination cascade, and compute also the          corresponding multiplets. The different cascade approaches help realize different strategies how these blocks are          selected and computed. A blockList::Array{Cascade.Block,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationList-Tuple{Vector{Multiplet}, Int64, Int64}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationList","text":"Cascade.generateConfigurationList(multiplets::Array{Multiplet,1}, further::Int64, NoShake::Int64)       ... generates all possible (decay) configurations with up to further holes and with NoShake displacements with regard         to the given multiplets. First, all configuratons are generated for which the hole is either moved 'outwards' or          is moved and a second 'outer' hole is created; this step is repated further + 2 times to make sure that all relevant         configurations are met. From the generated list, however, only those configurations are kept eventually with          up to further holes, when compared to the configurations of the given multiplets. A confList::Array{Configuration,1}          is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsForDielectronicCapture-Tuple{Vector{Multiplet}, JAC.Cascade.DielectronicRecombinationScheme, Model, JAC.Radial.Grid}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsForDielectronicCapture","text":"Cascade.generateConfigurationsForDielectronicCapture(multiplets::Array{Multiplet,1},  scheme::DielectronicRecombinationScheme,                                                      nm::Nuclear.Model, grid::Radial.Grid)       ... generates all possible doubly-excited configurations due to (dielectronic) electron capture into the given multiplets.         The number and type of such doubly-generated configurations depend on (1) the maximum (electron) energy for capturing an electron         that is closely related to the (maximum) temperature of the plasma; (2) the fromShells from which (and how many displacements)         are accepted as well as (3) the maximum principle and orbital angular quantum number of the additional (to-) shellsthe fromShells         into which electrons excited and/or captured. A Tuple(initialConfList::Array{Configuration,1}, confList::Array{Configuration,1})          is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsForExpansionOpacity-Tuple{Vector{Configuration}, JAC.Cascade.ExpansionOpacityScheme, Model, JAC.Radial.Grid}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsForExpansionOpacity","text":"Cascade.generateConfigurationsForExpansionOpacity(initialConfigs::Array{Configuration,1}, scheme::ExpansionOpacityScheme,                                                      nm::Nuclear.Model, grid::Radial.Grid)       ... generates all excited configurations for the expansion opacity computations due the given fromShells, toShells and number         of excited electrons. A confList::Array{Configurations,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsForHollowIons-Tuple{Vector{Configuration}, Vector{Shell}, Vector{Shell}, Int64}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsForHollowIons","text":"Cascade.generateConfigurationsForHollowIons(initialConfigs::Array{Configurations,1}, intoShells::Array{Shell,1},                                                  decayShells::Array{Shell,1}, noElectrons::Int64)       ... generates all possible configurations as obtained by the capture of noElectrons into the intoShells.          A confList::Array{Configuration,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsForImpactExcitation-Tuple{Vector{Multiplet}, JAC.Cascade.ImpactExcitationScheme, Model}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsForImpactExcitation","text":"Cascade.generateConfigurationsForImpactExcitation(multiplets::Array{Multiplet,1},  scheme::ImpactExcitationScheme, nm::Nuclear.Model)       ... generates all possible (electron-impact excited) configurations due to the single excitation scheme.fromShells to         scheme.toShells with regard to the given mutiplets.          A Tuple(initialConfList::Array{Configuration,1}, confList::Array{Configuration,1}) is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsForPhotoexcitation-Tuple{Vector{Multiplet}, JAC.Cascade.PhotoExcitationScheme, Model}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsForPhotoexcitation","text":"Cascade.generateConfigurationsForPhotoexcitation(multiplets::Array{Multiplet,1},  scheme::PhotoExcitationScheme, nm::Nuclear.Model)       ... generates all possible (photo-excited) configurations with upto  scheme.NoExcitations of displacements of electron from         scheme.excitationFromShells  to  scheme.excitationToShells  with regard to the given mutiplets.         A Tuple(initialConfList::Array{Configuration,1}, confList::Array{Configuration,1}) is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsForPhotoionization-Tuple{Vector{Multiplet}, JAC.Cascade.PhotoIonizationScheme, Model}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsForPhotoionization","text":"Cascade.generateConfigurationsForPhotoionization(multiplets::Array{Multiplet,1},  scheme::PhotoIonizationScheme, nm::Nuclear.Model)       ... generates all possible (photo-absorption) configurations with a single displacements of an electron from         scheme.excitationFromShells  to either scheme.excitationToShells or into partial waves with scheme.lValues.         A Tuple(initialConfList::Array{Configuration,1}, confList::Array{Configuration,1}) is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsForRadiativeRecombination-Tuple{Vector{Multiplet}, JAC.Cascade.RadiativeRecombinationScheme, Model, JAC.Radial.Grid}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsForRadiativeRecombination","text":"Cascade.generateConfigurationsForRadiativeRecombination(multiplets::Array{Multiplet,1},  scheme::RadiativeRecombinationScheme,                                                              nm::Nuclear.Model, grid::Radial.Grid)       ... generates all possible configurations due to radiative recombination into the given multiplets.         The number and type of such (singly-excited) configurations depend on the maximum principle and orbital angular quantum number          of the additional intoShells, into which electrons are captured.          A Tuple(initialConfList::Array{Configuration,1}, confList::Array{Configuration,1}) is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsForStepwiseDecay-Tuple{JAC.Cascade.StepwiseDecayScheme, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsForStepwiseDecay","text":"Cascade.generateConfigurationsForStepwiseDecay(scheme::Cascade.StepwiseDecayScheme, initialConfigs::Array{Configurations,1})       ... generates all possible configurations as obtained by a stepwise loss of maxElectronLoss electrons and by considering         NoShakeDisplacements displacements. A confList::Array{Configuration,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsWith1OuterHole-Tuple{Configuration, Shell}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsWith1OuterHole","text":"Cascade.generateConfigurationsWith1OuterHole(conf,  holeShell)       ... generates all possible (decay) configurations where the hole in holeShell is moved 'outwards'.          A confList::Array{Configuration,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsWith1OuterHole-Tuple{Vector{Configuration}, Vector{Shell}}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsWith1OuterHole","text":"Cascade.generateConfigurationsWith1OuterHole(configs::Array{Configuration,1},  holeShells::Array{Shell,1})       ... generates all possible (decay) configurations where one hole from holeShells is moved 'outwards'.          A confList::Array{Configuration,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsWith2OuterHoles-Tuple{Configuration, Shell}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsWith2OuterHoles","text":"Cascade.generateConfigurationsWith2OuterHoles(conf,  holeShell)       ... generates all possible (decay) configurations where the hole in holeShell is moved 'outwards'.          A confList::Array{Configuration,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.generateConfigurationsWith2OuterHoles-Tuple{Vector{Configuration}, Vector{Shell}}","page":"API Cascade computations","title":"JAC.Cascade.generateConfigurationsWith2OuterHoles","text":"Cascade.generateConfigurationsWith2OuterHoles(configs::Array{Configuration,1},  holeShells::Array{Shell,1})       ... generates all possible (decay) configurations where two holes from holeShells are moved 'outwards'.          A confList::Array{Configuration,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.groupDisplayConfigurationList-Tuple{Float64, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.groupDisplayConfigurationList","text":"Cascade.groupDisplayConfigurationList(Z::Float64, confs::Array{Configuration,1}; sa::String=\"\")      ... group & display the configuration list into sublists with the same No. of electrons; this lists are displayed together          with an estimated total energy. An ordered confList::Array{Configuration,1} is returned with configurations of decreasing         number of electrons.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.interpolateIonizationCS-Tuple{Float64, Vector{JAC.Basics.ScalarProperty{JAC.Basics.EmProperty}}}","page":"API Cascade computations","title":"JAC.Cascade.interpolateIonizationCS","text":"Cascade.interpolateIonizationCS(photonEnergy::Float64, ionizationCS::Array{Basics.ScalarProperty{EmProperty},1})      ... interpolates (or extrapolates) the ionization cross sections as defined by ionizationCS for the given photonEnergy.         If photonEnergy is outside the photon energies from ionizationCS, simply the cross section from the nearest energy         is returned; if photonEnergy lays between two photon energies from ionizationCS, a simple linear interpolation         rules is applied here. A cs::Basics.EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.modifySteps-Tuple{Vector{JAC.Cascade.Step}}","page":"API Cascade computations","title":"JAC.Cascade.modifySteps","text":"Cascade.modifySteps(stepList::Array{Cascade.Step,1})      ... allows the user to modify the steps, for instance, by deleting selected steps of the cascade or by modifying the settings of         one or several steps. A newStepList::Array{Cascade.Step,1} for which the transition data are eventually computed.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.perform-Tuple{JAC.Cascade.DielectronicRecombinationScheme, JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Cascade.perform","text":"Cascade.perform(scheme::DielectronicRecombinationScheme, comp::Cascade.Computation)       ... to set-up and perform a dielectronic-recombination (DR) plasma rate coefficient computation that combines the electron capture         and the subsequent radiative stabilization steps. Such a computation starts from a given set of initial configurations xor          initial multiplets and (1) generates all doubly-excited configurations due to the capture of an electron with a given maximum         electron energy; (2) selects all electron capture (inverse Auger) and re-autoionization (Auger) steps and (3) selects         all steps for radiative stabilization due to given parameters of the scheme::DielectronicRecombinationScheme. The results of          these DR plasma rate computation are comprised into (output) data::ExcitationData, while these data are only printed during          the generation and nothing is returned.\n\nCascade.perform(scheme::DielectronicRecombinationScheme, comp::Cascade.Computation; output=true, outputToFile::Bool=true)        ... to perform the same but to return the complete output in a dictionary that is written to disk and can be used in subsequent         cascade simulation. The particular output depends on the specifications of the cascade.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.perform-Tuple{JAC.Cascade.ElectronExcitationScheme, JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Cascade.perform","text":"Cascade.perform(scheme::ElectronExcitationScheme, comp::Cascade.Computation)       ... to set-up and perform an electron-excitation cascade computation that accounts for the direct and resonant part.          Apart from the direct electron-impact excitation of the atom, it enables one to treat the (resonant) dielectronic         capture with subsequent electron emission (re-autoionization) in the cascade. Typical electron-excitation         properties are energy-dependent collision strengths, impact-excitation cross sections, effective collision strengths,         and several others.\n\nCascade.perform(scheme::ElectronExcitationScheme, comp::Cascade.Computation; output=true, outputToFile::Bool=true)        ... to perform the same but to return the complete output in a dictionary that is written to disk and can be used in          subsequent cascade simulation. The particular output depends on the specifications of the cascade.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.perform-Tuple{JAC.Cascade.ExpansionOpacityScheme, JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Cascade.perform","text":"Cascade.perform(scheme::ExpansionOpacityScheme, comp::Cascade.Computation)       ... to set-up and perform an expansion opacity computation; it starts from a given set of initial configurations xor initial          multiplets and (1) generates all excited configurations with regard to the initial configuration, (2) selects all          radiative photoabsorption steps and (3) computes the corresponding transition amplitudes. The results of these expansion opacity          computations are comprised into (output) data::ExcitationData, while these data are only printed during the generation and          nothing is returned.\n\nCascade.perform(scheme::ExpansionOpacityScheme, comp::Cascade.Computation; output=true, outputToFile::Bool=true)        ... to perform the same but to return the complete output in a dictionary that is written to disk and can be used in subsequent         cascade simulation. The particular output depends on the specifications of the cascade.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.perform-Tuple{JAC.Cascade.HollowIonScheme, JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Cascade.perform","text":"Cascade.perform(scheme::HollowIonScheme, comp::Cascade.Computation)       ... to set-up and perform a dielectronic-recombination (DR) plasma rate coefficient computation that combines the electron capture         and the subsequent radiative stabilization steps. Such a computation starts from a given set of initial configurations xor          initial multiplets and (1) generates all doubly-excited configurations due to the capture of an electron with a given maximum         electron energy; (2) selects all electron capture (inverse Auger) and re-autoionization (Auger) steps and (3) selects         all steps for radiative stabilization due to given parameters of the scheme::HollowIonScheme. The results of          these DR plasma rate computation are comprised into (output) data::ExcitationData, while these data are only printed during          the generation and nothing is returned.\n\nCascade.perform(scheme::HollowIonScheme, comp::Cascade.Computation; output=true, outputToFile::Bool=true)        ... to perform the same but to return the complete output in a dictionary that is written to disk and can be used in subsequent         cascade simulation. The particular output depends on the specifications of the cascade.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.perform-Tuple{JAC.Cascade.ImpactExcitationScheme, JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Cascade.perform","text":"Cascade.perform(scheme::ImpactExcitationScheme, comp::Cascade.Computation)       ... to set-up and perform a electron-impact excitation computation that starts from a given set of initial configurations          xor initial multiplets and comprises the impact-excitation of different fromShells to the toShells. All configurations          are constructed with regard to the initial configurations. The results of these impact-excitation computations          are comprised into (output) data::??? but nothing is returned as default.\n\nCascade.perform(scheme::ImpactExcitationScheme, comp::Cascade.Computation; output=true, outputToFile::Bool=true)        ... to perform the same but to return the complete output in a dictionary that is written to disk and can be used in subsequent         cascade simulation. The particular output depends on the specifications of the cascade.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.perform-Tuple{JAC.Cascade.PhotoAbsorptionScheme, JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Cascade.perform","text":"Cascade.perform(scheme::PhotoAbsorptionScheme, comp::Cascade.Computation)       ... to set-up and perform a photoabsorption cascade computation that that accounts for the direct and resonant          of photoabsorption. Apart from the direct photoionization of the atom, it enables one to treat the photoexcitation          and subsequent electron emission (autoionization) in the cascade. Typical photoabsorption properties are          energy-dependent photoionization cross sections, photoabsorption spectra, PI plasma rate coefficients, and others.         The results of a photoabsorption cascade computation are comprised into (output) data::ExcitationData, while          nothing is returned otherwise.\n\nCascade.perform(scheme::PhotoAbsorptionScheme, comp::Cascade.Computation; output=true, outputToFile::Bool=true)        ... to perform the same but to return the complete output in a dictionary that is written to disk and can be used in subsequent         cascade simulation. The particular output depends on the specifications of the cascade.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.perform-Tuple{JAC.Cascade.PhotoExcitationScheme, JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Cascade.perform","text":"Cascade.perform(scheme::PhotoExcitationScheme, comp::Cascade.Computation)       ... to set-up and perform a photo-excitation computation that starts from a given set of initial configurations xor initial multiplets         and comprises (various) photoexcitation processes into configurations with up-to NoExcitations single-electron excitations with          regard to the initial multiplets. The results of these excitation are comprised into (output) data::PhotoExcData, while these          data are only printed during the generation and nothing is returned.\n\nCascade.perform(scheme::PhotoExcitationScheme, comp::Cascade.Computation; output=true, outputToFile::Bool=true)        ... to perform the same but to return the complete output in a dictionary that is written to disk and can be used in subsequent         cascade simulation. The particular output depends on the specifications of the cascade.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.perform-Tuple{JAC.Cascade.PhotoIonizationScheme, JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Cascade.perform","text":"Cascade.perform(scheme::PhotoIonizationScheme, comp::Cascade.Computation)       ... to set-up and perform a photo-excitation computation that starts from a given set of initial configurations xor initial multiplets         and comprises (various) photoexcitation processes into configurations with up-to NoExcitations single-electron excitations with          regard to the initial multiplets. The results of these excitation are comprised into (output) data::PhotoExcData, while these          data are only printed during the generation and nothing is returned.\n\nCascade.perform(scheme::PhotoIonizationScheme, comp::Cascade.Computation; output=true, outputToFile::Bool=true)        ... to perform the same but to return the complete output in a dictionary that is written to disk and can be used in subsequent         cascade simulation. The particular output depends on the specifications of the cascade.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.perform-Tuple{JAC.Cascade.RadiativeRecombinationScheme, JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Cascade.perform","text":"Cascade.perform(scheme::RadiativeRecombinationScheme, comp::Cascade.Computation)       ... to set-up and perform a radiative-recombination (RR) plasma rate coefficient computation basedm on all selected electron          capture steps. Such a computation starts from a given set of initial configurations xor initial multiplets and          (1) generates all singly-excited configurations due to the capture of an electron with a given maximum electron energy;          (2) selects all steps for radiative recombination due to given parameters of the scheme::RadiativeRecombinationScheme.          The results of these RR plasma rate computation are comprised into (output) data::DecayData, while these data are only          printed during the generation and nothing is returned.\n\nCascade.perform(scheme::RadiativeRecombinationScheme, comp::Cascade.Computation; output=true, outputToFile::Bool=true)        ... to perform the same but to return the complete output in a dictionary that is written to disk and can be used in subsequent         cascade simulation. The particular output depends on the specifications of the cascade.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.perform-Tuple{JAC.Cascade.Simulation}","page":"API Cascade computations","title":"JAC.Cascade.perform","text":"Cascade.perform(simulation::Cascade.Simulation       ... to simulate a cascade decay (and excitation) from the given data. Different computational methods and different properties of          the ionic system, such as the ion distribution or final-level distribution can be derived and displayed from these simulations.          Of course, the details of these simulations strongly depend on the atomic processes and data that have been generated before by          performing a computation::Cascade.Computation. The results of all individual steps are printed to screen but nothing is          returned otherwise.\n\nCascade.perform(simulation::Cascade.Simulation; output=true)        ... to perform the same but to return the complete output in a dictionary; the particular output depends on the method and          specifications of the cascade but can easily accessed by the keys of this dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.perform-Tuple{JAC.Cascade.StepwiseDecayScheme, JAC.Cascade.Computation}","page":"API Cascade computations","title":"JAC.Cascade.perform","text":"Cascade.perform(scheme::StepwiseDecayScheme, comp::Cascade.Computation)       ... to set-up and perform a cascade computation that starts from a given set of initial configurations and proceeds via          various steps until a given number of electrons has been removed or the decay stops at some stable levels with regard          to the given atomic processes. The results of all individual steps are printed to screen but nothing is returned          otherwise.\n\nCascade.perform(scheme::StepwiseDecayScheme, comp::Cascade.Computation; output::Bool=false, outputToFile::Bool=true)        ... to perform the same but to return the complete output in a dictionary;  the particular output depends on the type          and specifications of the cascade but can easily accessed by the keys of this dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.propagateOccupationInTime!-Tuple{Vector{JAC.Cascade.Level}, Float64}","page":"API Cascade computations","title":"JAC.Cascade.propagateOccupationInTime!","text":"Cascade.propagateOccupationInTime!(levels::Array{Cascade.Level,1}, dt::Float64)      ... propagates the occupation of the levels by dt in time. \n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.propagateProbability!-Tuple{Vector{JAC.Cascade.Level}}","page":"API Cascade computations","title":"JAC.Cascade.propagateProbability!","text":"Cascade.propagateProbability!(levels::Array{Cascade.Level,1};                                  collectPhotonIntensities::Bool=false, collectElectronIntensities::Bool=false)      ... propagates the relative level occupation through the levels of the cascade until no further change occur in the          relative level occupation. The argument levels is modified during the propagation, but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.pushLevels!-Tuple{Vector{JAC.Cascade.Level}, JAC.Cascade.Level}","page":"API Cascade computations","title":"JAC.Cascade.pushLevels!","text":"Cascade.pushLevels!(levels::Array{Cascade.Level,1}, newLevel::Cascade.Level)      ... push's the information of newLevel of levels. This is the standard 'push!(levels, newLevel)' if newLevel is not yet          including in levels, and the proper modification of the parent and daugther lines of this level otherwise. The argument          levels::Array{Cascade.Level,1} is modified and nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.reviewData-Tuple{JAC.Cascade.Simulation}","page":"API Cascade computations","title":"JAC.Cascade.reviewData","text":"Cascade.reviewData(simulation::Cascade.Simulation; ascendingOrder::Bool=false)      ... reviews and displays the (computation) data for the given simulation; these data contains the name of the data set,          its initial and generated multiplets for the various blocks of (some part of the ionization and/or decay) cascade as          well as all the line data [lineR, linesA, lineP, ...]. From these data, this function also generates and returns         the level tree that is to be used in the subsequent simulations, and where levels are odered in `ascending' order         if selected.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.simulateDrRateCoefficients-Tuple{Vector{JAC.Cascade.Level}, JAC.Cascade.Simulation}","page":"API Cascade computations","title":"JAC.Cascade.simulateDrRateCoefficients","text":"Cascade.simulateDrRateCoefficients(levels::Array{Cascade.Level,1}, simulation::Cascade.Simulation)      ... Determines and prints the DR resonance strength and (plasma) rate coefficients for all resonance levels.         Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.simulateExpansionOpacities-Tuple{Vector{JAC.Cascade.Data}, String, JAC.Cascade.ExpansionOpacities}","page":"API Cascade computations","title":"JAC.Cascade.simulateExpansionOpacities","text":"Cascade.simulateExpansionOpacities(photoexcitationData::Array{Cascade.Data,1}, name::String,                                      property::Cascade.ExpansionOpacities; printout::Bool=true)      ... runs through all excitation lines, sums up their contributions and form a (list of) expansion opacities for the given          parameters. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.simulateFinalLevelDistribution-Tuple{Vector{JAC.Cascade.Level}, JAC.Cascade.Simulation}","page":"API Cascade computations","title":"JAC.Cascade.simulateFinalLevelDistribution","text":"Cascade.simulateFinalLevelDistribution(levels::Array{Cascade.Level,1}, simulation::Cascade.Simulation)      ... sorts all levels as given by data and propagates their (occupation) probability until no further changes occur. For this          propagation, it runs through all levels and propagates the probability until no level probability changes anymore.          Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.simulateIonDistribution-Tuple{Vector{JAC.Cascade.Level}, JAC.Cascade.Simulation}","page":"API Cascade computations","title":"JAC.Cascade.simulateIonDistribution","text":"Cascade.simulateIonDistribution(levels::Array{Cascade.Level,1}, simulation::Cascade.Simulation)      ... sorts all levels as given by data and propagates their (occupation) probability until no further changes occur. For this          propagation, it runs through all levels and propagates the probabilty until no level probability changes anymore. The final          level distribution is then used to derive the ion distribution or the level distribution, if appropriate. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.simulateLevelDistribution-Tuple{Vector{JAC.Cascade.Level}, JAC.Cascade.Simulation}","page":"API Cascade computations","title":"JAC.Cascade.simulateLevelDistribution","text":"Cascade.simulateLevelDistribution(levels::Array{Cascade.Level,1}, simulation::Cascade.Simulation)      ... sorts all levels as given by data and propagates their (occupation) probability until no further changes occur. For this          propagation, it runs through all levels and propagates the probabilty until no level probability changes anymore. The final          level distribution is then used to derive the ion distribution or the level distribution, if appropriate. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.simulateMeanRelaxationTime-Tuple{Vector{JAC.Cascade.Level}, JAC.Cascade.Simulation}","page":"API Cascade computations","title":"JAC.Cascade.simulateMeanRelaxationTime","text":"Cascade.simulateMeanRelaxationTime(levels::Array{Cascade.Level,1}, simulation::Cascade.Simulation)      ... determine the mean relaxation time until 70%, 80%, 90%  of the initially occupied levels decay down to         the ground configurations. An relaxTimes::Array{Float64,1} is returned that contains the         mean relaxation times for 70%, 80%, 90%, ...\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.simulatePhotoAbsorptionSpectrum-Tuple{JAC.Cascade.Simulation, Vector{JAC.PhotoIonization.Line}, Vector{JAC.PhotoExcitation.Line}}","page":"API Cascade computations","title":"JAC.Cascade.simulatePhotoAbsorptionSpectrum","text":"Cascade.simulatePhotoAbsorptionSpectrum(simulation::Cascade.Simulation,                                              linesP::Array{PhotoIonization.Line,1}, linesE::Array{PhotoExcitation.Line,1})      ... cycle through all lines and (incident photon) energies to derive the overall photo-absorption spectrum.         The procedure interpolates the photoionization and 'adds' the photoexcitation cross sections to obtain the          total photoabsorption CS. A linear interpolation is used inside of the energy interval, for which photoionization          lines and cross sections have been calculated before. No extrapolation of cross sections is done here.         It is also assumed that the same initial levels (indices) appear in the photoionization and photoexcitation lines.         Moreover, energy units must be one of \"eV\", \"Kayser\", \"Hartree\"].         All absorption cross sections are displayed in a neat table and are returned as lists.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.simulatePhotonIntensities-Tuple{Vector{JAC.Cascade.Level}, JAC.Cascade.Simulation}","page":"API Cascade computations","title":"JAC.Cascade.simulatePhotonIntensities","text":"Cascade.simulatePhotonIntensities(levels::Array{Cascade.Level,1}, simulation::Cascade.Simulation)      ... sorts all levels as given by data and propagates their (occupation) probability until no further changes occur. For this          propagation, it runs through all levels and propagates the probabilty until no level probability changes anymore. The final          level distribution is then used to derive the ion distribution or the level distribution, if appropriate. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.simulateRosselandOpacities-Tuple{Vector{JAC.Cascade.Data}, JAC.Cascade.Simulation}","page":"API Cascade computations","title":"JAC.Cascade.simulateRosselandOpacities","text":"Cascade.simulateRosselandOpacities(photoexcitationData::Array{Cascade.Data,1}, simulation::Cascade.Simulation)      ... runs through all excitation lines, sums up their contributions and form a (list of) Rosseland opacities, based on         the expansion opacities, for the given parameters. Nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.simulateRrRateCoefficients-Tuple{Vector{JAC.PhotoRecombination.Line}, Any}","page":"API Cascade computations","title":"JAC.Cascade.simulateRrRateCoefficients","text":"Cascade.simulateRrRateCoefficients(lines::Array{PhotoRecombination.Line,1}, simulation)      ... Integrates over all selected cross sections in order to determine the RR plasma rate coefficients for a Maxwellian         distribution.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.sortByEnergy-Tuple{Vector{JAC.Cascade.Level}}","page":"API Cascade computations","title":"JAC.Cascade.sortByEnergy","text":"Cascade.sortByEnergy(levels::Array{Cascade.Level,1}; ascendingOrder::Bool=false)      ... sorts all levels by energy and assigns the occupation as given by the simulation\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.specifyInitialOccupation!-Tuple{Vector{JAC.Cascade.Level}, Vector{Configuration}}","page":"API Cascade computations","title":"JAC.Cascade.specifyInitialOccupation!","text":"Cascade.specifyInitialOccupation!(levels::Array{Cascade.Level,1}, leadingConfigs::Array{Configuration,1})      ... specifies the initial occupation of levels for the given leadingConfigs; it modifies the occupation          but returns nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.specifyInitialOccupation!-Tuple{Vector{JAC.Cascade.Level}, Vector{Tuple{Int64, Float64}}}","page":"API Cascade computations","title":"JAC.Cascade.specifyInitialOccupation!","text":"Cascade.specifyInitialOccupation!(levels::Array{Cascade.Level,1}, initialOccupations::Array{Tuple{Int64,Float64},1})      ... specifies the initial occupation of levels for the given relOccupation; it modifies the occupation          but returns nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#JAC.Cascade.truncateEnergiesIntensities-Tuple{Vector{Tuple{Float64, Float64}}, Float64, Float64}","page":"API Cascade computations","title":"JAC.Cascade.truncateEnergiesIntensities","text":"Cascade.truncateEnergiesIntensities(energiesInts::Array{Tuple{Float64,Float64},1}, minPhotonEnergy::Float64, maxPhotonEnergy::Float64)      ... reduces and truncates the energies & intensities  energiesInts; 'reduce' hereby refer to omit all intensity < 1.0e-8,         while 'truncate' omits all energies outside of the interval [minPhotonEnergy, miaxPhotonEnergy]. An          newEnergiesInts::Array{Tuple{Float64,Float64},1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-cascades.html#Dielectronic-recombination-scheme","page":"API Cascade computations","title":"Dielectronic recombination scheme","text":"","category":"section"},{"location":"api-cascades.html","page":"API Cascade computations","title":"API Cascade computations","text":"Modules = [Cascade]\nPages   = [\"inc-dielectronic-recombination.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api-cascades.html#Stepwise-decay-scheme","page":"API Cascade computations","title":"Stepwise decay scheme","text":"","category":"section"},{"location":"api-cascades.html","page":"API Cascade computations","title":"API Cascade computations","text":"Modules = [Cascade]\nPages   = [\"inc-stepwise-decay.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"news.html#Recently-implemented-features-and-up-dates","page":"News","title":"Recently implemented features and up-dates","text":"","category":"section"},{"location":"news.html#2025","page":"News","title":"2025","text":"","category":"section"},{"location":"news.html","page":"News","title":"News","text":"New B-Spline module: The B-Spline bases of atomic orbitals has been re-implemented to make self-consistent-field   computations more efficient. (March'25) \nRe-organized Plasma.Computation(): The computation of plasma properties have been expanded and re-organized    in order to support the SahaBoltzmannScheme and the LineShiftScheme. (January'25) ","category":"page"},{"location":"news.html#2024","page":"News","title":"2024","text":"","category":"section"},{"location":"news.html","page":"News","title":"News","text":"Dielectronic recombination into high-h shells: New empirical and run-time features now support the efficient    computation of DR resonances strengths if the electron capture occurs into high-n (n > 15) shells.  (October'24) \nNew and re-organized basic data types: Several new abstract and concrete data types have been implemented   (and re-organized) in the module Basics. (August'24) \nFirst design of empirical computations: A new kind Empirical.Computation() has been established to support   electron-impact ionization (EII) cross sections. (March'24) ","category":"page"},{"location":"api-racah.html#Racah-algebra-evaluations","page":"API Racah algebra","title":"Racah algebra evaluations","text":"","category":"section"},{"location":"api-racah.html","page":"API Racah algebra","title":"API Racah algebra","text":"Modules = [RacahAlgebra]\nOrder   = [:type, :function]","category":"page"},{"location":"api-racah.html#JAC.RacahAlgebra.AbstractRecursionW3j","page":"API Racah algebra","title":"JAC.RacahAlgebra.AbstractRecursionW3j","text":"abstract type RacahAlgebra.AbstractRecursionW3j      ... defines an abstract and a number of singleton types for the recursion rules for Wigner 3-j symbols.\n\n+ RecursionW3jMagnetic      ... Recursion wrt. the magnetic quantum numbers.\n+ RecursionW3jOneStep       ... Recursion with step-1 of the j-quantum numbers.\n+ RecursionW3jHalfStep      ... Recursion with step-1/2 of the j-quantum numbers.\n+ RecursionW3jLouck         ... Recursion wrt. j-quantum numbers due to Louck.\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.AngMomentum","page":"API Racah algebra","title":"JAC.RacahAlgebra.AngMomentum","text":"struct RacahAlgebra.AngMomentum      ... defines an (abstract) data types for symbolic angular momenta which accept the types          Basic, Symbol, Int64 and Rational{Int64} and check for being consistent with angular momenta.\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.Csq","page":"API Racah algebra","title":"JAC.RacahAlgebra.Csq","text":"struct  RacahAlgebra.Csq       ... defines a type for a coupling sequence of two angular momenta (a,b) c   or  a + b -> c  with symbolic arguments.\n\n+ a    ::Union{Basic,RacahAlgebra.Csq}      ... First angular momentum or coupling sequence.\n+ b    ::Union{Basic,RacahAlgebra.Csq}      ... Second angular momentum or coupling sequence.\n+ c    ::Basic                              ... Angular momentum to which a + b is coupled.\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.Djpq","page":"API Racah algebra","title":"JAC.RacahAlgebra.Djpq","text":"struct  RacahAlgebra.Djpq       ... defines a type for the (small and real !!) Wigner rotation matrix d^(j)_pq (beta) with symbolic arguments.\n\n+ j, p, q              ::Basic   ... angular momenta\n+ beta                 ::Basic   ... rotation angle\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.Djpq-Tuple{JAC.RacahAlgebra.AngMomentum, JAC.RacahAlgebra.AngMomentum, JAC.RacahAlgebra.AngMomentum, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.Djpq","text":"RacahAlgebra.Djpq(j::AngMomentum, p::AngMomentum, q::AngMomentum, beta::Basic)       ... constructor for defining the spherical harmonic Y_lm (theta,phi) either by Julia Symbol's or SymEngine Basic variables.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.Integral","page":"API Racah algebra","title":"JAC.RacahAlgebra.Integral","text":"struct  RacahAlgebra.Integral       ... defines an (finite) integral, typically over some angle, Int_low^up d var with symbolic arguments.\n\n+ var                  ::Basic   ... integration variable, typically an angle (theta, phi, beta, ...)\n+ low, up              ::Basic   ... lower, upper integration bound\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.Kronecker","page":"API Racah algebra","title":"JAC.RacahAlgebra.Kronecker","text":"struct  RacahAlgebra.Kronecker  ... defines a type for a Kronecker delta symbol with symbolic arguments.\n\n+ i, k     ::Basic   ... Kronecker indices\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.Kronecker-Tuple{JAC.RacahAlgebra.AngMomentum, JAC.RacahAlgebra.AngMomentum}","page":"API Racah algebra","title":"JAC.RacahAlgebra.Kronecker","text":"RacahAlgebra.Kronecker(i::AngMomentum, k::AngMomentum)       ... constructor for defining a Kronecker delta symbol either by Julia Symbol's or SymEngine Basic variables.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.RacahExpression","page":"API Racah algebra","title":"JAC.RacahAlgebra.RacahExpression","text":"struct  RacahAlgebra.RacahExpression  ... defines a type for a RacahExpression with symbolic arguments.\n\n+ summations    ::Array{Basic,1}      ... Summation indices.\n+ integrals     ::Array{Integral,1}   ... Integrals.\n+ phase         ::Basic               ... Phase of the Racah expression.\n+ weight        ::Basic               ... Weight of the Racah expression.\n+ deltas        ::Array{Kronecker,1}  ... List of Kronecker deltas.\n+ triangles     ::Array{Triangle,1}   ... List of Triangle deltas.\n+ w3js          ::Array{W3j,1}        ... List of Wigner 3-j symbols\n+ w6js          ::Array{W6j,1}        ... List of Wigner 6-j symbols\n+ w9js          ::Array{W9j,1}        ... List of Wigner 9-j symbols\n+ ylms          ::Array{Ylm,1}        ... List of spherical harmonics\n+ djpqs         ::Array{Djpq,1}       ... List of (small) Wigner rotation matrices\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.RacahExpression-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.RacahExpression","text":"RacahAlgebra.RacahExpression(rex::RacahAlgebra.RacahExpression;\n\n    summations=..,      integrals=..,   phase=..,       weight=..,      deltas=..,     triangles=..,       \n    w3js=..,            w6js=..,        w9js=..,        ylms=..,       djpqs=..) \n                \n... constructor for modifying a given rex::RacahExpression by 'overwriting' the explicitly selected parts of the \n    expression.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.RacahExpression-Tuple{}","page":"API Racah algebra","title":"JAC.RacahAlgebra.RacahExpression","text":"RacahAlgebra.RacahExpression()       ... constructor for defining an empty RacahExpression.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.Triangle","page":"API Racah algebra","title":"JAC.RacahAlgebra.Triangle","text":"struct  RacahAlgebra.Triangle  ... defines a type for a Triangle delta symbol with symbolic arguments.\n\n+ ja, jb, jc     ::Basic   ... angular momenta in the Triangle delta\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.Triangle-Tuple{JAC.RacahAlgebra.AngMomentum, JAC.RacahAlgebra.AngMomentum, JAC.RacahAlgebra.AngMomentum}","page":"API Racah algebra","title":"JAC.RacahAlgebra.Triangle","text":"RacahAlgebra.Triangle(ja::AngMomentum, jb::AngMomentum, jc::AngMomentum)       ... constructor for defining a Triangle delta symbol either by Julia Symbol's or SymEngine Basic variables.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.W3j","page":"API Racah algebra","title":"JAC.RacahAlgebra.W3j","text":"struct  RacahAlgebra.W3j  ... defines a type for a Wigner 3-j symbol with symbolic arguments.\n\n+ ja, jb, jc     ::Basic   ... angular momenta\n+ ma, mb, mc     ::Basic   ... projections of the angular momenta above\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.W3j-NTuple{6, JAC.RacahAlgebra.AngMomentum}","page":"API Racah algebra","title":"JAC.RacahAlgebra.W3j","text":"RacahAlgebra.W3j(ja::AngMomentum, jb::AngMomentum, jc::AngMomentum, ma::AngMomentum, mb::AngMomentum, mc::AngMomentum)       ... constructor for defining the Wigner 3-j symbol either by Julia Symbol's or SymEngine Basic variables.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.W6j","page":"API Racah algebra","title":"JAC.RacahAlgebra.W6j","text":"struct  RacahAlgebra.W6j  ... defines a type for a Wigner 6-j symbol with symbolic arguments.\n\n+ a, b, c, d, e, f     ::Basic   ... angular momenta\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.W6j-NTuple{6, JAC.RacahAlgebra.AngMomentum}","page":"API Racah algebra","title":"JAC.RacahAlgebra.W6j","text":"RacahAlgebra.W6j(a::AngMomentum, b::AngMomentum, c::AngMomentum,                      d::AngMomentum, e::AngMomentum, f::AngMomentum)       ... constructor for defining the Wigner 6-j symbol either by Julia Symbol's or SymEngine Basic variables.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.W9j","page":"API Racah algebra","title":"JAC.RacahAlgebra.W9j","text":"struct  RacahAlgebra.W9j  ... defines a type for a Wigner 9j symbol with symbolic arguments.\n\n+ a, b, c, d, e, f, g, h, i     ::Basic   ... angular momenta\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.W9j-NTuple{9, JAC.RacahAlgebra.AngMomentum}","page":"API Racah algebra","title":"JAC.RacahAlgebra.W9j","text":"RacahAlgebra.W9j(a::AngMomentum, b::AngMomentum, c::AngMomentum,                      d::AngMomentum, e::AngMomentum, f::AngMomentum,                     g::AngMomentum, h::AngMomentum, i::AngMomentum)       ... constructor for defining the Wigner 9j symbol either by Julia Symbol's or SymEngine Basic variables.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.Ylm","page":"API Racah algebra","title":"JAC.RacahAlgebra.Ylm","text":"RacahAlgebra.Ylm(l::AngMomentum, m::AngMomentum, theta::Basic, phi::Basic, star::Bool)       ... constructor for defining the spherical harmonic Y_lm (theta,phi) either by Julia Symbol's or SymEngine Basic variables.         The variable star indicates a complex-conjugate function, and which case a Racah expression is returned.\n\n+ (l::Basic, m::Basic, theta::Basic, phi::Basic, star::Bool)\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#JAC.RacahAlgebra.Ylm-2","page":"API Racah algebra","title":"JAC.RacahAlgebra.Ylm","text":"struct  RacahAlgebra.Ylm  ... defines a type for a spherical harmonic Y_lm (theta,phi) with symbolic arguments.\n\n+ l, m                 ::Basic   ... angular momenta\n+ theta, phi           ::Basic   ... polar and azimuthal angle\n\n\n\n\n\n","category":"type"},{"location":"api-racah.html#Base.:==-Tuple{Djpq, Djpq}","page":"API Racah algebra","title":"Base.:==","text":"Base.:(==)(da::Djpq, db::Djpq)       ... compares two (symbolic) small Wigner rotation matrices d^(j)_pq (beta) and return true if all subfields are equal,          and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#Base.:==-Tuple{Integral, Integral}","page":"API Racah algebra","title":"Base.:==","text":"Base.:(==)(ntga::Integral, ntgb::Integral)       ... compares two (symbolic) integrals and return true if all subfields are equal, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#Base.:==-Tuple{Kronecker, Kronecker}","page":"API Racah algebra","title":"Base.:==","text":"Base.:(==)(wa::Kronecker, wb::Kronecker)       ... compares two (symbolic) Kronecker deltas and return true if all subfields are equal under permutation, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#Base.:==-Tuple{RacahExpression, RacahExpression}","page":"API Racah algebra","title":"Base.:==","text":"Base.:(==)(rexa::RacahExpression, rexb::RacahExpression)       ... compares two (symbolic) Racah expressions and return true if all subfields are equal, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#Base.:==-Tuple{Triangle, Triangle}","page":"API Racah algebra","title":"Base.:==","text":"Base.:(==)(wa::Triangle, wb::Triangle)       ... compares two (symbolic) Triangle deltas and return true if all subfields are equal under permutation,          and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#Base.:==-Tuple{W3j, W3j}","page":"API Racah algebra","title":"Base.:==","text":"Base.:(==)(wa::W3j, wb::W3j)       ... compares two (symbolic) Wigner 3-j symbols and return true if all subfields are equal, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#Base.:==-Tuple{W6j, W6j}","page":"API Racah algebra","title":"Base.:==","text":"Base.:(==)(wa::W6j, wb::W6j)       ... compares two (symbolic) Wigner 6j symbols and return true if all subfields are equal, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#Base.:==-Tuple{W9j, W9j}","page":"API Racah algebra","title":"Base.:==","text":"Base.:(==)(wa::W9j, wb::W9j)       ... compares two (symbolic) Wigner 6j symbols and return true if all subfields are equal, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#Base.:==-Tuple{Ylm, Ylm}","page":"API Racah algebra","title":"Base.:==","text":"Base.:(==)(ya::Ylm, yb::Ylm)       ... compares two (symbolic) spherical harmonics Y_lm (theta,phi) and return true if all subfields are equal,          and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.ClebschGordan-NTuple{6, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.ClebschGordan","text":"RacahAlgebra.ClebschGordan(ja::Basic, ma::Basic, jb::Basic, mb::Basic, jc::Basic, mc::Basic)       ... returns the cg::RacahExpression for a standard Clebsch-Gordan coefficient either by Julia Symbol's or SymEngine          Basic variables.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.ClebschGordanExpansion-NTuple{6, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.ClebschGordanExpansion","text":"RacahAlgebra.ClebschGordanExpansion(ja::Basic, ma::Basic, jb::Basic, mb::Basic, jc::Basic, mc::Basic)       ... returns the expansion rex::RacahExpression for a standard Clebsch-Gordan expansion           |jc, mc > = Sum(ma, mb) |ja, ma > |jb, mb >  <ja ma, jb mb| jc mc>  either by Julia Symbol's or SymEngine          Basic variables.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.DFunction-NTuple{6, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.DFunction","text":"RacahAlgebra.DFunction(j::Basic, p::Basic, q::Basic, alpha::Basic, beta::Basic, gamma::Basic)       ... returns the rex::RacahExpression for a Wigner D-function D^(j)_pq (alpha, beta, gamma) by SymEngine Basic variables.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.countWignerSymbols-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.countWignerSymbols","text":"RacahAlgebra.countWignerSymbols(rex::RacahExpression)       ... counts the (total) number of Wigner nj symbols in rex. A nwnjs::Int64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.equivalentForm-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.equivalentForm","text":"RacahAlgebra.equivalentForm(rex::RacahAlgebra.RacahExpression; regge::Bool=false)       ... generates an (random) equivalent form for the Racah expression rex by using either the classical         (regge = false) or Regge symmetries (regge = true) for the Wigner 3j, 6j or 9j symbols.          A rex:RacahExpression is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.equivalentForm-Tuple{W3j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.equivalentForm","text":"RacahAlgebra.equivalentForm(w3j::RacahAlgebra.W3j; regge::Bool=false)       ... generates an (random) equivalent form for the Wigner 3j symbol w3j by using either the classical         (regge = false) or Regge symmetries (regge = true). A rex:RacahExpression is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.equivalentForm-Tuple{W6j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.equivalentForm","text":"RacahAlgebra.equivalentForm(w6j::RacahAlgebra.W6j; regge::Bool=false)       ... generates an (random) equivalent form for the Wigner 6j symbol w6j by using either the classical         (regge = false) or Regge symmetries (regge = true). A rex:RacahExpression is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.equivalentForm-Tuple{W9j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.equivalentForm","text":"RacahAlgebra.equivalentForm(w9j::RacahAlgebra.W9j; regge::Bool=false)       ... generates an (random) equivalent form for the Wigner 9-j symbol w9j by using either the classical         (regge = false) or Regge symmetries (regge = true). A rex:RacahExpression is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.evaluate-Tuple{Djpq}","page":"API Racah algebra","title":"JAC.RacahAlgebra.evaluate","text":"RacahAlgebra.evaluate(djpq::Djpq)       ... attempts to evaluate a symbolic (small) Wigner rotation matrix by means of special values.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.evaluate-Tuple{JAC.RacahAlgebra.Csq, JAC.RacahAlgebra.Csq}","page":"API Racah algebra","title":"JAC.RacahAlgebra.evaluate","text":"RacahAlgebra.evaluate(leftCsq::RacahAlgebra.Csq, rightCsq::RacahAlgebra.Csq)       ... evaluates a general recoupling coefficient that is defined by two coupling sequences. It first translates the coupling         sequences into Racah expressions, i.e. into sums of Wigner 3-j symbols. A non-zero coefficient is obtained only if         leftCsq.c == rightCsq.c, since re-coupling coefficients are diagonal in the 'last' angular momentum.          A newrex::RacahExpression is returned once a (single) simplification has been found, and nothing otherwise.          No attempt is presently made to find further simplications, once a rule has been applied.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.evaluate-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.evaluate","text":"RacahAlgebra.evaluate(rex::RacahExpression; special::Bool=false)       ... attempts to evaluate and symbolically simplify a Racah expression by means of special values, if         special=true, or by sum rules. A newrex::RacahExpression is returned once a (single) simplification          has been found, and nothing otherwise. No attempt is presently made to find further simplication,          once a rule has been applied.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.evaluate-Tuple{Union{W3j, W6j, W9j}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.evaluate","text":"RacahAlgebra.evaluate(wj::Union{W3j,W6j,W9j})       ... attempts to evaluate a symbolic Wigner 3j, 6j or 9j symbols by means of special values.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.evaluate-Tuple{Ylm}","page":"API Racah algebra","title":"JAC.RacahAlgebra.evaluate","text":"RacahAlgebra.evaluate(ylm::Ylm)       ... attempts to evaluate a symbolic spherical harmonic by means of special values.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.evaluateNumerical-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.evaluateNumerical","text":"RacahAlgebra.evaluateNumerical(rex::RacahExpression)       ... attempts to evaluates  a Racah expression numerically; it is supposed that the phase, weight and all angular momenta          are given numerically. A newRex::RacahExpression is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.evaluateNumerical-Tuple{W3j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.evaluateNumerical","text":"RacahAlgebra.evaluateNumerical(w3j::W3j)       ... attempts to evaluates  a Wigner 3-j symbol numerically; it is supposed that all angular momenta are given numerically.         A wa::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.evaluateNumerical-Tuple{W6j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.evaluateNumerical","text":"RacahAlgebra.evaluateNumerical(w6j::W6j)       ... attempts to evaluates  a Wigner 6-j symbol numerically; it is supposed that all angular momenta are given numerically.         A wa::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.hasAllVars-Tuple{Vector{SymEngine.Basic}, Vector{SymEngine.Basic}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.hasAllVars","text":"RacahAlgebra.hasAllVars(indexList::Array{SymEngine.Basic,1}, varList::Array{SymEngine.Basic,1})       ... returns true if all indices from indexList are in varList and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.hasNoVars-Tuple{Vector{SymEngine.Basic}, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.hasNoVars","text":"RacahAlgebra.hasNoVars(indexList::Array{SymEngine.Basic,1}, expr::SymEngine.Basic)       ... returns true if no (symbolic) index from indexList occurs in expression and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.hasNoVars-Tuple{Vector{SymEngine.Basic}, Vector{Djpq}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.hasNoVars","text":"RacahAlgebra.hasNoVars(indexList::Array{SymEngine.Basic,1}, djpqs::Array{RacahAlgebra.Djpq,1})       ... returns true if no (symbolic) index from indexList occurs in the array djpqs and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.hasNoVars-Tuple{Vector{SymEngine.Basic}, Vector{Integral}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.hasNoVars","text":"RacahAlgebra.hasNoVars(indexList::Array{SymEngine.Basic,1}, integrals::Array{RacahAlgebra.Integral,1})       ... returns true if no (symbolic) index from indexList occurs in the array integrals and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.hasNoVars-Tuple{Vector{SymEngine.Basic}, Vector{Kronecker}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.hasNoVars","text":"RacahAlgebra.hasNoVars(indexList::Array{SymEngine.Basic,1}, deltas::Array{RacahAlgebra.Kronecker,1})       ... returns true if no (symbolic) index from indexList occurs in the array deltas and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.hasNoVars-Tuple{Vector{SymEngine.Basic}, Vector{Triangle}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.hasNoVars","text":"RacahAlgebra.hasNoVars(indexList::Array{SymEngine.Basic,1}, triangles::Array{RacahAlgebra.Triangle,1})       ... returns true if no (symbolic) index from indexList occurs in the array triangles and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.hasNoVars-Tuple{Vector{SymEngine.Basic}, Vector{W3j}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.hasNoVars","text":"RacahAlgebra.hasNoVars(indexList::Array{SymEngine.Basic,1}, w3js::Array{RacahAlgebra.W3j,1})       ... returns true if no (symbolic) index from indexList occurs in the array w3js and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.hasNoVars-Tuple{Vector{SymEngine.Basic}, Vector{W6j}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.hasNoVars","text":"RacahAlgebra.hasNoVars(indexList::Array{SymEngine.Basic,1}, w6js::Array{RacahAlgebra.W6j,1})       ... returns true if no (symbolic) index from indexList occurs in the array w6js and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.hasNoVars-Tuple{Vector{SymEngine.Basic}, Vector{W9j}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.hasNoVars","text":"RacahAlgebra.hasNoVars(indexList::Array{SymEngine.Basic,1}, w9js::Array{RacahAlgebra.W9j,1})       ... returns true if no (symbolic) index from indexList occurs in the array w3js and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.hasNoVars-Tuple{Vector{SymEngine.Basic}, Vector{Ylm}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.hasNoVars","text":"RacahAlgebra.hasNoVars(indexList::Array{SymEngine.Basic,1}, ylms::Array{RacahAlgebra.Ylm,1})       ... returns true if no (symbolic) index from indexList occurs in the array ylms and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.integralRulesForOneYlm-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.integralRulesForOneYlm","text":"RacahAlgebra.integralRulesForOneYlm(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for one Wigner 3j symbol.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.obsoletePhaseVars-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.obsoletePhaseVars","text":"RacahAlgebra.obsoletePhaseVars(rex::RacahExpression)       ... determines those angular-momentum variables in the phase that should be removed by proper zero-phase terms.         A list of vars::Array{Basic,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.purifyPhase-Tuple{SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.purifyPhase","text":"RacahAlgebra.purifyPhase(phase::SymEngine.Basic)       ... purifies the phase so that all contributions of 'a' are in the range -a, a, 2a ,3a         An equivalent newphase::SymEngine.Basic is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.recursionW3j-Tuple{W3j, JAC.RacahAlgebra.AbstractRecursionW3j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.recursionW3j","text":"RacahAlgebra.recursionW3j(ww::W3j, rule::AbstractRecursionW3j)       ... applies a given recursion rules to w3j; an rexList::Array{RacahAlgebra.RacahExpression,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.removeIndex-Tuple{SymEngine.Basic, Vector{SymEngine.Basic}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.removeIndex","text":"RacahAlgebra.removeIndex(index::SymEngine.Basic, indexList::Array{SymEngine.Basic,1})       ... removes the index from the given indexList; a newList::Array{SymEngine.Basic,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.removeIndex-Tuple{Vector{SymEngine.Basic}, Vector{SymEngine.Basic}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.removeIndex","text":"RacahAlgebra.removeIndex(indices::Array{SymEngine.Basic,1}, indexList::Array{SymEngine.Basic,1})       ... removes the indices from the given indexList; a newList::Array{SymEngine.Basic,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.removeIntegral-Tuple{Integral, Vector{Integral}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.removeIntegral","text":"RacahAlgebra.removeIntegral(integral::Integral, integralList::Array{Integral,1})       ... removes the index from the given indexList; a newList::Array{Integral,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.rewriteCsq-Tuple{JAC.RacahAlgebra.Csq, String}","page":"API Racah algebra","title":"JAC.RacahAlgebra.rewriteCsq","text":"RacahAlgebra.rewriteCsq(csq::RacahAlgebra.Csq, ms::String)       ... attempts to rewrite the coupling sequence csq as Racah expressions, i.e. as (sum of) products of Wigner 3-j symbols.          A rex::RacahExpression is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.rewritePhase-Tuple{RacahExpression, Vector{SymEngine.Basic}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.rewritePhase","text":"RacahAlgebra.rewritePhase(rex::RacahExpression, zeroTerms::Array{SymEngine.Basic,1}; printout::Bool=false, from::String=\"Unspecified source\")       ... attempts to rewrite (and shorten) the phase by adding one or several 'zero' terms so that          (i) no obsolete indices appear;         (ii) the number of phase indices becomes smaller         A modified Racah expression is returned if the re-writing was successful, and nothing is changed otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.rewritePhase-Tuple{SymEngine.Basic, Vector{SymEngine.Basic}, Vector{SymEngine.Basic}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.rewritePhase","text":"RacahAlgebra.rewritePhase(phase::Basic, zeroTerms::Array{SymEngine.Basic,1}, woIndex::Array{SymEngine.Basic,1};                              printout::Bool=false, from::String=\"Unspecified source\")       ... attempts to rewrite the phase by adding one or several 'zero' terms so that it appears without the indices          in woIndex. An equivalent newPhase::Basic either 'without' or 'with' the indicated indices is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.selectRacahExpression-Tuple{Int64}","page":"API Racah algebra","title":"JAC.RacahAlgebra.selectRacahExpression","text":"RacahAlgebra.selectRacahExpression(n::Int64)       ... selects one of various pre-defined Racah expression as they often occur on the lhs of some sum rule;         this function has been implemented mainly for test purposes. A rex::RacahExpression is returned.          If n = 99, all pre-defined RacahExpression are printed to screen and nothing is returned in this         case.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.selectRacahIntegral-Tuple{Int64}","page":"API Racah algebra","title":"JAC.RacahAlgebra.selectRacahIntegral","text":"RacahAlgebra.selectRacahIntegral(n::Int64)       ... selects one of various pre-defined Racah integrals as they often occur on the lhs of some sum/integration rule;         this function has been implemented mainly for test purposes. A rex::RacahExpression is returned.          If n = 99, all pre-defined RacahExpression are printed to screen and nothing is returned in this         case.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.selectW3j-Tuple{Int64}","page":"API Racah algebra","title":"JAC.RacahAlgebra.selectW3j","text":"RacahAlgebra.selectW3j(n::Int64)       ... selects one of various pre-defined Wigner 3j symbols for which usually special values are known;         this function has been implemented mainly for test purposes. A w3j::W3j is returned.          If n = 99, all pre-defined Wigner 3j symbols are printed to screen and nothing is returned in this         case.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.selectW6j-Tuple{Int64}","page":"API Racah algebra","title":"JAC.RacahAlgebra.selectW6j","text":"RacahAlgebra.selectW6j(n::Int64)       ... selects one of various pre-defined Wigner 6j symbols for which usually special values are known; this function has been          implemented mainly for test purposes. A w6j::W6j is returned. If n = 99, all pre-defined Wigner 6j symbols are printed to          screen and nothing is returned in this case.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.selectW9j-Tuple{Int64}","page":"API Racah algebra","title":"JAC.RacahAlgebra.selectW9j","text":"RacahAlgebra.selectW9j(n::Int64)       ... selects one of various pre-defined Wigner 9j symbols for which usually special values are known;         this function has been implemented mainly for test purposes. A w9j::W9j is returned.          If n = 99, all pre-defined Wigner 9j symbols are printed to screen and nothing is returned in this         case.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.simplifyDeltas-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.simplifyDeltas","text":"RacahAlgebra.simplifyDeltas(rex::RacahExpression)       ... simplifies the all Kronecker deltas in rex; a new nrex::RacahExpression is returned, typically with less summation         indices.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.simplifyTriangles-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.simplifyTriangles","text":"RacahAlgebra.simplifyTriangles(rex::RacahExpression)       ... simplifies the all Tringle deltas in rex; these triangles can be removed if the same condition is places by one of         the Wigner symbols in rex. A new nrex::RacahExpression is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.specialValue-Tuple{W3j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.specialValue","text":"RacahAlgebra.specialValue(w3j::RacahAlgebra.W3j)       ... attempts to find a special value for the Wigner 3j symbol w3j.          A (istrue, rex)::Tuple{Bool, RacahExpression} is returned, and where istrue determined of whether a          special value is returned in rex. For istrue = false, rex has no meaning.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.specialValue-Tuple{W6j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.specialValue","text":"RacahAlgebra.specialValue(w6j::RacahAlgebra.W6j)       ... attempts to find a special value for the Wigner 6-j symbol w6j.          A (istrue, rex)::Tuple{Bool, RacahExpression} is returned, and where istrue determined of whether a          special value is returned in rex. For istrue = false, rex has no meaning.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.specialValue-Tuple{W9j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.specialValue","text":"RacahAlgebra.specialValue(w9j::RacahAlgebra.W9j)       ... attempts to find a special value for the Wigner 9-j symbol w9j.          A (istrue, rex)::Tuple{Bool, RacahExpression} is returned, and where istrue determined of whether a          special value is returned in rex. For istrue = false, rex has no meaning.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Kronecker, SymEngine.Basic, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(delta::RacahAlgebra.Kronecker, wold::Basic, wnew::Basic)       ... substitutes in triangle all occasions of wold by wnew; a newDelta::RacahAlgebra.Kronecker is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Kronecker, Vector{Pair{Symbol, Rational{Int64}}}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(delta::RacahAlgebra.Kronecker, subList::Array{Pair{Symbol,Rational{Int64}},1})       ... substitutes in delta the symbols by the corresponding rational numbers in subList; a ww:Kronecker is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{RacahExpression, Vector{Pair{Symbol, Rational{Int64}}}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(rex::RacahAlgebra.RacahExpression, subList::Array{Pair{Symbol,Rational{Int64}},1})       ... substitutes in rex the symbols by the corresponding rational numbers in subList; a ww:RacahExpression is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Triangle, Vector{Pair{Symbol, Rational{Int64}}}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(triangle::RacahAlgebra.Triangle, subList::Array{Pair{Symbol,Rational{Int64}},1})       ... substitutes in triangle the symbols by the corresponding rational numbers in subList; a ww:Triangle is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Vector{Djpq}, SymEngine.Basic, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(djpqs::Array{RacahAlgebra.Djpq,1}, wold::Basic, wnew::Basic)       ... substitutes in djpqs all occasions of wold by wnew; a newYlms::Array{RacahAlgebra.Djpq,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Vector{Integral}, SymEngine.Basic, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(integrals::Array{RacahAlgebra.Integral,1}, wold::Basic, wnew::Basic)       ... substitutes in integrals all occasions of wold by wnew; a newIntegrals::Array{RacahAlgebra.Integral,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Vector{Kronecker}, SymEngine.Basic, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(deltas::Array{RacahAlgebra.Kronecker,1}, wold::Basic, wnew::Basic)       ... substitutes in triangle all occasions of wold by wnew; a newDeltass::Array{RacahAlgebra.Kronecker,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Vector{SymEngine.Basic}, SymEngine.Basic, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(list::Array{Basic,1}, wold::Basic, wnew::Basic)       ... substitutes in list all occasions of wold by wnew; a newList::Array{Basic,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Vector{Triangle}, SymEngine.Basic, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(triangles::Array{RacahAlgebra.Triangle,1}, wold::Basic, wnew::Basic)       ... substitutes in triangle all occasions of wold by wnew; a newTriangles::Array{RacahAlgebra.Triangle,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Vector{W3j}, SymEngine.Basic, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(w3js::Array{RacahAlgebra.W3j,1}, wold::Basic, wnew::Basic)       ... substitutes in w3js all occasions of wold by wnew; a newW3js::Array{RacahAlgebra.W3j,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Vector{W6j}, SymEngine.Basic, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(w6js::Array{RacahAlgebra.W6j,1}, wold::Basic, wnew::Basic)       ... substitutes in w6js all occasions of wold by wnew; a newW6js::Array{RacahAlgebra.W6j,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Vector{W9j}, SymEngine.Basic, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(w9js::Array{RacahAlgebra.W9j,1}, wold::Basic, wnew::Basic)       ... substitutes in w9js all occasions of wold by wnew; a newW9js::Array{RacahAlgebra.W9j,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{Vector{Ylm}, SymEngine.Basic, SymEngine.Basic}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(ylms::Array{RacahAlgebra.Ylm,1}, wold::Basic, wnew::Basic)       ... substitutes in ylms all occasions of wold by wnew; a newYlms::Array{RacahAlgebra.Ylm,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{W3j, Vector{Pair{Symbol, Rational{Int64}}}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(w3j::RacahAlgebra.W3j, subList::Array{Pair{Symbol,Rational{Int64}},1})       ... substitutes in w3j the symbols by the corresponding rational numbers in subList; a ww:W3j is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.subs-Tuple{W6j, Vector{Pair{Symbol, Rational{Int64}}}}","page":"API Racah algebra","title":"JAC.RacahAlgebra.subs","text":"RacahAlgebra.subs(w6j::RacahAlgebra.W6j, subList::Array{Pair{Symbol,Rational{Int64}},1})       ... substitutes in w6j the symbols by the corresponding rational numbers in subList; a ww:W6j is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForFiveW3j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForFiveW3j","text":"RacahAlgebra.sumRulesForFiveW3j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for five Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForFourW3j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForFourW3j","text":"RacahAlgebra.sumRulesForFourW3j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for four Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForFourW6j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForFourW6j","text":"RacahAlgebra.sumRulesForFourW6j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for four Wigner 6j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForOneW3j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForOneW3j","text":"RacahAlgebra.sumRulesForOneW3j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for one Wigner 3j symbol.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForOneW6j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForOneW6j","text":"RacahAlgebra.sumRulesForOneW6j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for one Wigner 6-j symbol.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForOneW6jOneW9j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForOneW6jOneW9j","text":"RacahAlgebra.sumRulesForOneW6jOneW9j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for one Wigner 6j and one 9j symbol.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForOneW6jThreeW9j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForOneW6jThreeW9j","text":"RacahAlgebra.sumRulesForOneW6jThreeW9j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for four Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForOneW6jTwoW9j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForOneW6jTwoW9j","text":"RacahAlgebra.sumRulesForOneW6jTwoW9j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for three Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForOneW9j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForOneW9j","text":"RacahAlgebra.sumRulesForOneW9j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for one Wigner 9-j symbol.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForSixW3j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForSixW3j","text":"RacahAlgebra.sumRulesForSixW3j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for six Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForThreeW3j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForThreeW3j","text":"RacahAlgebra.sumRulesForThreeW3j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for three Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForThreeW6j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForThreeW6j","text":"RacahAlgebra.sumRulesForThreeW6j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for three Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForThreeW6jOneW9j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForThreeW6jOneW9j","text":"RacahAlgebra.sumRulesForThreeW6jOneW9j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for four Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForThreeW9j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForThreeW9j","text":"RacahAlgebra.sumRulesForThreeW9j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for three Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForTwoW3j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForTwoW3j","text":"RacahAlgebra.sumRulesForTwoW3j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for one Wigner 3j symbol.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForTwoW3jOneW6j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForTwoW3jOneW6j","text":"RacahAlgebra.sumRulesForTwoW3jOneW6j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for three Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForTwoW6j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForTwoW6j","text":"RacahAlgebra.sumRulesForTwoW6j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for one Wigner 6-j symbol.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n                                                2\n                                    ( X  Y  Z )\n            Sum(X,Y,Z)  [X,Y,Z]  {(         )}    =    [a,b,c]\n                                    ( a  b  c )\n                \n                \n                            ( a  b  X )   ( c  d  X )        1\n            Sum(X) [X]  {(         )} {(         )}  =   ---  d(p,q) d(a,d,p) d(b,c,p)\n                            ( c  d  p )   ( a  b  q )       [p]\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForTwoW6jOneW9j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForTwoW6jOneW9j","text":"RacahAlgebra.sumRulesForTwoW6jOneW9j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for three Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForTwoW6jTwoW9j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForTwoW6jTwoW9j","text":"RacahAlgebra.sumRulesForTwoW6jTwoW9j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for four Wigner 3j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.sumRulesForTwoW9j-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.sumRulesForTwoW9j","text":"RacahAlgebra.sumRulesForTwoW9j(rex::RacahAlgebra.RacahExpression)       ... attempts to find a simplification of the given Racah expression by using sum rules for two Wigner 9j symbols.          Once a simplification is found, no attempt is made to find another simplifcation for this set of rules.         A (istrue, rex)::Tuple{Bool, RacahExpression} is returned but where rex has no meaning for !istrue.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.symmetricForms-Tuple{Djpq}","page":"API Racah algebra","title":"JAC.RacahAlgebra.symmetricForms","text":"RacahAlgebra.symmetricForms(djpq::RacahAlgebra.Djpq)       ... generates a list of equivalent symmetric forms of the small rotation matrix djpq. There are 12 basic symmetric forms          for a rotation matix, including the given one. A rexList:Array{RacahExpression,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.symmetricForms-Tuple{W3j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.symmetricForms","text":"RacahAlgebra.symmetricForms(w3j::RacahAlgebra.W3j; regge::Bool=false)       ... generates a list of equivalent symmetric forms of the Wigner 3j symbol w3j. There are 12 basic symmetric forms          for a 3j-symbol, including the given one, and 72 symmetries due to Regge, including the 12 classical ones.         A rexList:Array{RacahExpression,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.symmetricForms-Tuple{W6j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.symmetricForms","text":"RacahAlgebra.symmetricForms(w6j::RacahAlgebra.W6j; regge::Bool=false)       ... generates a list of equivalent symmetric forms of the Wigner 6j symbol w6j. There are 24 basic symmetric forms          for a 6j-symbol, including the given one, and 144 symmetries due to Regge, including the 24 classical ones.         A rexList:Array{RacahExpression,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.symmetricForms-Tuple{W9j}","page":"API Racah algebra","title":"JAC.RacahAlgebra.symmetricForms","text":"RacahAlgebra.symmetricForms(w9j::RacahAlgebra.W9j; regge::Bool=false)       ... generates a list of equivalent symmetric forms of the Wigner 9-j symbol w9j. There are 72 basic symmetric forms          for a 9-j-symbol, including the given one. The keyword regge has no effect since no additional Regge symmetries          are known for the Wigner 9-j symbols. A rexList:Array{RacahExpression,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.symmetricForms-Tuple{Ylm}","page":"API Racah algebra","title":"JAC.RacahAlgebra.symmetricForms","text":"RacahAlgebra.symmetricForms(ylm::RacahAlgebra.Ylm)       ... generates a list of equivalent symmetric forms of the spherical harmonic ylm. There are 8 basic symmetric forms          for a spherical harmonic, including the given one. A rexList:Array{RacahExpression,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.testIntegralRules-Tuple{}","page":"API Racah algebra","title":"JAC.RacahAlgebra.testIntegralRules","text":"RacahAlgebra.testIntegralRules(; short::Bool=true)       ... tests the implemented integral rules by just comparing comparing the number of integrals symbols; this does not include tests on          the proper phase nor the algebraic factors of the Racah expression. The success::Bool of these tests is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.testRecursions-Tuple{}","page":"API Racah algebra","title":"JAC.RacahAlgebra.testRecursions","text":"RacahAlgebra.testRecursions(; short::Bool=true)       ... tests the implemented recursion by just comparing comparing the number of Wigner symbols; this does not include tests on          the proper phase nor the algebraic factors of the Racah expression(s). The success::Bool of these tests is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.testSpecialValuesDjpq-Tuple{}","page":"API Racah algebra","title":"JAC.RacahAlgebra.testSpecialValuesDjpq","text":"RacahAlgebra.testSpecialValuesDjpq(; short::Bool=true)       ... tests the implemented special values of the small Wigner matrices by just comparing the number of these matrices,         which must be 0 in all cases. The success::Bool of these tests is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.testSpecialValuesW3j-Tuple{}","page":"API Racah algebra","title":"JAC.RacahAlgebra.testSpecialValuesW3j","text":"RacahAlgebra.testSpecialValuesW3j(; short::Bool=true)       ... tests the implemented special values of the Wigner 3j symbols by just comparing comparing the number of Wigner symbols,         which must be 0 in all cases. The success::Bool of these tests is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.testSpecialValuesW6j-Tuple{}","page":"API Racah algebra","title":"JAC.RacahAlgebra.testSpecialValuesW6j","text":"RacahAlgebra.testSpecialValuesW6j(; short::Bool=true)       ... tests the implemented special values of the Wigner 6j symbols by just comparing comparing the number of Wigner symbols,         which must be 0 in all cases. The success::Bool of these tests is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.testSpecialValuesW9j-Tuple{}","page":"API Racah algebra","title":"JAC.RacahAlgebra.testSpecialValuesW9j","text":"RacahAlgebra.testSpecialValuesW9j(; short::Bool=true)       ... tests the implemented special values of the Wigner 9j symbols by just comparing comparing the number of Wigner symbols,         which must be 0 in all cases. The success::Bool of these tests is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.testSpecialValuesYlm-Tuple{}","page":"API Racah algebra","title":"JAC.RacahAlgebra.testSpecialValuesYlm","text":"RacahAlgebra.testSpecialValuesYlm(; short::Bool=true)       ... tests the implemented special values of the spherical harmonics by just comparing the number of spherical harmonics,         which must be 0 in all cases. The success::Bool of these tests is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.testSumRules-Tuple{}","page":"API Racah algebra","title":"JAC.RacahAlgebra.testSumRules","text":"RacahAlgebra.testSumRules(; short::Bool=true)       ... tests the implemented sum rules by just comparing comparing the number of Wigner symbols; this does not include tests on          the proper phase nor the algebraic factors of the Racah expression. The success::Bool of these tests is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-racah.html#JAC.RacahAlgebra.zeroPhases-Tuple{RacahExpression}","page":"API Racah algebra","title":"JAC.RacahAlgebra.zeroPhases","text":"RacahAlgebra.zeroPhases(rex::RacahAlgebra.RacahExpression)       ... determines a number of phase terms that do not modify the overall phase of the given Racah expression but may         allow to elimate certain variables as required for sum-rule evaluation; a phaseList::Basic[] is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#Atomic-form-factors","page":"API Atomic properties","title":"Atomic form factors","text":"","category":"section"},{"location":"api-properties.html","page":"API Atomic properties","title":"API Atomic properties","text":"Modules = [FormFactor]\nOrder   = [:type, :function]","category":"page"},{"location":"api-properties.html#JAC.FormFactor.Outcome","page":"API Atomic properties","title":"JAC.FormFactor.Outcome","text":"struct  FormFactor.Outcome  ... defines a type to keep the outcome of a form-factor computation, such as the standard form factor                                     as well other results.\n\n+ level                     ::Level              ... Atomic level to which the outcome refers to.\n+ qValues                   ::Array{Float64,1}   ... momentum transfer |q|.\n+ standardFs                ::Array{Float64,1}   ... standard atomic form factor F(q) for an (assumed) spherical charge distr.\n+ modifiedFs                ::Array{Float64,1}   ... modified atomic form factor F(q) for such a charge distribution.\n\n\n\n\n\n","category":"type"},{"location":"api-properties.html#JAC.FormFactor.Outcome-Tuple{}","page":"API Atomic properties","title":"JAC.FormFactor.Outcome","text":"FormFactor.Outcome()       ... constructor for an empty instance of FormFactor.Outcome for the computation of atomic form factors.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.FormFactor.Settings","page":"API Atomic properties","title":"JAC.FormFactor.Settings","text":"struct  FormFactor.Settings  <:  AbstractPropertySettings  ... defines a type for the details and parameters of computing alpha-variation parameters.\n\n+ qList                    ::Array{Float64,1} ... List of q-values in [a.u.]\n+ printBefore              ::Bool             ... True if a list of selected levels is printed before the  \n                                                    actual computations start. \n+ levelSelection           ::LevelSelection   ... Specifies the selected levels, if any.\n\n\n\n\n\n","category":"type"},{"location":"api-properties.html#JAC.FormFactor.Settings-Tuple{}","page":"API Atomic properties","title":"JAC.FormFactor.Settings","text":"FormFactor.Settings()  ... constructor for an empty instance of FormFactor.Settings for the computation of atomic form factors.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.FormFactor.amplitude-Tuple{Float64, Level, Level, JAC.Radial.Grid}","page":"API Atomic properties","title":"JAC.FormFactor.amplitude","text":"FormFactor.amplitude(q::Float64, finalLevel::Level, initialLevel::Level, grid::Radial.Grid; display::Bool=false)       ... to compute the momentum transfer amplitude  <(alphaf Jf, kappa) Ji || T^(1) || alphai J_i>  for the given          final and initial level. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.FormFactor.computeAmplitudesProperties-Tuple{JAC.FormFactor.Outcome, Model, JAC.Radial.Grid, JAC.FormFactor.Settings}","page":"API Atomic properties","title":"JAC.FormFactor.computeAmplitudesProperties","text":"FormFactor.computeAmplitudesProperties(outcome::FormFactor.Outcome, nm::Nuclear.Model, grid::Radial.Grid, settings::FormFactor.Settings)       ... to compute all form factors, etc. for the given outcome; a newOutcome::FormFactor.Outcome is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.FormFactor.computeOutcomes-Tuple{Multiplet, Model, JAC.Radial.Grid, JAC.FormFactor.Settings}","page":"API Atomic properties","title":"JAC.FormFactor.computeOutcomes","text":"FormFactor.computeOutcomes(multiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid, settings::FormFactor.Settings; output=true)      ... to compute (as selected) the alpha-variation parameters for the levels of the given multiplet and as specified          by the given settings. The results are printed in neat tables to screen but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.FormFactor.determineOutcomes-Tuple{Multiplet, JAC.FormFactor.Settings}","page":"API Atomic properties","title":"JAC.FormFactor.determineOutcomes","text":"FormFactor.determineOutcomes(multiplet::Multiplet, settings::FormFactor.Settings)       ... to determine a list of Outcomes's for the computation of the alpha-variation parameters for the given          multiplet. It takes into account the particular selections and settings. An Array{FormFactor.Outcome,1}          is returned. Apart from the level specification, all physical properties are set to zero during the          initialization process.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.FormFactor.displayOutcomes-Tuple{IO, Vector{JAC.FormFactor.Outcome}}","page":"API Atomic properties","title":"JAC.FormFactor.displayOutcomes","text":"FormFactor.displayOutcomes(stream::IO, outcomes::Array{FormFactor.Outcome,1})       ... to display a list of levels that have been selected for the computations. A small neat table of all          selected levels and their energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.FormFactor.displayResults-Tuple{IO, Vector{JAC.FormFactor.Outcome}}","page":"API Atomic properties","title":"JAC.FormFactor.displayResults","text":"FormFactor.displayResults(stream::IO, outcomes::Array{FormFactor.Outcome,1})       ... to display the energies, M_ms and F-parameters, etc. for the selected levels. A neat table is printed but          nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.FormFactor.modifiedF-Tuple{Float64, Level, JAC.Radial.Grid}","page":"API Atomic properties","title":"JAC.FormFactor.modifiedF","text":"FormFactor.modifiedF(q::Float64, level::Level, grid::Radial.Grid)       ... to compute the (real) Fourier transform of the (spherically-symmetric) charge distribution but including a correction         due to the local (DFS) potential, relative to the rest mass of the electron. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.FormFactor.standardF-Tuple{Float64, Level, JAC.Radial.Grid}","page":"API Atomic properties","title":"JAC.FormFactor.standardF","text":"FormFactor.standardF(q::Float64, level::Level, grid::Radial.Grid)           ... to compute the (real) Fourier transform of the (spherically-symmetric) charge distribution. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#Hyperfine-coefficients-and-energy-splittings","page":"API Atomic properties","title":"Hyperfine coefficients and energy splittings","text":"","category":"section"},{"location":"api-properties.html","page":"API Atomic properties","title":"API Atomic properties","text":"Modules = [Hfs]\nOrder   = [:type, :function]","category":"page"},{"location":"api-properties.html#JAC.Hfs.IJF_Basis","page":"API Atomic properties","title":"JAC.Hfs.IJF_Basis","text":"struct  Hfs.IJF_Basis  ... defines a type for a IJF-coupled basis.\n\n+ vectors   ::Array{IJF_Vector,1}   ... List of IJF_Vectors that form the basis.\n+ basisJ    ::Basis                 ... Electronic basis that allows access to the electronic orbitals and CSF basis.\n\n\n\n\n\n","category":"type"},{"location":"api-properties.html#JAC.Hfs.IJF_Basis-Tuple{}","page":"API Atomic properties","title":"JAC.Hfs.IJF_Basis","text":"Hfs.IJF_Basis()  ... constructor for an empty instance of IJF_Basis.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.IJF_Level","page":"API Atomic properties","title":"JAC.Hfs.IJF_Level","text":"struct  Hfs.IJF_Level  ... defines a type for a IJF-coupled level.\n\n+ I              ::AngularJ64       ... Nuclear spin I.\n+ F              ::AngularJ64       ... Total angular momentum F.\n+ M              ::AngularM64       ... Total projection M, only defined if a particular sublevel is referred to.\n+ parity         ::Parity           ... Parity of the level which corresponds to the electronic system.\n+ energy         ::Float64          ... energy\n+ basis          ::IJF_Basis        ... basis for this level\n+ mc             ::Vector{Float64}  ... Vector of mixing coefficients w.r.t basis.\n\n\n\n\n\n","category":"type"},{"location":"api-properties.html#JAC.Hfs.IJF_Level-Tuple{}","page":"API Atomic properties","title":"JAC.Hfs.IJF_Level","text":"Hfs.IJF_Level()  ... constructor for an empty instance of IJF_Level.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.IJF_Multiplet","page":"API Atomic properties","title":"JAC.Hfs.IJF_Multiplet","text":"struct  Hfs.IJF_Multiplet  ... defines a type for a multiplet of IJF-coupled levels.\n\n+ name     ::String                ... A name associated to the multiplet.\n+ levelFs  ::Array{IJF_Level,1}    ... List of IJF-coupled levels.\n\n\n\n\n\n","category":"type"},{"location":"api-properties.html#JAC.Hfs.IJF_Multiplet-Tuple{}","page":"API Atomic properties","title":"JAC.Hfs.IJF_Multiplet","text":"Hfs.IJF_Multiplet()  ... constructor for an empty instance of Hfs.IJF_Multiplet.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.IJF_Vector","page":"API Atomic properties","title":"JAC.Hfs.IJF_Vector","text":"struct  Hfs.IJF_Vector  ... defines a type for a IJF-coupled basis vector, here based on an ASF.\n\n+ I        ::AngularJ64   ... Nuclear spin I.\n+ F        ::AngularJ64   ... Total angular momentum F\n+ levelJ   ::Level        ... Atomic level with well-defined total (electronic) angular momentum J\n\n\n\n\n\n","category":"type"},{"location":"api-properties.html#JAC.Hfs.IJF_Vector-Tuple{}","page":"API Atomic properties","title":"JAC.Hfs.IJF_Vector","text":"Hfs.IJF_Vector()  ... constructor for an empty instance of IJF_Vector.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.InteractionMatrix","page":"API Atomic properties","title":"JAC.Hfs.InteractionMatrix","text":"struct  Hfs.InteractionMatrix  ... defines a type for storing the T^1 and T^2 interaction matrices for a given basis.\n\n+ calcT1   ::Bool               ... true, if the matrixT1 has been calculated and false otherwise.\n+ calcT2   ::Bool               ... true, if the matrixT2 has been calculated and false otherwise.\n+ matrixT1 ::Array{Float64,2}   ... T1 interaction matrix\n+ matrixT2 ::Array{Float64,2}   ... T2 interaction matrix\n\n\n\n\n\n","category":"type"},{"location":"api-properties.html#JAC.Hfs.InteractionMatrix-Tuple{}","page":"API Atomic properties","title":"JAC.Hfs.InteractionMatrix","text":"Hfs.InteractionMatrix()  ... constructor for an empty instance of InteractionMatrix.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.Outcome","page":"API Atomic properties","title":"JAC.Hfs.Outcome","text":"struct  Hfs.Outcome       ... defines a type to keep the outcome of a HFS computation, such as the HFS A and B coefficients as well          other results.\n\n+ Jlevel                    ::Level            ... Atomic level to which the outcome refers to.\n+ AIoverMu                  ::Float64          ... HFS A * I / mu value.\n+ BoverQ                    ::Float64          ... HFS B / Q value\n+ amplitudeT1               ::Complex{Float64} ... T1 amplitude\n+ amplitudeT2               ::Complex{Float64} ... T2 amplitude\n+ nuclearI                  ::AngularJ64       ... nuclear spin\n+ hfsMultiplet              ::IJF_Multiplet    ... Multiplet of IJF levels as associated with the JLevel.\n\n\n\n\n\n","category":"type"},{"location":"api-properties.html#JAC.Hfs.Outcome-Tuple{}","page":"API Atomic properties","title":"JAC.Hfs.Outcome","text":"Hfs.Outcome()  ... constructor for an empty instance of Hfs.Outcome for the computation of HFS properties.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.Settings","page":"API Atomic properties","title":"JAC.Hfs.Settings","text":"struct  Settings  <:  AbstractPropertySettings  ... defines a type for the details and parameters of computing HFS A and B coefficients.\n\n+ calcT1                    ::Bool             ... True if T1-amplitudes (HFS A values) need to be calculated, and false otherwise.\n+ calcT2                    ::Bool             ... True if T2-amplitudes (HFS B values) need to be calculated, and false otherwise.\n+ calcNondiagonal           ::Bool             \n    ... True if also (non-)diagonal hyperfine amplitudes are to be calculated and printed, and false otherwise.\n+ calcIJFexpansion          ::Bool             \n    ... True if the selected atomic levels are to be represented in a IJF-coupled basis, and false otherwise.\n+ printBefore               ::Bool             ... True if a list of selected levels is printed before the actual computations start. \n+ levelSelection            ::LevelSelection   ... Specifies the selected levels, if any.\n\n\n\n\n\n","category":"type"},{"location":"api-properties.html#JAC.Hfs.Settings-Tuple{}","page":"API Atomic properties","title":"JAC.Hfs.Settings","text":"Hfs.Settings(; calcT1::Bool=true, calcT2::Bool=false, calcNondiagonal::Bool=false, calcIJFexpansion::Bool=false,                      printBefore::Bool=false, levelSelection::LevelSelection=LevelSelection())      ... keyword constructor to overwrite selected value of Einstein line computations.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Basics.sortByEnergy-Tuple{JAC.Hfs.IJF_Multiplet}","page":"API Atomic properties","title":"JAC.Basics.sortByEnergy","text":"Basics.sortByEnergy(multiplet::Hfs.IJF_Multiplet)       ... to sort all hyperfine levels in the multiplet into a sequence of increasing energy; a (new) multiplet::Hfs.IJF_Multiplet          is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Basics.tabulate-Tuple{String, JAC.Hfs.IJF_Multiplet}","page":"API Atomic properties","title":"JAC.Basics.tabulate","text":"Basics.tabulate(sa::String, multiplet::Hfs.IJF_Multiplet; stream::IO=stdout)       ... tabulates the energies from the multiplet due to different criteria.\n\n(\"multiplet: energies\", multiplet::Hfs.IJF_Multiplet; stream::IO=stdout)     ... to tabulate the energies of all hyperfine levels of the given multiplet into a neat format; nothing is returned.\n(\"multiplet: energy of each level relative to lowest level\", multiplet::Hfs.IJF_Multiplet; stream::IO=stdout)     ... to tabulate the energy splitting of all levels with regard to the lowest level of the given multiplet into        a neat format; nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.amplitude-Tuple{String, Level, Level, JAC.Radial.Grid}","page":"API Atomic properties","title":"JAC.Hfs.amplitude","text":"Hfs.amplitude(kind::String, rLevel::Level, sLevel::Level, grid::Radial.Grid; printout::Bool=true)      ... to compute either the  T^(1) or T^(2) hyperfine amplitude <alphar Jr || T^(n)) || alphas Js>           for a given pair of levels. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.computeAmplitudesProperties-Tuple{JAC.Hfs.Outcome, Model, JAC.Radial.Grid, JAC.Hfs.Settings, JAC.Hfs.InteractionMatrix}","page":"API Atomic properties","title":"JAC.Hfs.computeAmplitudesProperties","text":"`Hfs.computeAmplitudesProperties(outcome::Hfs.Outcome, nm::Nuclear.Model, grid::Radial.Grid, settings::Hfs.Settings, im::Hfs.InteractionMatrix)      ... to compute all amplitudes and properties of for a given level; an outcome::Hfs.Outcome is returned for which the          amplitudes and properties are now evaluated explicitly.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.computeHyperfineMultiplet-Tuple{Level, Model, JAC.Radial.Grid}","page":"API Atomic properties","title":"JAC.Hfs.computeHyperfineMultiplet","text":"Hfs.computeHyperfineMultiplet(level::Level, nm::Nuclear.Model, grid::Radial.Grid)       ... to compute a hyperfine multiplet, i.e. a representation of hyperfine levels within a hyperfine-coupled basis as defined by the         given (electronic) level; a hfsMultiplet::IJF_Multiplet is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.computeHyperfineMultiplet-Tuple{Multiplet, Model, JAC.Radial.Grid, JAC.Hfs.Settings}","page":"API Atomic properties","title":"JAC.Hfs.computeHyperfineMultiplet","text":"Hfs.computeHyperfineMultiplet(multiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid, settings::Hfs.Settings; output=true)       ... to compute a hyperfine multiplet, i.e. a representation of hyperfine levels within a hyperfine-coupled basis as defined by the         given (electronic) multiplet; a hfsMultiplet::IJF_Multiplet is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.computeHyperfineRepresentation-Tuple{JAC.Hfs.IJF_Basis, Model, JAC.Radial.Grid}","page":"API Atomic properties","title":"JAC.Hfs.computeHyperfineRepresentation","text":"Hfs.computeHyperfineRepresentation(hfsBasis::IJF_Basis, nm::Nuclear.Model, grid::Radial.Grid)       ... to set-up and diagonalized the Hamiltonian matrix of H^(DFB) + H^(hfs) within the atomic hyperfine (IJF-coupled) basis;         a hfsMultiplet::IJF_Multiplet is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.computeInteractionAmplitudeM-Tuple{EmMultipole, JAC.Nuclear.Isomer, JAC.Nuclear.Isomer}","page":"API Atomic properties","title":"JAC.Hfs.computeInteractionAmplitudeM","text":"Hfs.computeInteractionAmplitudeM(mp::EmMultipole, leftIsomer::Nuclear.Isomer, rightIsomer::Nuclear.Isomer)      ... to compute the hyperfine interaction amplitude (<leftIsomer || M^(mp)) || rightIsomer>) for the interaction of two         nuclear levels; this ME is geometrically fixed if the left and right isomer are the same, and it depends         on the nuclear ME otherwise. An amplitude::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.computeInteractionAmplitudeT-Tuple{EmMultipole, Level, Any, JAC.Radial.Grid}","page":"API Atomic properties","title":"JAC.Hfs.computeInteractionAmplitudeT","text":"Hfs.computeInteractionAmplitudeT(mp::EmMultipole, aLevel::Level, bLevel, grid::Radial.Grid)      ... to compute the T^(mp) interaction matrices for the given basis, i.e. (<aLevel || T^(mp) || bLevel>).         Both levels must refer to the same basis. A me::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.computeInteractionMatrix-Tuple{Basis, JAC.Radial.Grid, JAC.Hfs.Settings}","page":"API Atomic properties","title":"JAC.Hfs.computeInteractionMatrix","text":"Hfs.computeInteractionMatrix(basis::Basis, grid::Radial.Grid, settings::Hfs.Settings)      ... to compute the T^1 and/or T^2 interaction matrices for the given basis, i.e. (<csfr || T^(n)) || csfs>).         An im::Hfs.InteractionMatrix is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.computeModifiedEinsteinRates-Tuple{JAC.Hfs.Outcome, JAC.Hfs.Outcome, Vector{EmMultipole}, JAC.Basics.EmGauge, JAC.Radial.Grid}","page":"API Atomic properties","title":"JAC.Hfs.computeModifiedEinsteinRates","text":"Hfs.computeModifiedEinsteinRates(upperOutcome::Outcome, lowerOutcome::Outcome, multipoles::Array{EmMultipole,1}, gauge::EmGauge,                                   grid::Radial.Grid)       ... to compute and tabulate the modified Einstein amplitudes and rates for the hyperfine-resolved          transitions between the upper and lower outcome. The procedures assumes that the two outcomes provide         a proper IJF expansion (multiplet) of the hyperfine levels of interest.         A neat table is printed but nothing is returned otherwise\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.computeOutcomes-Tuple{Multiplet, Model, JAC.Radial.Grid, JAC.Hfs.Settings}","page":"API Atomic properties","title":"JAC.Hfs.computeOutcomes","text":"Hfs.computeOutcomes(multiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid, settings::Hfs.Settings; output=true)       ... to compute (as selected) the HFS A and B parameters as well as hyperfine energy splittings for the levels          of the given multiplet and as specified by the given settings. The results are printed in neat tables to          screen and, if requested, an arrays{Hfs.Outcome,1} with all the results are returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.defineHyperfineBasis-Tuple{Level, Model}","page":"API Atomic properties","title":"JAC.Hfs.defineHyperfineBasis","text":"Hfs.defineHyperfineBasis(level::Level, nm::Nuclear.Model)       ... to define/set-up an atomic hyperfine (IJF-coupled) basis for the given electronic level;          a hfsBasis::IJF_Basis is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.defineHyperfineBasis-Tuple{Multiplet, Model}","page":"API Atomic properties","title":"JAC.Hfs.defineHyperfineBasis","text":"Hfs.defineHyperfineBasis(multiplet::Multiplet, nm::Nuclear.Model)       ... to define/set-up an atomic hyperfine (IJF-coupled) basis for the given electronic multipet;          a hfsBasis::IJF_Basis is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.determineOutcomes-Tuple{Multiplet, JAC.Hfs.Settings}","page":"API Atomic properties","title":"JAC.Hfs.determineOutcomes","text":"Hfs.determineOutcomes(multiplet::Multiplet, settings::Hfs.Settings)       ... to determine a list of Outcomes's for the computation of HFS A- and B-parameters for the given multiplet.          It takes into account the particular selections and settings. An Array{Hfs.Outcome,1} is returned. Apart from the          level specification, all physical properties are set to zero during the initialization process.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.displayNondiagonal-Tuple{IO, Multiplet, JAC.Radial.Grid, JAC.Hfs.Settings}","page":"API Atomic properties","title":"JAC.Hfs.displayNondiagonal","text":"Hfs.displayNondiagonal(stream::IO, multiplet::Multiplet, grid::Radial.Grid, settings::Hfs.Settings)       ... to compute and display all non-diagonal hyperfine amplitudes for the selected levels. A small neat table of          all (pairwise) hyperfine amplitudes is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.displayOutcomes-Tuple{Vector{JAC.Hfs.Outcome}}","page":"API Atomic properties","title":"JAC.Hfs.displayOutcomes","text":"Hfs.displayOutcomes(outcomes::Array{Hfs.Outcome,1})       ... to display a list of levels that have been selected for the computations A small neat table of all          selected levels and their energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.Hfs.displayResults-Tuple{IO, Vector{JAC.Hfs.Outcome}, Model, JAC.Hfs.Settings}","page":"API Atomic properties","title":"JAC.Hfs.displayResults","text":"Hfs.displayResults(stream::IO, outcomes::Array{Hfs.Outcome,1}, nm::Nuclear.Model, settings::Hfs.Settings)       ... to display the energies, A- and B-values, Delta E_F energy shifts, etc. for the selected levels. All nuclear          parameters are taken from the nuclear model. A neat table is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#Isotope-shifts","page":"API Atomic properties","title":"Isotope shifts","text":"","category":"section"},{"location":"api-properties.html","page":"API Atomic properties","title":"API Atomic properties","text":"Modules = [IsotopeShift]\nOrder   = [:type, :function]","category":"page"},{"location":"api-properties.html#JAC.IsotopeShift.Outcome","page":"API Atomic properties","title":"JAC.IsotopeShift.Outcome","text":"struct  IsotopeShift.Outcome       ... defines a type to keep the outcome of a isotope-shift computation, such as the K and F parameters as well other          results.\n\n+ level                     ::Level              ... Atomic level to which the outcome refers to.\n+ Knms                      ::Float64            ... K_nms parameter\n+ Ksms                      ::Float64            ... K_sms parameter\n+ Fme                       ::Float64            ... F parameter from matrix element.\n+ Fdensity                  ::Float64            ... F parameter from density.\n+ Xboson                    ::Float64            ... X boson-field shift constant.\n+ amplitudeKnms             ::Complex{Float64}   ... K_nms amplitude\n+ amplitudeKsmsA            ::Complex{Float64}   ... K_sms,A amplitude\n+ amplitudeKsmsB            ::Complex{Float64}   ... K_sms,B amplitude\n+ amplitudeKsmsC            ::Complex{Float64}   ... K_sms,C amplitude\n\n\n\n\n\n","category":"type"},{"location":"api-properties.html#JAC.IsotopeShift.Outcome-Tuple{}","page":"API Atomic properties","title":"JAC.IsotopeShift.Outcome","text":"IsotopeShift.Outcome()  ... constructor for an empty instance of Hfs.Outcome for the computation of isotope-shift properties.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.IsotopeShift.Settings","page":"API Atomic properties","title":"JAC.IsotopeShift.Settings","text":"struct  IsotopeShift.Settings  <:  AbstractPropertySettings       ... defines a type for the details and parameters of computing isotope-shift M and F parameters.\n\n+ calcNMS                  ::Bool             ... True if mass-shift parameters M_nmn need to be calculated, and false otherwise.\n+ calcSMS                  ::Bool             ... True if mass-shift parameters M_sms need to be calculated, and false otherwise.\n+ calcF                    ::Bool             ... True if the field-shift parameter need to be calculated, and false otherwise.\n+ calcBoson                ::Bool             ... True if the boson-field shift parameter need to be calculated, and false otherwise.\n+ printBefore              ::Bool             ... True if a list of selected levels is printed before the actual computations start. \n+ bosonMass                ::Float64          ... mass of the scalar boson [e_electron].\n+ levelSelection           ::LevelSelection   ... Specifies the selected levels, if any.\n\n\n\n\n\n","category":"type"},{"location":"api-properties.html#JAC.IsotopeShift.Settings-Tuple{}","page":"API Atomic properties","title":"JAC.IsotopeShift.Settings","text":"IsotopeShift.Settings(; calcNMS::Bool=true, calcSMS::Bool=false, calcF::Bool=false, calcBoson::Bool=false,                              printBefore::Bool=true, bosonMass::Float64=0., levelSelection::LevelSelection=LevelSelection())      ... keyword constructor to overwrite selected value of isoshift computations.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.IsotopeShift.amplitude-Tuple{String, Level, Level, Model, JAC.Radial.Grid}","page":"API Atomic properties","title":"JAC.IsotopeShift.amplitude","text":"IsotopeShift.amplitude(kind::String, rLevel::Level, sLevel::Level, nm::Nuclear.Model, grid::Radial.Grid)      ... to compute either the  H^(NMS),  H^(SMS,A),  H^(SMS,B) or  H^(SMS,C) normal and specific mass-shift amplitudes         <alphar Jr || H^(A)) || alphas Js>  for a given pair of levels. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.IsotopeShift.amplitude-Tuple{String, Level, Level, Vector{Float64}, JAC.Radial.Grid}","page":"API Atomic properties","title":"JAC.IsotopeShift.amplitude","text":"IsotopeShift.amplitude(kind::String, rLevel::Level, sLevel::Level, potential::Array{Float64,1}, grid::Radial.Grid)      ... to compute the H^(field-shift) field-shift amplitude  <alphar Jr || H^(field-shift) || alphas Js> or the         H^(boson-field) shift amplitude  <alphar Jr || H^(boson-field) || alphas Js>  for a given pair of levels.         The potential has to provide delta V^(nuc) for the field-shift amplitudes and the effective potential for the         boson-field shift. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.IsotopeShift.computeAmplitudesProperties-Tuple{JAC.IsotopeShift.Outcome, Model, JAC.Radial.Grid, JAC.IsotopeShift.Settings}","page":"API Atomic properties","title":"JAC.IsotopeShift.computeAmplitudesProperties","text":"`IsotopeShift.computeAmplitudesProperties(outcome::IsotopeShift.Outcome, nm::Nuclear.Model, grid::Radial.Grid,                                              settings::IsotopeShift.Settings)      ... to compute all amplitudes and properties for a given level; an outcome::IsotopeShift.Outcome is returned for          which the amplitudes and properties are now evaluated explicitly.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.IsotopeShift.computeOutcomes-Tuple{Multiplet, Model, JAC.Radial.Grid, JAC.IsotopeShift.Settings}","page":"API Atomic properties","title":"JAC.IsotopeShift.computeOutcomes","text":"IsotopeShift.computeOutcomes(multiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid, settings::IsotopeShift.Settings; output=true)      ... to compute (as selected) the isotope-shift M and F parameters for the levels of the given multiplet and as          specified by the given settings. The results are printed in neat tables to screen but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.IsotopeShift.determineOutcomes-Tuple{Multiplet, JAC.IsotopeShift.Settings}","page":"API Atomic properties","title":"JAC.IsotopeShift.determineOutcomes","text":"IsotopeShift.determineOutcomes(multiplet::Multiplet, settings::IsotopeShift.Settings)       ... to determine a list of Outcomes's for the computation of the isotope-shift M and F parameters for the given multiplet.          It takes into account the particular selections and settings. An Array{IsotopeShift.Outcome,1} is returned. Apart from          the level specification, all physical properties are set to zero during the initialization process.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.IsotopeShift.displayOutcomes-Tuple{Vector{JAC.IsotopeShift.Outcome}}","page":"API Atomic properties","title":"JAC.IsotopeShift.displayOutcomes","text":"IsotopeShift.displayOutcomes(outcomes::Array{IsotopeShift.Outcome,1})       ... to display a list of levels that have been selected for the computations. A small neat table of all          selected levels and their energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-properties.html#JAC.IsotopeShift.displayResults-Tuple{IO, Vector{JAC.IsotopeShift.Outcome}, JAC.IsotopeShift.Settings}","page":"API Atomic properties","title":"JAC.IsotopeShift.displayResults","text":"IsotopeShift.displayResults(stream::IO, outcomes::Array{Hfs.Outcome,1}, settings::IsotopeShift.Settings)       ... to display the energies, M_ms and F-parameters, etc. for the selected levels. A neat table is printed but nothing          is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference.html","page":"Bibliography to JAC","title":"Bibliography to JAC","text":"For reference to (using) this code, please, use the Computer Physics Communications publication on JAC:","category":"page"},{"location":"reference.html","page":"Bibliography to JAC","title":"Bibliography to JAC","text":"S. Fritzsche: A fresh computational approach to atomic structures, processes and cascades     Computer Physics Communications 240, 1 (2019)\nG. Gaigalas & S. Fritzsche: Angular coefficients for symmetry-adapted configuration states in jj-coupling.    Comp. Phys. Commun. 267, 108086 (2021)\nS. Fritzsche, P. Palmeri & S. Schippers: Atomic cascade computations. Symmetry 13, 520 (2021)\nS. Fritzsche: Symbolic evaluation of expressions from Racah’s algebra. Symmetry 13, 1558 (2021)\nS. Fritzsche & A. Surzhykov: Approximate atomic Green functions. Molecules 26, 2660 (2021)\nS. Fritzsche: Dielectronic recombination strengths and plasma rate coefficients of multiply-charged ions.    A&A 656, A163 (2021)\nS. Fritzsche: Level structure and properties of open f-shell elements. Atoms 10, 7 (2022)\nS. Fritzsche: Photon emission from hollow ions near surfaces. Atoms 10, 37 (2022)\nS. Fritzsche, B. Böning: Strong-field ionization amplitudes for atomic many-electron targets. Atoms 10, 70 (2022)\nS. Fritzsche: Application of symmetry-adapted atomic amplitudes. Atoms 10, 127 (2022)\nS. Fritzsche, A.V. Maiorova & Z.W. Wu: Radiative recombination plasma rate coefficients of multiply-charged ions.    Atoms 11, 50 (2023)\nS. Fritzsche, L.G. Jiao, Y.C. Wang & J.E. Sienkiewicz; Collision strengths of astrophysical interest for multiply charged ions.    Atoms 11, 80 (2023)\nS. Fritzsche, A.K. Sahoo, L.Sharma, Z.W. Wu & S. Schippers; Merits of atomic cascade computations.    European Physical Journal D 78, 75 (2024)\nA.K. Sahoo, S. Fritzsche & L.Sharma; Computation of effective collision strengths for plasma applications using JAC.    European Physical Journal Plus 139, 986 (2024)\nS. Fritzsche, H.K. Huang, Z.K. Huang, S. Schippers, W.Q. Wen and Z.W. Wu; Dielectronic recombination into high-n Rydberg shells.    European Physical Journal D 79, 22 (2025)\nS. Fritzsche; Atomic input for modeling ionic mixtures in astrophysical plasma.    European Physical Journal A 61, 63 (2025)","category":"page"},{"location":"reference.html","page":"Bibliography to JAC","title":"Bibliography to JAC","text":"See also citations.bib for the relevant references(s).","category":"page"},{"location":"getting-involved.html","page":"Getting involved","title":"Getting involved","text":"The scope of JAC is much wider than what we can (and plan to) implement ourselves here in Jena.  With making JAC an official Julia package (at Github), we wish to encourage the users to fork the code and to  make and announce improvements, to report failures, bugs, etc. Non-trivial changes to the code can be made available  via pull requests, i.e. by submitting code for review (by us and other users), and with the goal to merge these advancements with the master code. However, since JAC is still a physics code, this merging may need some time to enable us to understand and test for side-effects upon other parts of the code.","category":"page"},{"location":"getting-involved.html","page":"Getting involved","title":"Getting involved","text":"In particular, we like to encourage contributions from the atomic physics community to contribute to the code, provided that the overall style of the package is maintained and if consensus exists how to add new features to the code. The goal  should be to avoid duplication and inhomogeneity across the package as well as to implement (too) specific features  that will cause issues in the future. External support by developers may include incremental improvements as well as  multiple approaches for algorithms and modules in order to provide well-tested alternatives, for instance, if some  particular approach does not work properly in all applications. Moreover, emphasis will be placed first on all those  applications that receive enough attention by the community. –- In contrast, we shall not support developments that  are highly sophisticated or detrimental to a long-term maintenance of the code. ","category":"page"},{"location":"getting-involved.html","page":"Getting involved","title":"Getting involved","text":"Although a good number of tests and applications have been performed by using JAC, this code still in an early stage,  and no code is error free. We shall therefore appreciate reports from the users if problems are encountered or,  more helpful, if solutions are suggesteg and/or provided. One of the simplest way to start contributing to JAC is  writing some new demos (Pluto notebooks), in addition to those provided above, in order to navigate others to the task of a new user. Also, new graphical user interface and plotting features on different outcomes of atomic computations will be very  helpful for the community. A few further suggestions for extending and improving JAC can be found in section 1.7 in the  User Guide, Compendium & Theoretical Background to JAC.","category":"page"},{"location":"api-empirical.html#Empirical-computations","page":"API Empirical computations","title":"Empirical computations","text":"","category":"section"},{"location":"api-empirical.html","page":"API Empirical computations","title":"API Empirical computations","text":"Modules = [Empirical]\nOrder   = [:type, :function]","category":"page"},{"location":"api-empirical.html#JAC.Empirical.Computation","page":"API Empirical computations","title":"JAC.Empirical.Computation","text":"struct  Empirical.Computation       ... defines a type for an empirical computation of various ionization and charge exchange processes.\n\n+ name                   ::String                           ... A name associated to the computation.\n+ nuclearModel           ::Nuclear.Model                    ... Model, charge and parameters of the nucleus.\n+ grid                   ::Radial.Grid                      ... The radial grid to be used for the computation.\n+ configs                ::Array{Configuration,1}           ... A list of non-relativistic configurations.\n+ settings               ::Basics.AbstractEmpiricalSettings ... Provides the settings for the selected computations.\n\n\n\n\n\n","category":"type"},{"location":"api-empirical.html#JAC.Empirical.Computation-Tuple{JAC.Empirical.Computation}","page":"API Empirical computations","title":"JAC.Empirical.Computation","text":"Empirical.Computation(comp::Empirical.Computation;\n\nname=..,                nuclearModel=..,            grid=..,                    configs=..,                   settings=..,  \nprintout::Bool=false)\n                \n... constructor for modifying the given Empirical.Computation by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-empirical.html#JAC.Empirical.Computation-Tuple{}","page":"API Empirical computations","title":"JAC.Empirical.Computation","text":"Empirical.Computation()  ... constructor for an 'empty' instance::Empirical.Computation.\n\n\n\n\n\n","category":"method"},{"location":"api-empirical.html#JAC.Basics.perform-Tuple{JAC.Empirical.Computation}","page":"API Empirical computations","title":"JAC.Basics.perform","text":"Basics.perform(computation::Empirical.Computation)       ... to set-up and perform an empirical computation that starts from a given nuclear model and set of configurations,         and which is mainly controlled by its settings. The results are printed to screen but nothing is returned otherwise.\n\nBasics.perform(computation::Empirical.Computation; output=true)       ... to perform the same but to return the complete output in a dictionary;  the particular output depends on the kind         and specifications of the empirical computation but can easily accessed by the keys of this dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api-empirical.html#Semi-empirical-estimates","page":"API Empirical computations","title":"Semi-empirical estimates","text":"","category":"section"},{"location":"api-empirical.html","page":"API Empirical computations","title":"API Empirical computations","text":"Modules = [Semiempirical]\nOrder   = [:type, :function]","category":"page"},{"location":"api-empirical.html#JAC.Semiempirical.AtomicCrossSection","page":"API Empirical computations","title":"JAC.Semiempirical.AtomicCrossSection","text":"@enum   AtomicCrossSection  ... defines a enumeration for (supported) cross section estimation.\n\n\n\n\n\n","category":"type"},{"location":"api-empirical.html#JAC.Semiempirical.AtomicCrossSection-Tuple{String}","page":"API Empirical computations","title":"JAC.Semiempirical.AtomicCrossSection","text":"Semiempirical.AtomicCrossSection(sa::String)  ... constructor for a given String.\n\n\n\n\n\n","category":"method"},{"location":"api-empirical.html#JAC.Semiempirical.estimate-Tuple{String, Int64, Configuration}","page":"API Empirical computations","title":"JAC.Semiempirical.estimate","text":"Semiempirical.estimate(\"binding energy: ...\", Z::Float64, conf::Configuration)       ... to provide an approximate binding energy of a given electron configuration. This estimate adds the binding          energies of all subshell, taken frogm a semi-empirical tabulations by Williams et al.,          https://userweb.jlab.org/~gwyn/ebindene.html. If no binding energy is provided by this table, it simply scales the          binding energies (e/ 12.) from the next lower shell of the same symmetry         No relaxation effects are included if several hole states         occur with regard to the neutral atom. An energy::Float64 in  Hartree is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-empirical.html#JAC.Semiempirical.estimate-Tuple{String, Int64, Subshell}","page":"API Empirical computations","title":"JAC.Semiempirical.estimate","text":"Semiempirical.estimate(\"binding energy\", Z::Int64, sh::Subshell; useLarkins::Bool=false)        ... to provide the binding energy of a subshell electron, taken from a semi-empirical tabulations by Williams et al. (2000),          https://userweb.jlab.org/~gwyn/ebindene.html or Larkins (1977). A energy::Float64 in  Hartree is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-empirical.html#JAC.Semiempirical.estimate-Tuple{String, Shell, Int64}","page":"API Empirical computations","title":"JAC.Semiempirical.estimate","text":"Semiempirical.estimate(\"ionization potential: inner-shell\", shell::Shell, Z::Int64)       ... to estimate the ionization potential = mean binding energy of an electron in the given shell; an energy value::Float64          is returned. These ionization potentials are taken from the tabulation ....\n\n\n\n\n\n","category":"method"},{"location":"api-empirical.html#JAC.Semiempirical.estimateBindingEnergies-Tuple{Float64, Configuration, UnitRange{Int64}, Int64}","page":"API Empirical computations","title":"JAC.Semiempirical.estimateBindingEnergies","text":"Semiempirical.estimateBindingEnergies(Z::Float64, coreConf::Configuration, nRange::UnitRange{Int64}, l::Int64)       ... to estimate the binding energies of the high-n shells with n = nRange and orbital angular momentum l         for a (multiply-charged) ion with nuclear charge Z and core configuration coreConfiguration.         A list of energies::Array{Float64} [in Hartree] is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-empirical.html#JAC.Semiempirical.estimateBindingEnergies-Tuple{Float64, Configuration, UnitRange{Int64}}","page":"API Empirical computations","title":"JAC.Semiempirical.estimateBindingEnergies","text":"Semiempirical.estimateBindingEnergies(Z::Float64, coreConf::Configuration, nRange::UnitRange{Int64})       ... to estimate the binding energies of the high-n shells with n = nRange for a (multiply-charged)          ion with nuclear charge Z and core configuration coreConfiguration.         A list of energies::Array{Float64} [in Hartree] is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-empirical.html#JAC.Semiempirical.estimateRadialExpectation-Tuple{Float64, Configuration, UnitRange{Int64}, Int64}","page":"API Empirical computations","title":"JAC.Semiempirical.estimateRadialExpectation","text":"Semiempirical.estimateRadialExpectation(Z::Float64, coreConf::Configuration, nRange::UnitRange{Int64}, l::Int64)       ... to estimate the radial extent (r-expectation value) of the high-n shells with n = nRange and orbital         angular momentum l for a (multiply-charged) ion with nuclear charge Z and core configuration          coreConfiguration. A list of radii::Array{Float64} [in a_o] is returned.\n\n\n\n\n\n","category":"method"},{"location":"license.html#jac-license","page":"License","title":"LICENSE","text":"","category":"section"},{"location":"license.html","page":"License","title":"License","text":"The JAC apackage is distributed under the MIT licence. The associated User Guide, Compendium & Theoretical Background to JAC is distributed under the Creative Commons Attribution 4.0 International (CC BY 4.0) license.","category":"page"},{"location":"license.html","page":"License","title":"License","text":"Copyright (c) 2017-2025: Stephan Fritzsche.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"api-processes.html#Autoionization","page":"API Atomic processes","title":"Autoionization","text":"","category":"section"},{"location":"api-processes.html","page":"API Atomic processes","title":"API Atomic processes","text":"Modules = [AutoIonization]\nOrder   = [:type, :function]","category":"page"},{"location":"api-processes.html#JAC.AutoIonization.Channel","page":"API Atomic processes","title":"JAC.AutoIonization.Channel","text":"struct  Channel        ... defines a type for a AutoIonization channel to help characterize a scattering (continuum) state of many          electron-states with a single free electron.\n\n+ kappa          ::Int64                ... partial-wave of the free electron\n+ symmetry       ::LevelSymmetry        ... total angular momentum and parity of the scattering state\n+ phase          ::Float64              ... phase of the partial wave\n+ amplitude      ::Complex{Float64}     ... Auger amplitude associated with the given channel.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.AutoIonization.Line","page":"API Atomic processes","title":"JAC.AutoIonization.Line","text":"struct  Line       ... defines a type for a AutoIonization line that may include the definition of sublines and their          corresponding amplitudes.\n\n+ initialLevel   ::Level           ... initial-(state) level\n+ finalLevel     ::Level           ... final-(state) level\n+ electronEnergy ::Float64         ... Energy of the (incoming free) electron.\n+ totalRate      ::Float64         ... Total rate of this line.\n+ angularAlpha   ::Float64         ... Angular alpha_2 coefficient.\n+ channels       ::Array{AutoIonization.Channel,1}  ... List of AutoIonization channels of this line.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.AutoIonization.Line-Tuple{Level, Level, Float64}","page":"API Atomic processes","title":"JAC.AutoIonization.Line","text":"AutoIonization.Line(initialLevel::Level, finalLevel::Level, totalRate::Float64)       ... constructor for an AutoIonization line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.PlasmaSettings","page":"API Atomic processes","title":"JAC.AutoIonization.PlasmaSettings","text":"struct  AutoIonization.PlasmaSettings  <:  Basics.AbstractLineShiftSettings       ... defines a type for the details and parameters of computing Auger rates with plasma interactions.\n\n+ printBefore         ::Bool             ... True, if all energies and lines are printed before their evaluation.\n+ lineSelection       ::LineSelection    ... Specifies the selected levels, if any.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.AutoIonization.PlasmaSettings-Tuple{}","page":"API Atomic processes","title":"JAC.AutoIonization.PlasmaSettings","text":"AutoIonization.PlasmaSettings()  ... constructor for a standard instance of AutoIonization.PlasmaSettings.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.Settings","page":"API Atomic processes","title":"JAC.AutoIonization.Settings","text":"struct  Settings  <:  AbstractProcessSettings  ... defines a type for the details and parameters of computing Auger lines.\n\n+ calcAnisotropy      ::Bool               ... True, if the intrinsic alpha_2,4 angular parameters are to be \n                                                calculated, and false otherwise.\n+ calcTeAuger         ::Bool               \n    ... True, if contributions of the two-electron Auger transitions are to be calculated, and false otherwise;\n        this flag requires a proper (resonant) Green function that supports the TEA transitions.\n+ printBefore         ::Bool               ... True, if all energies and lines are printed before their evaluation.\n+ lineSelection       ::LineSelection      ... Specifies the selected levels, if any.\n+ augerEnergyShift    ::Float64            ... An overall energy shift for all Auger (free-electron) energies.\n+ minAugerEnergy      ::Float64            ... Minimum energy of free (Auger) electrons to be included.\n+ maxAugerEnergy      ::Float64            ... Maximum energy of free (Auger) electrons to be included.\n+ maxKappa            ::Int64              ... Maximum kappa value of partial waves to be included.\n+ operator            ::AbstractEeInteraction   \n    ... Auger operator that is to be used for evaluating the Auger amplitudes; allowed values are: \n        CoulombInteraction(), BreitInteraction(), ...\n+ gMultiplet          ::Multiplet      \n    ... Mean-field multiplet of intermediate levels in the computations, sometimes referred to as\n        (resonant) Green function.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.AutoIonization.Settings-Tuple{JAC.AutoIonization.Settings}","page":"API Atomic processes","title":"JAC.AutoIonization.Settings","text":"AutoIonization.Settings(set::AutoIonization.Settings;\n\n    calcAnisotropy=..,      calcTeAuger..,              printBefore=..,         augerEnergyShift=.., \n    minAugerEnergy=..,      maxAugerEnergy=..,          maxKappa=..,            operator=..,\n    gMultiplet=.. )\n                \n... constructor for modifying the given AutoIonization.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.Settings-Tuple{}","page":"API Atomic processes","title":"JAC.AutoIonization.Settings","text":"AutoIonization.Settings()  ... constructor for the default values of AutoIonization line computations.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.amplitude-Tuple{AbstractEeInteraction, JAC.AutoIonization.Channel, Level, Level, JAC.Radial.Grid}","page":"API Atomic processes","title":"JAC.AutoIonization.amplitude","text":"AutoIonization.amplitude(kind::AbstractEeInteraction, channel::AutoIonization.Channel, continuumLevel::Level, initialLevel::Level,                              grid::Radial.Grid; printout::Bool=true)       ... to compute the kind in  CoulombInteraction(), BreitInteraction(), CoulombBreit(), CoulombGaunt()   Auger amplitude          <(alphaf Jf, kappa) Ji || O^(Auger, kind) || alphai J_i>  due to the interelectronic interaction for the given          final and initial level. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.channelAmplitude-Tuple{String, JAC.AutoIonization.Channel, Float64, Level, Level, JAC.Radial.Grid}","page":"API Atomic processes","title":"JAC.AutoIonization.channelAmplitude","text":"AutoIonization.channelAmplitude(kind::String, channel::AutoIonization.Channel, energy::Float64, finalLevel::Level,                                      initialLevel::Level, grid::Radial.Grid)       ... to compute the kind = (CoulombInteraction(), BreitInteraction(), CoulombBreit(), CoulombGaunt())   Auger amplitude           <(alphaf Jf, kappa) Ji || O^(Auger, kind) || alphai J_i>  due to the interelectronic interaction for the given final and          initial level. A newChannel::AutoIonization.Channel is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.computeAmplitudesProperties-Tuple{JAC.AutoIonization.Line, Model, JAC.Radial.Grid, Int64, JAC.AutoIonization.Settings}","page":"API Atomic processes","title":"JAC.AutoIonization.computeAmplitudesProperties","text":"AutoIonization.computeAmplitudesProperties(line::AutoIonization.Line, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,                                              settings::AutoIonization.Settings; printout::Bool=true)      ... to compute all amplitudes and properties of the given line; a line::AutoIonization.Line is returned for which the amplitudes          and properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.computeAmplitudesPropertiesPlasma-Tuple{JAC.AutoIonization.Line, Model, JAC.Radial.Grid, Int64, JAC.AutoIonization.PlasmaSettings}","page":"API Atomic processes","title":"JAC.AutoIonization.computeAmplitudesPropertiesPlasma","text":"AutoIonization.computeAmplitudesPropertiesPlasma(line::AutoIonization.Line, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,                                                    settings::AutoIonization.PlasmaSettings; printout::Bool=true)       ... to compute all amplitudes and properties of the given line but for the given plasma model; a line::AutoIonization.Line is returned          for which the amplitudes and properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.computeIntrinsicAlpha-Tuple{Int64, JAC.AutoIonization.Line}","page":"API Atomic processes","title":"JAC.AutoIonization.computeIntrinsicAlpha","text":"AutoIonization.computeIntrinsicAlpha(k::Int64, line::AutoIonization.Line)       ... to compute the intrinsic alpha_k anisotropy parameter for the given line. A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.computeLines-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.AutoIonization.Settings}","page":"API Atomic processes","title":"JAC.AutoIonization.computeLines","text":"AutoIonization.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                  settings::AutoIonization.Settings; output=true, printout::Bool=true)       ... to compute the Auger transition amplitudes and all properties as requested by the given settings. A list of          lines::Array{AutoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.computeLinesCascade-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.AutoIonization.Settings}","page":"API Atomic processes","title":"JAC.AutoIonization.computeLinesCascade","text":"AutoIonization.computeLinesCascade(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                      settings::AutoIonization.Settings; output::Bool=true, printout::Bool=true)       ... to compute the Auger transition amplitudes and all properties as requested by the given settings. The computations         and printout is adapted for large cascade computations by including only lines with at least one channel and by sending         all printout to a summary file only. A list of lines::Array{AutoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.computeLinesFromOrbitals-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.AutoIonization.Settings, Dict{Subshell, Orbital}}","page":"API Atomic processes","title":"JAC.AutoIonization.computeLinesFromOrbitals","text":"AutoIonization.computeLinesFromOrbitals(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                              settings::AutoIonization.Settings, contOrbitals::Dict{Subshell, Orbital}; output::Bool=true, printout::Bool=true)       ... to compute the Auger transition amplitudes and all properties as requested by the given settings but by using the given set of          continuum orbitals. The computations and printout is adapted for large cascade computations by including only lines with at least          one channel and by sending all printout to a summary file only. A list of lines::Array{AutoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.computeLinesPlasma-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.AutoIonization.PlasmaSettings}","page":"API Atomic processes","title":"JAC.AutoIonization.computeLinesPlasma","text":"AutoIonization.computeLinesPlasma(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                     settings::AutoIonization.PlasmaSettings; output=true)       ... to compute the Auger transition amplitudes and all properties as requested by the given settings. A list of          lines::Array{AutoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.computeTeaAmplitude-Tuple{AbstractEeInteraction, JAC.AutoIonization.Channel, Level, Multiplet, Level, JAC.Radial.Grid}","page":"API Atomic processes","title":"JAC.AutoIonization.computeTeaAmplitude","text":"AutoIonization.computeTeaAmplitude(kind::AbstractEeInteraction, channel::AutoIonization.Channel, continuumLevel::Level,                                      gMultiplet::Multiplet, initialLevel::Level, grid::Radial.Grid; printout::Bool=true)       ... to compute the kind in  CoulombInteraction(), BreitInteraction(), CoulombBreit() total Auger amplitude          for the two-electron Auger transitions via the gMultiplet as the resonant Green function:\n\n    <(alpha_f J_f, kappa) J_i || O^(TEA, kind) || alpha_i J_i> \n    \n                <(alpha_f J_f, kappa) J_i || O^(Auger, kind) || alpha_in J_n> <J_n || O^(e-e, kind) || alpha_i J_i>\n            = ---------------------------------------------------------------------------------------------------\n                                                                E_i  -  E_n\n                                                                \n    due to the interelectronic interaction as well as the given initial, intermediate (gMultiplet), and final \n    (continuum) levels and the given kind of interaction. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.determineChannels-Tuple{Level, Level, JAC.AutoIonization.Settings}","page":"API Atomic processes","title":"JAC.AutoIonization.determineChannels","text":"AutoIonization.determineChannels(finalLevel::Level, initialLevel::Level, settings::AutoIonization.Settings)       ... to determine a list of Auger Channel for a transitions from the initial to final level and by taking into account the particular          settings of for this computation; an Array{AutoIonization.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.determineLines-Tuple{Multiplet, Multiplet, JAC.AutoIonization.Settings}","page":"API Atomic processes","title":"JAC.AutoIonization.determineLines","text":"AutoIonization.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::AutoIonization.Settings)       ... to determine a list of AutoIonization.Line's for transitions between levels from the initial- and final-state multiplets, and           by taking into account the particular selections and settings for this computation; an Array{AutoIonization.Line,1} is returned.          Apart from the level specification, all physical properties are set to zero during the initialization process.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.displayLifetimes-Tuple{IO, Vector{JAC.AutoIonization.Line}}","page":"API Atomic processes","title":"JAC.AutoIonization.displayLifetimes","text":"AutoIonization.displayLifetimes(stream::IO, lines::Array{AutoIonization.Line,1})       ... to list all lifetimes as associated with the selected lines. A neat table is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.displayLines-Tuple{IO, Vector{JAC.AutoIonization.Line}}","page":"API Atomic processes","title":"JAC.AutoIonization.displayLines","text":"AutoIonization.displayLines(stream::IO, lines::Array{AutoIonization.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all selected          transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.AutoIonization.displayRates-Tuple{IO, Vector{JAC.AutoIonization.Line}, JAC.AutoIonization.Settings}","page":"API Atomic processes","title":"JAC.AutoIonization.displayRates","text":"AutoIonization.displayRates(stream::IO, lines::Array{AutoIonization.Line,1}, settings::AutoIonization.Settings)       ... to list all results, energies, rates, etc. of the selected lines. A neat table is printed but nothing is returned          otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#Dielectronic-Recombination","page":"API Atomic processes","title":"Dielectronic Recombination","text":"","category":"section"},{"location":"api-processes.html","page":"API Atomic processes","title":"API Atomic processes","text":"Modules = [DielectronicRecombination]\nOrder   = [:type, :function]","category":"page"},{"location":"api-processes.html#JAC.DielectronicRecombination.AbstractCorrections","page":"API Atomic processes","title":"JAC.DielectronicRecombination.AbstractCorrections","text":"abstract type DielectronicRecombination.AbstractCorrections      ... defines an abstract type to distinguish different types of corrections to the decay rates and strength.         These corrections are based on the classification of shell:\n\n    n^(core)  <   n^(final)  <  n^(hydrogenic)  <  n^(lowest-captured)  <  n^(lower-empirical)    \n              <=  n^(upper-empirical)              ... where\n              \n    n^(core)            ... refers to the (maximum) principal quantum number to which initial core electrons are excited;\n    n^(final)           ... the maximum number for which shells are treated explicitly in the representation of the final levels f;\n    n^(hydrogenic)      ... to the maximum n-shell, to which the radiative decay is modeled by scaled-hydrogenic rates, \n                        ... and which can be omitted also from the list. \n    n^(lowest-captured) ... is the lowest, high-n shell, into which the additional electron is captured and which must\n                            (of course) occur explicitly in the basis of the intermediate and final levels. \n    [n^(lower-empirical)  <=  n^(upper-empirical)]  \n                        ... designates additional (empirical) high-n shells for which the contributions to the DR resonances \n                            are still estimated empirically by using arguments from quantum-defect theory. All shells with \n                            n > n^(upper-empirical) are neglected completely for their contributions to the DR spectra; see also:\n\n+ struct DielectronicRecombination.EmpiricalCorrections  \n    ... to estimate empirically the contributions of additional resonances for the capture of an electron into\n        shells with [n^(lower-empirical)  <=  n^(upper-empirical)]. A simple scaling of the rates, calculated initially\n        for n^(lowest-captured), ... only, is utilized for estimating the associated strength for these additional\n        resonances.\n+ struct DielectronicRecombination.HydrogenicCorrections  \n    ... to add for missing final decay levels to the (total) photon decay rates by scaling the corresponding rates\n        of non-relativistic hydrogenic ions with a suitable effective charge (Zeff); these hydrogenic corrections improve\n        goth, the total photon rate as well as the resonance strength.\n+ struct DielectronicRecombination.MaximumlCorrection  \n    ... to exclude all subshells with l > l_max in the hydrogenic corrections; this restriction does not apply to the \n        given resonance levels, which can be controlled (and are specified) by the list of intermediate configurations.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.DielectronicRecombination.EmpiricalCorrections","page":"API Atomic processes","title":"JAC.DielectronicRecombination.EmpiricalCorrections","text":"struct  DielectronicRecombination.EmpiricalCorrections  <:  DielectronicRecombination.AbstractCorrections       ... to include empirical corrections for the shells with [n^(lower-empirical)  <=  n^(upper-empirical)].         A rather rude model is used so far.\n\n+ nUpperEmpirical ::Union{Int64,Missing}   \n    ... The upper-empirical shell for which rate contributions are estimated; the lower-empirical shell = n^(captured-max + 1) \n        is derived from the given configuration lists. No corrections are made for nUpperEmpirical <= n^(captured-max + 1).\n+ effectiveZ      ::Union{Float64,Missing}  ... effective charge Z_eff for the hydrogenic correction (inactive).\n+ rateScaling     ::Union{Float64,Missing}  ... scaling factor to modify the estimated rates.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.DielectronicRecombination.EmpiricalTreatment","page":"API Atomic processes","title":"JAC.DielectronicRecombination.EmpiricalTreatment","text":"struct  DielectronicRecombination.EmpiricalTreatment       ... defines an (internal) type to communicate and distribute the physical (and technical) parameters         that are utilized to make the requested empirical corrections or just nothing. This data type should         not be applied by the user but is initialized by the given (set of) corrections.         Otherwise, it is treated like any other type in JAC. All parameters are made physically \"explicit\",         even if they were \"missing\" originally, and can be directly applied in the empirical treatment of         the DR process. The following hierarchy of shells is used:\n\n    n^(core)  <   n^(final)  <  n^(hydrogenic)  <  n^(lowest-captured)  <  n^(lower-empirical)    \n              <=  n^(upper-empirical) \n    \n+ doEmpiricalCorrections      ::Bool    ... True, if empirical corrections are needed, false o/w.\n+ doHydrogenicCorrections     ::Bool    ... True, if hydrogenic corrections are needed, false o/w.\n+ doMaximumlCorrection        ::Bool    ... True, if a maximum l values is used, false o/w.\n+ doResonanceWindowCorrection ::Bool    ... True, if a window of resonances is specified, false o/w.\n+ nCore                       ::Int64   \n    ... (maximum) principal quantum number to which initial core electrons are excited;\n+ nFinal                      ::Int64   \n    ... the maximum number for which shells are treated explicitly in the representation of the final levels f;\n+ nHydrogenic                 ::Int64   \n    ... maximum n-shell, to which the radiative decay is modeled by scaled-hydrogenic rates. \n+ nLowestCaptured             ::Int64   \n    ... lowest, high-n shell, into which the additional electron is captured and which must (of course) occur \n        explicitly in the basis of the intermediate and final levels.\n+ nLowerEmpirical             ::Int64   \n    ... maximum n-shell, to which the radiative decay is modeled by scaled-hydrogenic rates. \n+ nUpperEmpirical             ::Int64   \n    ... additional (empirical) high-n shells for which the contributions to the DR resonances are still \n        estimated empirically by using arguments from quantum-defect theory.\n+ maximum_l                   ::Int64    ... maximum l value; is set to a large value if not specified by the user.\n+ hydrogenicEffectiveZ        ::Float64  ... effective charge Z_eff for the hydrogenic correction (inactive).\n+ hydrogenicRateScaling       ::Float64  ... scaling factor to modify the estimated hydrogenic rates.\n+ empiricalEffectiveZ         ::Float64  ... effective Z for empirical estimates\n+ empiricalRateScaling        ::Float64  ... scaling factor to modify the empirical rates.\n+ resonanceEnergyMin:         ::Float64  ... minimum energy [Hartree] of the resonances to be considered.\n+ resonanceEnergyMax:         ::Float64  ... maximum energy [Hartree] of the resonances to be considered.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.DielectronicRecombination.HydrogenicCorrections","page":"API Atomic processes","title":"JAC.DielectronicRecombination.HydrogenicCorrections","text":"struct  DielectronicRecombination.HydrogenicCorrections  <:  DielectronicRecombination.AbstractCorrections       ... to add for missing final decay levels the photon decay rates for non-relativistic hydrogenic ions;         this improves the total photon rate as well as the resonance strength. These corrections are taken into         account for all shells with n^{final}+1 <= n <= nHydrogenic\n\n+ nHydrogenic       ::Union{Int64,Missing}   \n    ... upper principal quantum number nHydrogenic for which hydrogenic correctios to the radiative photon rates are \n        calculated explicitly; the photon rates are further scaled if some proper effectiveZ and/or rateScaling\n        is provided.\n+ effectiveZ      ::Union{Float64,Missing}   ... effective charge Z_eff for the hydrogenic correction.\n+ rateScaling     ::Union{Float64,Missing}   ... scaling factor to scale the photon rates\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.DielectronicRecombination.MaximumlCorrection","page":"API Atomic processes","title":"JAC.DielectronicRecombination.MaximumlCorrection","text":"struct  DielectronicRecombination.MaximumlCorrection  <:  DielectronicRecombination.AbstractCorrections       ... to exclude all subshells with l > l_max, both in the treatment of the corrections shells.\n\n+ maximum_l    ::Union{Int64,Missing}   \n    ... maximum orbital angular momentum quantum number for which contributions to the DR strengths are \n        taken into account. This number applies for all subshells for which other corrections are \n        requested, whereas the \"physical subshells\" are defined by the configuration lists.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.DielectronicRecombination.Passage","page":"API Atomic processes","title":"JAC.DielectronicRecombination.Passage","text":"struct  DielectronicRecombination.Passage       ... defines a type for a dielectronic recombination passage, i.e. a (reduced) pathways, that include the          definition of channels and their corresponding amplitudes for the individual i –> m resonances, whereas         the subsequent radiative stabilization is considered only later.\n\n+ initialLevel      ::Level                   ... initial-(state) level\n+ intermediateLevel ::Level                   ... intermediate-(state) level\n+ electronEnergy    ::Float64                 ... energy of the (incoming, captured) electron\n+ captureRate       ::Float64                 ... rate for the electron capture (Auger rate)\n+ photonRate        ::EmProperty              ... rate for the photon emission\n+ reducedStrength   ::EmProperty              \n    ... reduced resonance strength Sum_f S(i -> d -> f) * Gamma_d of this passage; this reduced strength does \n        not require the knowledge of Gamma_d for the individual passage.\n+ captureChannels   ::Array{AutoIonization.Channel,1}   ... List of |i> -->  |n>   dielectronic (Auger) capture channels.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.DielectronicRecombination.Passage-Tuple{}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.Passage","text":"DielectronicRecombination.Passage()       ... constructor for an 'empty' instance of a dielectronic recombination passage between a specified          initial and intermediate level.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.Pathway","page":"API Atomic processes","title":"JAC.DielectronicRecombination.Pathway","text":"struct  DielectronicRecombination.Pathway       ... defines a type for a dielectronic recombination pathways that may include the definition of channels and          their corresponding amplitudes.\n\n+ initialLevel      ::Level                   ... initial-(state) level\n+ intermediateLevel ::Level                   ... intermediate-(state) level\n+ finalLevel        ::Level                   ... final-(state) level\n+ electronEnergy    ::Float64                 ... energy of the (incoming, captured) electron\n+ photonEnergy      ::Float64                 ... energy of the (emitted) photon\n+ captureRate       ::Float64                 ... rate for the electron capture (Auger rate)\n+ photonRate        ::EmProperty              ... rate for the photon emission\n+ angularBeta       ::EmProperty              ... beta parameter of the photon emission\n+ reducedStrength   ::EmProperty              ... reduced resonance strength S(i -> d -> f) * Gamma_d of this pathway;\n                                                    this reduced strength does not require the knowledge of Gamma_d for each pathway.\n+ captureChannels   ::Array{AutoIonization.Channel,1}   ... List of |i> -->  |n>   dielectronic (Auger) capture channels.\n+ photonChannels    ::Array{PhotoEmission.Channel,1}    ... List of |n> -->  |f>   radiative stabilization channels.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.DielectronicRecombination.Pathway-Tuple{}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.Pathway","text":"DielectronicRecombination.Pathway()       ... constructor for an 'empty' instance of a dielectronic recombination pathway between a specified          initial, intermediate and final level.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.Resonance","page":"API Atomic processes","title":"JAC.DielectronicRecombination.Resonance","text":"struct  DielectronicRecombination.Resonance       ... defines a type for a dielectronic resonance as defined by a given initial and resonance level but by summing over all final levels\n\n+ initialLevel      ::Level             ... initial-(state) level\n+ intermediateLevel ::Level             ... intermediate-(state) level\n+ resonanceEnergy   ::Float64           ... energy of the resonance w.r.t. the inital-state\n+ resonanceStrength ::EmProperty        ... strength of this resonance due to the stabilization into any of the allowed final levels.\n+ captureRate       ::Float64           ... capture (Auger) rate to form the intermediate resonance, starting from the initial level.\n+ augerRate         ::Float64           ... total (Auger) rate for an electron emission of the intermediate resonance\n+ photonRate        ::EmProperty        ... total photon rate for a photon emission, i.e. for stabilization.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.DielectronicRecombination.Resonance-Tuple{}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.Resonance","text":"DielectronicRecombination.Resonance()       ... constructor for an 'empty' instance of a dielectronic resonance as defined by a given initial and resonance          level but by summing over all final levels.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.ResonanceSelection","page":"API Atomic processes","title":"JAC.DielectronicRecombination.ResonanceSelection","text":"struct  DielectronicRecombination.ResonanceSelection       ... defines a type for selecting classes of resonances in terms of leading configurations.\n\n+ active          ::Bool              ... initial-(state) level\n+ fromShells      ::Array{Shell,1}    ... List of shells from which excitations are to be considered.\n+ toShells        ::Array{Shell,1}    ... List of shells to which (core-shell) excitations are to be considered.\n+ intoShells      ::Array{Shell,1}    ... List of shells into which electrons are initially placed (captured).\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.DielectronicRecombination.ResonanceSelection-Tuple{}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.ResonanceSelection","text":"DielectronicRecombination.ResonanceSelection()       ... constructor for an 'empty' instance of a ResonanceSelection()\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.ResonanceWindowCorrection","page":"API Atomic processes","title":"JAC.DielectronicRecombination.ResonanceWindowCorrection","text":"struct  DielectronicRecombination.ResonanceWindowCorrection  <:  DielectronicRecombination.AbstractCorrections       ... to exclude all DR resonances outside of a given \"window [Emin, Emax]\" of resonance energies with         regard to the initial level.\n\n+ energyMin  ::Float64   ... minimum energy [Hartree] of the resonances to be considered.  \n+ energyMax  ::Float64   ... maximum energy [Hartree] of the resonances to be considered.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.DielectronicRecombination.Settings","page":"API Atomic processes","title":"JAC.DielectronicRecombination.Settings","text":"struct  DielectronicRecombination.Settings  <:  AbstractProcessSettings       ... defines a type for the details and parameters of computing dielectronic recombination pathways.\n\n+ multipoles            ::Array{EmMultipoles}  ... Multipoles of the radiation field that are to be included.\n+ gauges                ::Array{UseGauge}      ... Specifies the gauges to be included into the computations.\n+ calcOnlyPassages      ::Bool                 \n    ... Only compute resonance strength but without making all the pathways explicit. This option is useful\n        for the capture into high-n shells or if the photons are not considered explicit. It also treats the \n        shells differently due to the given core shells < final-state shells < hydrogenically-scaled shells <\n        capture-shells < asymptotic-shells. Various correction and multi-threading techiques can be applied\n        to deal with or omit different classes of these shells.\n+ calcRateAlpha         ::Bool                 \n    ... True, if the DR rate coefficients are to be calculated, and false o/w.\n+ printBefore           ::Bool                 \n    ... True, if all energies and pathways are printed before their evaluation.\n+ pathwaySelection      ::PathwaySelection     ... Specifies the selected levels/pathways, if any.\n+ electronEnergyShift   ::Float64              \n    ... An overall energy shift for all electron energies (i.e. from the initial to the resonance levels [Hartree].\n+ photonEnergyShift     ::Float64              \n    ... An overall energy shift for all photon energies (i.e. from the resonance to the final levels.\n+ mimimumPhotonEnergy   ::Float64              \n    ... minimum transition energy for which photon transitions are  included into the evaluation.\n+ temperatures          ::Array{Float64,1}     \n    ... list of temperatures for which plasma rate coefficients are displayed; however, these rate coefficients\n        only include the contributions from those pathsways that are calculated here explicitly.\n+ corrections           ::Array{DielectronicRecombination.AbstractCorrections,1}\n    ... Specify, if appropriate, the inclusion of additional corrections to the rates and DR strengths.\n+ augerOperator         ::AbstractEeInteraction \n    ... Auger operator that is to be used for evaluating the Auger amplitude's; the allowed values are: \n        CoulombInteraction(), BreitInteration(), CoulombBreit(), CoulombGaunt().\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.DielectronicRecombination.Settings-Tuple{JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.Settings","text":"(set::DielectronicRecombination.Settings;\n\n    multipoles=..,             gauges=..,                  \n    calcOnlyPassages=..,       calcRateAlpha=..,         printBefore=..,           pathwaySelection=..,     \n    electronEnergyShift=..,    photonEnergyShift=..,       \n    mimimumPhotonEnergy=..,    temperatures=..,          corrections=..,           augerOperator=..)\n                \n... constructor for modifying the given DielectronicRecombination.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.Settings-Tuple{}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.Settings","text":"DielectronicRecombination.Settings()       ... constructor for the default values of dielectronic recombination pathway computations.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.addEmpiricalPassages!-Tuple{Vector{JAC.DielectronicRecombination.Passage}, JAC.DielectronicRecombination.EmpiricalTreatment}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.addEmpiricalPassages!","text":"DielectronicRecombination.addEmpiricalPassages!(passages::Array{DielectronicRecombination.Passage,1},                                                  empTreatment::EmpiricalTreatment)       ... to add further (empirical) passages due to the capture of electrons into higher n-shells; information         about the last \"captured\" shell as well as the interval [nLowerEmpirical, nUpperEmpirical] are taken from         empTreatment. A simple scaling rules of energies and rates are presently applied bu could be improved         if needed. The array passages::Array{DielectronicRecombination.Passage,1} is modified and nothing is         returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.checkConsistentMultiplets-Tuple{Multiplet, Multiplet, Multiplet}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.checkConsistentMultiplets","text":"DielectronicRecombination.checkConsistentMultiplets(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet,                                                       initialMultiplet::Multiplet)       ... to check that the given initial-, intermediate- and final-state levels and multiplets are consistent to each other and         to avoid later problems with the computations. An error message is issued if an inconsistency occurs,         and nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.checkOrbitalRepresentation-Tuple{Multiplet, Multiplet, Multiplet}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.checkOrbitalRepresentation","text":"DielectronicRecombination.checkOrbitalRepresentation(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet,                                                        initialMultiplet::Multiplet)       ... to check (and analyze) that all high nl orbitals in these multiplets are properly represented on the given grid.         The function prints for each symmetry block kappa the high-nl orbitals and checks that they are all bound.         An error message is issued if this is not the case, and nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.computeAmplitudesProperties-Tuple{JAC.DielectronicRecombination.Passage, Multiplet, Model, JAC.Radial.Grid, Int64, JAC.DielectronicRecombination.EmpiricalTreatment, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.computeAmplitudesProperties","text":"DielectronicRecombination.computeAmplitudesProperties(passage::DielectronicRecombination.Passage,                             finalMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,                             empTreatment::EmpiricalTreatment, settings::DielectronicRecombination.Settings)      ... to compute all amplitudes and properties of the given line; a line::DielectronicRecombination.Pathway is returned          for which the amplitudes and properties have now been evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.computeAmplitudesProperties-Tuple{JAC.DielectronicRecombination.Pathway, Model, JAC.Radial.Grid, Int64, JAC.DielectronicRecombination.Settings, Bool, Vector{JAC.AutoIonization.Channel}}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.computeAmplitudesProperties","text":"(pathway::DielectronicRecombination.Pathway, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,    settings::DielectronicRecombination.Settings, hasCaptureChannels::Bool,     lastCaptureChannels::Array{AutoIonization.Channel,1})      ... to compute all amplitudes and properties of the given line; a line::DielectronicRecombination.Pathway is returned          for which the amplitudes and properties have now been evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.computeHydrogenicRate-Tuple{Int64, Int64, Int64, Int64, Float64}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.computeHydrogenicRate","text":"DielectronicRecombination.computeHydrogenicRate(ni::Int64, li::Int64, nf::Int64, lf::Int64,  Zeff::Float64)     ... to compute the non-relativistic electric-dipole rate for the transition from shell ni,li –> nf,lf of a         hydrogenic ion with effective charge Zeff. The recursion formulas by Infeld and Hull (1951) are used         together with the absorption oscillator strength. This makes the overall formulation/computation rather         obscure, unfortunately. Uses SpecialFunctions.logfactorial. A rate::Float64 [a.u.] is returned.         This procedure has been worked out by Stefan Schippers (2023).\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.computePassages-Tuple{Multiplet, Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.DielectronicRecombination.EmpiricalTreatment, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.computePassages","text":"DielectronicRecombination.computePassages(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet, initialMultiplet::Multiplet,                                            nm::Nuclear.Model, grid::Radial.Grid, empTreatment::EmpiricalTreatment,                                             settings::DielectronicRecombination.Settings)       ... to compute the data for all resonances (resonance lines) directly from the given multiplets of the initial-, intermediate-          and final states. It also enables one to (successively) include a set of corrections to the resonance strength to incorporate         the contributions of shells that were not considered explicitly.          A list of resonances::Array{DielectronicRecombination.Resonance,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.computePathways-Tuple{Multiplet, Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.computePathways","text":"DielectronicRecombination.computePathways(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet, initialMultiplet::Multiplet,                            nm::Nuclear.Model, grid::Radial.Grid, settings::DielectronicRecombination.Settings; output=true)       ... to compute the dielectronic recombination amplitudes and all properties as requested by the given settings.          A list of pathways::Array{DielectronicRecombination.Pathway,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.computeRateCoefficient-Tuple{JAC.DielectronicRecombination.Resonance, Float64}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.computeRateCoefficient","text":"DielectronicRecombination.computeRateCoefficient(resonance::DielectronicRecombination.Resonance, temp::Float64)       ... computes for a delta-like resonance the DR rate coefficient alpha_d (i, Te) from the given resonance strength         and temperature [K], and for both, Coulomb and Babushkin gauge. All values are directly returned in [cm^3/s].         An alphaDR::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.computeResonances-Tuple{Vector{JAC.DielectronicRecombination.Passage}, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.computeResonances","text":"DielectronicRecombination.computeResonances(passages::Array{DielectronicRecombination.Passage,1},                                               settings::DielectronicRecombination.Settings)       ... to compute the data for all resonances (resonance lines) as defined by the given passages and and settings.          In fact, passages and resonances are treated rather similar to each other in JAC and can be readily         extracted from each other. A list of resonances::Array{DielectronicRecombination.Resonance,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.computeResonances-Tuple{Vector{JAC.DielectronicRecombination.Pathway}, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.computeResonances","text":"(pathways::Array{DielectronicRecombination.Pathway,1}, settings::DielectronicRecombination.Settings)       ... to compute the data for all resonances (resonance lines) as defined by the given pathways and and settings.          A list of resonances::Array{DielectronicRecombination.Resonance,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.determineCaptureChannels-Tuple{Level, Level, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.determineCaptureChannels","text":"DielectronicRecombination.determineCaptureChannels(intermediateLevel::Level, initialLevel::Level,                                                      settings::DielectronicRecombination.Settings)      ... to determine a list of AutoIonization.Channel for a (Auger) capture transitions from the initial to an          intermediate level, and by taking into account the particular settings of for this computation;           an Array{AutoIonization.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.determineEmpiricalTreatment-Tuple{Multiplet, Multiplet, Model, Multiplet, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.determineEmpiricalTreatment","text":"DielectronicRecombination.determineEmpiricalTreatment(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet,                                      nm::Nuclear.Model, initialMultiplet::Multiplet, settings::DielectronicRecombination.Settings)      ... to determine an instance of empiricalTreatment::EmpiricalTreatment that is (internally) applied to simplify         the use of \"corrections\" to the DR strenghts. This data structure summarizes all parameters that help introduce         several empirical corrections. The procedure is simple but slightly sophisticated as we wish to support \"missing\"         parameters in the individual corrections as well as the knowledge that can be derived internally.          The definition of EmpiricalTreatment() can readily be extended as the need arises from the user side.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.determinePassages-Tuple{Multiplet, Multiplet, JAC.DielectronicRecombination.EmpiricalTreatment, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.determinePassages","text":"DielectronicRecombination.determinePassages(intermediateMultiplet::Multiplet, initialMultiplet::Multiplet,                                               empTreatment::EmpiricalTreatment, settings::DielectronicRecombination.Settings)       ... to determine a list of dielectronic-recombination resonances between the levels from the given initial- and intermediate-          states, whereas the final states are considered \"on-fly\"; the particular selections and settings for this computation         are taken into account; an Array{DielectronicRecombination.Passsage,1} is returned. Apart from the level specification,          all physical properties are set to zero during the initialization process.  \n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.determinePathways-Tuple{Multiplet, Multiplet, Multiplet, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.determinePathways","text":"DielectronicRecombination.determinePathways(finalMultiplet::Multiplet, intermediateMultiplet::Multiplet, initialMultiplet::Multiplet,                                               settings::DielectronicRecombination.Settings)       ... to determine a list of dielectronic-recombination pathways between the levels from the given initial-, intermediate- and          final-state multiplets and by taking into account the particular selections and settings for this computation;          an Array{DielectronicRecombination.Pathway,1} is returned. Apart from the level specification, all physical properties          are set to zero during the initialization process.  \n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.determinePhotonChannels-Tuple{Level, Level, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.determinePhotonChannels","text":"DielectronicRecombination.determinePhotonChannels(finalLevel::Level, intermediateLevel::Level,                                                     settings::DielectronicRecombination.Settings)      ... to determine a list of PhotoEmission.Channel for the photon transitions from the intermediate and to a final level, and by          taking into account the particular settings of for this computation;  an Array{PhotoEmission.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.displayPassages-Tuple{IO, Vector{JAC.DielectronicRecombination.Passage}}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.displayPassages","text":"DielectronicRecombination.displayPassages(stream::IO, passages::Array{DielectronicRecombination.Passage,1})       ... to display a list of passages and channels that have been selected due to the prior settings. A neat table of all selected          transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.displayPathways-Tuple{IO, Vector{JAC.DielectronicRecombination.Pathway}}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.displayPathways","text":"DielectronicRecombination.displayPathways(stream::IO, pathways::Array{DielectronicRecombination.Pathway,1})       ... to display a list of pathways and channels that have been selected due to the prior settings. A neat table of all selected          transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.displayRateCoefficients-Tuple{IO, Vector{JAC.DielectronicRecombination.Resonance}, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.displayRateCoefficients","text":"DielectronicRecombination.displayRateCoefficients(stream::IO, resonances::Array{DielectronicRecombination.Resonance,1},                                                    settings::DielectronicRecombination.Settings)       ... to list, if settings.calcRateAlpha, all rate coefficients for the selected temperatures. Both, the individual as well as         the total DR plasma rate coefficients are printed in neat tables, though nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.displayResults-Tuple{IO, Vector{JAC.DielectronicRecombination.Pathway}, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.displayResults","text":"DielectronicRecombination.displayResults(stream::IO, pathways::Array{DielectronicRecombination.Pathway,1},                                           settings::DielectronicRecombination.Settings)       ... to list all results, energies, cross sections, etc. of the selected lines. A neat table is printed but nothing is          returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.displayResults-Tuple{IO, Vector{JAC.DielectronicRecombination.Resonance}, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.displayResults","text":"+ (stream::IO, resonances::Array{DielectronicRecombination.Resonance,1}, settings::DielectronicRecombination.Settings)`  \n... to list all results for the resonances. A neat table is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.extractRateCoefficients-Tuple{Vector{JAC.DielectronicRecombination.Resonance}, JAC.DielectronicRecombination.Settings}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.extractRateCoefficients","text":"DielectronicRecombination.extractRateCoefficients(resonances::Array{DielectronicRecombination.Resonance,1}, settings::DielectronicRecombination.Settings)       ... to extract, if settings.calcRateAlpha, the total DR rate coefficients for all temperatures.          A list of total rate coefficients [cm^3/s] alphaDR::Array{EmProperty,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.DielectronicRecombination.isResonanceToBeExcluded-Tuple{Level, Any, JAC.DielectronicRecombination.ResonanceSelection}","page":"API Atomic processes","title":"JAC.DielectronicRecombination.isResonanceToBeExcluded","text":"DielectronicRecombination.isResonanceToBeExcluded(level::Level, refLevel, rSelection::ResonanceSelection)       returns true, if level is to be excluded from the valid resonances, and false otherwise.     It returns false if the ResonanceSelection() is inactive or if level belongs to the selected resoances.     It is true only of ResonanceSelection() is active but the level does not belong to the selected resonances.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#Electron-Impact-Excitation","page":"API Atomic processes","title":"Electron Impact Excitation","text":"","category":"section"},{"location":"api-processes.html","page":"API Atomic processes","title":"API Atomic processes","text":"Modules = [ImpactExcitation]\nOrder   = [:type, :function]","category":"page"},{"location":"api-processes.html#JAC.ImpactExcitation.Channel","page":"API Atomic processes","title":"JAC.ImpactExcitation.Channel","text":"struct  ImpactExcitation.Channel       ... defines a type for a electron-impact excitaiton channel to help characterize the incoming and outgoing (continuum) states of          many electron-states with a single free electron\n\n+ initialKappa     ::Int64              ... partial-wave of the incoming free electron\n+ finalKappa       ::Int64              ... partial-wave of the outgoing free electron\n+ symmetry         ::LevelSymmetry      ... total angular momentum and parity of the scattering state\n+ initialPhase     ::Float64            ... phase of the incoming partial wave\n+ finalPhase       ::Float64            ... phase of the outgoing partial wave\n+ amplitude        ::Complex{Float64}   ... Collision amplitude associated with the given channel.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.ImpactExcitation.Line","page":"API Atomic processes","title":"JAC.ImpactExcitation.Line","text":"struct  ImpactExcitation.Line       ... defines a type for a electron-impact excitation line that may include the definition of channels and their corresponding                                                                                                                         amplitudes.\n\n+ initialLevel           ::Level         ... initial- (bound-state) level\n+ finalLevel             ::Level         ... final- (bound-state) level\n+ initialElectronEnergy  ::Float64       ... energy of the incoming (initial-state) free-electron\n+ finalElectronEnergy    ::Float64       ... energy of the outgoing (final-state) free-electron\n+ crossSection           ::Float64       ... total cross section of this line\n+ collisionStrength      ::Float64       ... total collision strength of this line\n+ channels               ::Array{ImpactExcitation.Channel,1}  ... List of ImpactExcitation channels of this line.\n+ convergence            ::Float64       ... convergence of calculation\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.ImpactExcitation.Line-Tuple{Level, Level, Float64}","page":"API Atomic processes","title":"JAC.ImpactExcitation.Line","text":"ImpactExcitation.Line(initialLevel::Level, finalLevel::Level, crossSection::Float64)       ... constructor for an electron-impact excitation line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.Line-Tuple{}","page":"API Atomic processes","title":"JAC.ImpactExcitation.Line","text":"ImpactExcitation.Line()  ... 'empty' constructor for an electron-impact excitation line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.RateCoefficients","page":"API Atomic processes","title":"JAC.ImpactExcitation.RateCoefficients","text":"struct  ImpactExcitation.RateCoefficients     ... Defines a type for the output results from excitation rate or                                                     effective collision strengths calculations\n\n+ initialLevel        ::Level               ... initial- (bound-state) level\n+ finalLevel          ::Level               ... final- (bound-state) level\n+ temperatures        ::Array{Float64,1}    ... Temperatures in [K] to calculate excitation rates and effective collision strengths\n+ alphas              ::Array{Float64,1}    ... Excitation rate coefficients in [cm^3/s] for the input temperatures\n+ effOmegas           ::Array{Float64,1}    ... Effective collision strengths for the input temperatures\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.ImpactExcitation.RateCoefficients-Tuple{}","page":"API Atomic processes","title":"JAC.ImpactExcitation.RateCoefficients","text":"ImpactExcitation.RateCoefficients()  ... constructor for the default values of electron-impact excitation rate coefficient or                                             effective collision strength computations.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.Settings","page":"API Atomic processes","title":"JAC.ImpactExcitation.Settings","text":"struct  ImpactExcitation.Settings  <:  AbstractProcessSettings  ... defines a type for the details and parameters of computing                                                                                                  electron-impact excitation lines.\n\n+ lineSelection            ::LineSelection      ... Specifies the selected levels, if any.\n+ electronEnergies         ::Array{Float64,1}   ... List of impact-energies of the incoming elecgtrons (in user-defined units).\n+ energyShift              ::Float64            ... An overall energy shift for all transitions |i> --> |f>.\n+ maxKappa                 ::Int64              ... Maximum kappa value of partial waves to be included.\n+ calcRateCoefficient      ::Bool               ... True, if the plasma rate coefficients to be calculated, false otherwise.\n+ maxEnergyMultiplier      ::Float64            ... Maximum initial electron energy for eff. collision strength integration.\n                                 (maxEnergyMultiplier * Excitation threshold energy), after this assymptotic limit is applied.\n+ numElectronEnergies      ::Int64              ... No. of different electron energy points at which collision strengths to compute\n                                                    in electron energy range [0, (maxEnergyMultiplier * Excitation threshold energy)]\n+ temperatures             ::Array{Float64, 1}  ... Electron temperatures [K] for eff. collision strengths and rate coefficients.\n+ printBefore              ::Bool               ... True, if all energies and lines are printed before their evaluation.\n+ operator                 ::AbstractEeInteraction   \n    ... Interaction operator that is to be used for evaluating the e-e interaction amplitudes; allowed values are: \n        CoulombInteraction(), BreitInteraction(), ...\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.ImpactExcitation.Settings-Tuple{JAC.ImpactExcitation.Settings}","page":"API Atomic processes","title":"JAC.ImpactExcitation.Settings","text":"ImpactExcitation.Settings(set::ImpactExcitation.Settings;\n\nlineSelection...,  electronEnergies..., energyShift..., maxKappa...,\ncalcRateCoefficient..., maxEnergyMultiplier..., numElectronEnergies..., temperatures...,\nprintBefore..., operator...)\n\n... constructor for modifying the given ImpactExcitation.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.Settings-Tuple{}","page":"API Atomic processes","title":"JAC.ImpactExcitation.Settings","text":"ImpactExcitation.Settings()  ... constructor for the default values of electron-impact excitation line computations.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.amplitude-Tuple{AbstractEeInteraction, JAC.ImpactExcitation.Channel, Level, Level, JAC.Radial.Grid}","page":"API Atomic processes","title":"JAC.ImpactExcitation.amplitude","text":"ImpactExcitation.amplitude(kind::AbstractEeInteraction, channel::ImpactExcitation.Channel, cFinalLevel::Level, cInitialLevel::Level,                              grid::Radial.Grid; printout::Bool=true)       ... to compute the kind in  CoulombInteraction(), BreitInteraction(), CoulombBreit() electron-impact interaction amplitude          <(alphaf Jf, kappaf) Jt || O^(e-e, kind) || (alphai Ji, kappai) Jt>  due to the interelectronic interaction for          the given final and initial (continuum) level. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.computeAmplitudesProperties-Tuple{JAC.ImpactExcitation.Line, Model, JAC.Radial.Grid, JAC.ImpactExcitation.Settings}","page":"API Atomic processes","title":"JAC.ImpactExcitation.computeAmplitudesProperties","text":"ImpactExcitation.computeAmplitudesProperties(line::ImpactExcitation.Line, nm::Nuclear.Model, grid::Radial.Grid,                                                  settings::ImpactExcitation.Settings; printout::Bool=true)       ... to compute all amplitudes and properties of the given line; a line::ImpactExcitation.Line is returned for which      the amplitudes and properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.computeEffStrengths-Tuple{Vector{JAC.ImpactExcitation.Line}, JAC.ImpactExcitation.Settings}","page":"API Atomic processes","title":"JAC.ImpactExcitation.computeEffStrengths","text":"ImpactExcitation.computeEffStrengths(lines::Array{ImpactExcitation.Line, 1}, settings::ImpactExcitation.Settings)     ... computes Effective collision strengths from the calculated line collision strengths at temperature(s) [K].         Returns an Array{ImpactExcitation.RateCoefficients,1}.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.computeLines-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.ImpactExcitation.Settings}","page":"API Atomic processes","title":"JAC.ImpactExcitation.computeLines","text":"ImpactExcitation.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                  settings::ImpactExcitation.Settings; output=true)       ... to compute the electron-impact excitation transition amplitudes and all properties as requested by the given settings.          A list of lines::Array{ImpactExcitation.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.computeRateCoefficients-Tuple{Vector{JAC.ImpactExcitation.Line}, JAC.ImpactExcitation.Settings}","page":"API Atomic processes","title":"JAC.ImpactExcitation.computeRateCoefficients","text":"ImpactExcitation.computeRateCoefficients(effStrengths::Vector{RateCoefficients}, settings::ImpactExcitation.Settings)     ... computes Exitation rate coefficients from the calculated collsion strengths at a temperature(s) [K].         The rate coefficients are returned in [cm^3/s]. Returns an Array{ImpactExcitation.RateCoefficients,1}.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.determineChannels-Tuple{Level, Level, JAC.ImpactExcitation.Settings}","page":"API Atomic processes","title":"JAC.ImpactExcitation.determineChannels","text":"ImpactExcitation.determineChannels(finalLevel::Level, initialLevel::Level, settings::ImpactExcitation.Settings)       ... to determine a list of electron-impact excitation Channels for a transitions from the initial to the final level and by          taking into account the particular settings of for this computation; an Array{ImpactExcitation.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.determineLines-Tuple{Multiplet, Multiplet, JAC.ImpactExcitation.Settings}","page":"API Atomic processes","title":"JAC.ImpactExcitation.determineLines","text":"ImpactExcitation.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::ImpactExcitation.Settings)       ... to determine a list of ImpactExcitation.Line's for transitions between levels from the initial- and final-state multiplets,          and by taking into account the particular selections and settings for this computation; an Array{ImpactExcitation.Line,1} is          returned. Apart from the level specification, all physical properties are set to zero during the initialization process.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.displayLines-Tuple{Vector{JAC.ImpactExcitation.Line}}","page":"API Atomic processes","title":"JAC.ImpactExcitation.displayLines","text":"ImpactExcitation.displayLines(lines::Array{ImpactExcitation.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all          selected transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.displayResults-Tuple{JAC.ImpactExcitation.Line}","page":"API Atomic processes","title":"JAC.ImpactExcitation.displayResults","text":"ImpactExcitation.displayResults(line::ImpactExcitation.Line)     ... to display energies, cross sections, collision stregths, convergence etc. for a single line immediatly after         the calculation for that line is completed.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.displayResults-Tuple{Vector{JAC.ImpactExcitation.Line}}","page":"API Atomic processes","title":"JAC.ImpactExcitation.displayResults","text":"ImpactExcitation.displayResults(lines::Array{ImpactExcitation.Line,1})       ... to list all results, energies, cross sections, etc. of the selected lines. A neat table is printed but nothing is          returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.displayResults-Tuple{Vector{JAC.ImpactExcitation.RateCoefficients}}","page":"API Atomic processes","title":"JAC.ImpactExcitation.displayResults","text":"ImpactExcitation.displayResults(allRates::Array{RateCoefficients,1})       ... to list the excitation rate coefficients and effective collision strengths for the selected lines at the selected temperatures.         A neat table is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.groupLines-Tuple{Vector{JAC.ImpactExcitation.Line}, JAC.ImpactExcitation.Settings}","page":"API Atomic processes","title":"JAC.ImpactExcitation.groupLines","text":"ImpactExcitation.groupLines(lines::Array{ImpactExcitation.Line,1}, settings::ImpactExcitation.Settings)     ... groups lines having the same initial and final level but different energies         returns an Array{Array{ImpactExcitation.Line,1},1}\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.groupLines-Tuple{Vector{JAC.ImpactExcitation.Line}}","page":"API Atomic processes","title":"JAC.ImpactExcitation.groupLines","text":"ImpactExcitation.groupLines(lines::Array{ImpactExcitation.Line,1})     ... groups lines having the same initial and final level but different energies         returns an Array{Array{ImpactExcitation.Line,1},1}\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.interpolateCS-Tuple{Float64, Vector{Float64}, Vector{Float64}, Bool}","page":"API Atomic processes","title":"JAC.ImpactExcitation.interpolateCS","text":"ImpactExcitation.interpolateCS(x::Float64, xa::Vector{Float64}, ya::Vector{Float64}, isE1Allowed::Bool)     ... interpolates the cross section or collision stregths for a given initial electron Energy         if the energy is beyond the upper bound then uses asymptotic approximation for extrapolation,         depending on the transition is E1 allowed or not.         Returns a Float64.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.ImpactExcitation.interpolateCS-Tuple{Float64, Vector{Float64}, Vector{Float64}}","page":"API Atomic processes","title":"JAC.ImpactExcitation.interpolateCS","text":"ImpactExcitation.interpolateCS(x::Float64, xa::Vector{Float64}, ya::Vector{Float64})     ... interpolates the cross section or collision stregths for a given initial electron Energy         returns a Float64.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#Photoemission","page":"API Atomic processes","title":"Photoemission","text":"","category":"section"},{"location":"api-processes.html","page":"API Atomic processes","title":"API Atomic processes","text":"Modules = [PhotoEmission]\nOrder   = [:type, :function]","category":"page"},{"location":"api-processes.html#JAC.PhotoEmission.Channel","page":"API Atomic processes","title":"JAC.PhotoEmission.Channel","text":"struct  PhotoEmission.Channel       ... defines a type for a single radiative emission/absorption channel that specifies the multipole, gauge and amplitude.\n\n+ multipole         ::EmMultipole        ... Multipole of the photon emission/absorption.\n+ gauge             ::EmGauge            ... Gauge for dealing with the (coupled) radiation field.\n+ amplitude         ::Complex{Float64}   ... Amplitude of this multiple channel.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoEmission.Line","page":"API Atomic processes","title":"JAC.PhotoEmission.Line","text":"struct  PhotoEmission.Line       ... defines a type for a radiative line that may include the definition of sublines and their corresponding amplitudes.\n\n+ initialLevel   ::Level               ... initial-(state) level\n+ finalLevel     ::Level               ... final-(state) level\n+ omega          ::Float64             ... Transition frequency of this line; can be shifted w.r.t. the level energies.\n+ photonRate     ::EmProperty          ... Total rate of this line.\n+ angularBeta    ::EmProperty          ... Angular beta_2 coefficient.\n+ hasSublines    ::Bool                ... Determines whether the sublines are defined in terms of their multipolarity, amplitude, or not.\n+ channels       ::Array{PhotoEmission.Channel,1}  ... List of radiative (photon) channels\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoEmission.Line-Tuple{Level, Level, Float64, JAC.Basics.EmProperty}","page":"API Atomic processes","title":"JAC.PhotoEmission.Line","text":"PhotoEmission.Line(initialLevel::Level, finalLevel::Level, photonRate::Float64)       ... constructor an radiative line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.Settings","page":"API Atomic processes","title":"JAC.PhotoEmission.Settings","text":"struct  PhotoEmission.Settings  <:  AbstractProcessSettings       ... defines a type for the details and parameters of computing radiative lines.\n\n+ multipoles              ::Array{EmMultipoles}     ... Specifies the (radiat. field) multipoles to be included.\n+ gauges                  ::Array{UseGauge}         ... Gauges to be included into the computations.\n+ calcAnisotropy          ::Bool                    ... True, if the anisotropy (structure) functions are to be \n                                                        calculated and false otherwise \n+ printBefore             ::Bool                    ... True, if all energies and lines are printed before comput.\n+ corePolarization        ::CorePolarization        ... Parametrization of the core-polarization potential/contribution.\n+ lineSelection           ::LineSelection           ... Specifies the selected levels, if any.\n+ photonEnergyShift       ::Float64                 ... An overall energy shift for all photon energies.\n+ mimimumPhotonEnergy     ::Float64                 ... minimum transition energy for which (photon) transitions \n                                                        are included into the computation.\n+ maximumPhotonEnergy     ::Float64                 ... maximum transition energy for which (photon) transitions \n                                                        are included.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoEmission.Settings-Tuple{JAC.PhotoEmission.Settings}","page":"API Atomic processes","title":"JAC.PhotoEmission.Settings","text":"PhotoEmission.Settings(set::PhotoEmission.Settings;\n\n    multipoles::=..,        gauges=..,                calcAnisotropy=..,          printBefore=..,\n    corePolarization=..,    lineSelection=..,         photonEnergyShift=..,       \n    mimimumPhotonEnergy=.., maximumPhotonEnergy=..) \n                \n... constructor for modifying the given PhotoEmission.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.Settings-Tuple{}","page":"API Atomic processes","title":"JAC.PhotoEmission.Settings","text":"PhotoEmission.Settings()  ... constructor for the default values of radiative line computations\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.amplitude-Tuple{String, CorePolarization, Float64, Level, Level, JAC.Radial.Grid}","page":"API Atomic processes","title":"JAC.PhotoEmission.amplitude","text":"+ (kind::String, cp::CorePolarization, omega::Float64, finalLevel::Level, initialLevel::Level, grid::Radial.Grid;          display::Bool=false, printout::Bool=false)           ... to compute the kind = E1 with core-polarization emission amplitude               <alphaf Jf || O^(E1, emission with core-polarization) || alphai Ji> in length gauge and for the given transition energy.             A value::ComplexF64 is returned. The amplitude value is printed to screen if display=true.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.amplitude-Tuple{String, EmMultipole, JAC.Basics.EmGauge, Float64, Level, Level, JAC.Radial.Grid}","page":"API Atomic processes","title":"JAC.PhotoEmission.amplitude","text":"PhotoEmission.amplitude(kind::String, Mp::EmMultipole, gauge::EmGauge, omega::Float64, finalLevel::Level, initialLevel::Level,                              grid::Radial.Grid; display::Bool=false, printout::Bool=false)       ... to compute the kind = (absorption or emission) amplitude  <alphaf Jf || O^(Mp, kind) || alphai Ji> for the          interaction with  photon of multipolarity Mp and for the given transition energy and gauge. A value::ComplexF64 is          returned. The amplitude value is printed to screen if display=true.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.computeAmplitudesProperties-Tuple{JAC.PhotoEmission.Line, JAC.Radial.Grid, JAC.PhotoEmission.Settings}","page":"API Atomic processes","title":"JAC.PhotoEmission.computeAmplitudesProperties","text":"PhotoEmission.computeAmplitudesProperties(line::PhotoEmission.Line, grid::Radial.Grid, settings::Einstein.Settings; printout::Bool=true)       ... to compute all amplitudes and properties of the given line; a line::Einstein.Line is returned for which the amplitudes and          properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.computeLines-Tuple{Multiplet, Multiplet, JAC.Radial.Grid, JAC.PhotoEmission.Settings}","page":"API Atomic processes","title":"JAC.PhotoEmission.computeLines","text":"PhotoEmission.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, grid::Radial.Grid, settings::PhotoEmission.Settings;                              output=true)       ... to compute the radiative transition amplitudes and all properties as requested by the given settings. A list of          lines::Array{PhotoEmission.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.computeLinesCascade-Tuple{Multiplet, Multiplet, JAC.Radial.Grid, JAC.PhotoEmission.Settings}","page":"API Atomic processes","title":"JAC.PhotoEmission.computeLinesCascade","text":"PhotoEmission.computeLinesCascade(finalMultiplet::Multiplet, initialMultiplet::Multiplet, grid::Radial.Grid,                                      settings::PhotoEmission.Settings; output::Bool=true, printout::Bool=true)       ... to compute the radiative transition amplitudes and all properties as requested by the given settings. The computations         and printout is adapted for larger cascade computations by including only lines with at least one channel and by sending         all printout to a summary file only. A list of lines::Array{PhotoEmission.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.determineChannels-Tuple{Level, Level, JAC.PhotoEmission.Settings}","page":"API Atomic processes","title":"JAC.PhotoEmission.determineChannels","text":"PhotoEmission.determineChannels(finalLevel::Level, initialLevel::Level, settings::PhotoEmission.Settings)       ... to determine a list of PhotoEmission.Channel for a transitions from the initial to final level and by taking into          account the particular settings of for this computation; an Array{PhotoEmission.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.determineLines-Tuple{Multiplet, Multiplet, JAC.PhotoEmission.Settings}","page":"API Atomic processes","title":"JAC.PhotoEmission.determineLines","text":"PhotoEmission.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::PhotoEmission.Settings)       ... to determine a list of PhotoEmission Line's for transitions between the levels from the given initial- and          final-state multiplets and by taking into account the particular selections and settings for this computation;          an Array{PhotoEmission.Line,1} is returned. Apart from the level specification, all physical properties are set          to zero during the initialization process.  \n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.displayAnisotropies-Tuple{IO, Vector{JAC.PhotoEmission.Line}, JAC.PhotoEmission.Settings}","page":"API Atomic processes","title":"JAC.PhotoEmission.displayAnisotropies","text":"PhotoEmission.displayAnisotropies(stream::IO, lines::Array{PhotoEmission.Line,1}, settings::PhotoEmission.Settings)       ... to list all energies and anisotropy parameters of the selected lines. A neat table is printed but nothing is          returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.displayLifetimes-Tuple{IO, Vector{JAC.PhotoEmission.Line}, JAC.PhotoEmission.Settings}","page":"API Atomic processes","title":"JAC.PhotoEmission.displayLifetimes","text":"PhotoEmission.displayLifetimes(stream::IO, lines::Array{PhotoEmission.Line,1}, settings::PhotoEmission.Settings)       ... to list all lifetimes as derived from the selected lines. A neat table is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.displayLines-Tuple{IO, Vector{JAC.PhotoEmission.Line}}","page":"API Atomic processes","title":"JAC.PhotoEmission.displayLines","text":"PhotoEmission.displayLines(stream::IO, lines::Array{PhotoEmission.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all          selected transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoEmission.displayRates-Tuple{IO, Vector{JAC.PhotoEmission.Line}, JAC.PhotoEmission.Settings}","page":"API Atomic processes","title":"JAC.PhotoEmission.displayRates","text":"PhotoEmission.displayRates(stream::IO, lines::Array{PhotoEmission.Line,1}, settings::PhotoEmission.Settings)       ... to list all results, energies, rates, etc. of the selected lines. A neat table is printed but nothing is          returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#Photoexcitation","page":"API Atomic processes","title":"Photoexcitation","text":"","category":"section"},{"location":"api-processes.html","page":"API Atomic processes","title":"API Atomic processes","text":"Modules = [PhotoExcitation]\nOrder   = [:type, :function]","category":"page"},{"location":"api-processes.html#JAC.PhotoExcitation.Line","page":"API Atomic processes","title":"JAC.PhotoExcitation.Line","text":"struct  PhotoExcitation.Line       ... defines a type for a photo-excitation line that may include the definition of sublines and their          corresponding amplitudes.\n\n+ initialLevel   ::Level                       ... initial-(state) level\n+ finalLevel     ::Level                       ... final-(state) level\n+ omega          ::Float64                     ... Transition frequency of this line; can be shifted w.r.t. the level energies.\n+ oscStrength    ::EmProperty                  ... Absorption oscillator strength\n+ crossSection   ::EmProperty                  ... Total cross section of this line.\n+ staTensor      ::Array{TensorComp,1}         ... Array of statistical tensor components rho_kq\n+ hasSublines    ::Bool                        ... Determines whether the individual sublines are defined in terms of their \n                                                    multipolarity, amplitude, or not; cf. PhotoEmission.Channel\n+ channels       ::Array{PhotoEmission.Channel,1}  ... List of radiative (photon) channels\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoExcitation.Line-Tuple{Level, Level, Float64, JAC.Basics.EmProperty}","page":"API Atomic processes","title":"JAC.PhotoExcitation.Line","text":"PhotoExcitation.Line(initialLevel::Level, finalLevel::Level, omega::Float64, crossSection::EmProperty)       ... constructor an photo-excitation line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.Settings","page":"API Atomic processes","title":"JAC.PhotoExcitation.Settings","text":"struct  PhotoExcitation.Settings  <:  AbstractProcessSettings  ... defines a type for the details and parameters of computing photo-excitation  lines.\n\n+ multipoles              ::Array{EmMultipole,1}    ... Specifies the multipoles of the radiation field that are to be included.\n+ gauges                  ::Array{UseGauge,1}       ... Specifies the gauges to be included into the computations.\n+ calcForStokes           ::Bool                    ... True, if the excitation cross sections are to be calculated (and false otherwise)\n                                                        for given Stokes parameter of the incident plane-wave photons.\n+ calcPhotonDm            ::Bool                    ... True, if the photon density matrix of a subsequently emitted fluorescence photon \n                                                        is to be calculated and false otherwise. \n+ calcTensors             ::Bool                    ... True, if statistical tensors of the excited atom are to be calculated, false otherwise. \n+ printBefore             ::Bool                    ... True, if all energies and lines are printed before their evaluation.\n+ lineSelection           ::LineSelection           ... Specifies the selected levels, if any.\n+ photonEnergyShift       ::Float64                 ... An overall energy shift for all photon energies.\n+ mimimumPhotonEnergy     ::Float64                 ... minimum transition energy for which (photon) transitions are included into the\n                                                        computation.\n+ maximumPhotonEnergy     ::Float64                 ... maximum transition energy for which (photon) transitions are included.\n+ stokes                  ::ExpStokes               ... Stokes parameters of the incident radiation.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoExcitation.Settings-Tuple{JAC.PhotoExcitation.Settings}","page":"API Atomic processes","title":"JAC.PhotoExcitation.Settings","text":"PhotoExcitation.Settings(set::PhotoExcitation.Settings;\n\n    multipoles=..,          gauges=..,                  calcForStokes=..,           calcPhotonDm=..,    \n    calcTensors=..,         printBefore=..,             lineSelection=..,    \n    photonEnergyShift=..,   mimimumPhotonEnergy=..,     maximumPhotonEnergy=..,     stokes=..)\n                \n... constructor for modifying the given PhotoExcitation.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.Settings-Tuple{}","page":"API Atomic processes","title":"JAC.PhotoExcitation.Settings","text":"PhotoExcitation.Settings()  ... 'empty' constructor for the default values of photo-excitation line computations\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.computeAmplitudesProperties-Tuple{JAC.PhotoExcitation.Line, JAC.Radial.Grid, JAC.PhotoExcitation.Settings}","page":"API Atomic processes","title":"JAC.PhotoExcitation.computeAmplitudesProperties","text":"PhotoExcitation.computeAmplitudesProperties(line::PhotoExcitation.Line, grid::Radial.Grid, settings::PhotoExcitation.Settings; printout::Bool=true)       ... to compute all amplitudes and properties of the given line; a line::PhotoExcitation.Line is returned for which          the amplitudes and properties have now been evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.computeCrossSection-Tuple{JAC.PhotoExcitation.Line, ExpStokes}","page":"API Atomic processes","title":"JAC.PhotoExcitation.computeCrossSection","text":"PhotoExcitation.computeCrossSection(line::PhotoExcitation.Line, stokes::ExpStokes)       ... to compute the excitation cross section for the excitation of unpolarized atoms by plane-wave photons, whose polarization          is described by the given (experimental) Stokes parameters. A cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.computeLines-Tuple{Multiplet, Multiplet, JAC.Radial.Grid, JAC.PhotoExcitation.Settings}","page":"API Atomic processes","title":"JAC.PhotoExcitation.computeLines","text":"PhotoExcitation.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, grid::Radial.Grid,                                      settings::PhotoExcitation.Settings; output=true)       ... to compute the photo-excitation amplitudes and all properties as requested by the given settings. A list          of lines::Array{PhotoExcitation.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.computeLinesCascade-Tuple{Multiplet, Multiplet, JAC.Radial.Grid, JAC.PhotoExcitation.Settings, LevelSelection}","page":"API Atomic processes","title":"JAC.PhotoExcitation.computeLinesCascade","text":"PhotoExcitation.computeLinesCascade(finalMultiplet::Multiplet, initialMultiplet::Multiplet, grid::Radial.Grid,                                       settings::PhotoExcitation.Settings, initialLevelSelection::LevelSelection;                                       output::Bool=true, printout::Bool=true)       ... to compute the excitation (absorption) transition amplitudes and all properties as requested by the given settings.          The computations and printout is adapted for larger cascade computations by including only lines with at least one channel          and by sending all printout to a summary file only. A list of lines::Array{PhotoExcitation.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.computeStatisticalTensor-Tuple{Int64, Int64, JAC.PhotoExcitation.Line, ExpStokes}","page":"API Atomic processes","title":"JAC.PhotoExcitation.computeStatisticalTensor","text":"PhotoExcitation.computeStatisticalTensor(k::Int64, q::Int64, line::PhotoExcitation.Line, stokes::ExpStokes)       ... to compute the statistical tensor (component) rho{k,q} of the final level for the excitation of unpolarized atoms by          plane-wave photons, whose polarization is described by the given (experimental) Stokes parameters.          A rhokq::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.determineChannels-Tuple{Level, Level, JAC.PhotoExcitation.Settings}","page":"API Atomic processes","title":"JAC.PhotoExcitation.determineChannels","text":"PhotoExcitation.determineChannels(finalLevel::Level, initialLevel::Level, settings::PhotoExcitation.Settings)       ... to determine a list of PhotoExcitation.Channel for a transitions from the initial to final level and by taking          into account the particular settings of for this computation; an Array{PhotoExcitation.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.determineLines-Tuple{Multiplet, Multiplet, JAC.PhotoExcitation.Settings}","page":"API Atomic processes","title":"JAC.PhotoExcitation.determineLines","text":"PhotoExcitation.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::PhotoExcitation.Settings)       ... to determine a list of photo-excitation Line's for transitions between the levels from the given initial- and          final-state multiplets and by taking into account the particular selections and settings for this computation;          an Array{PhotoExcitation.Line,1} is returned. Apart from the level specification, all physical properties are set to          zero during the initialization process.  \n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.displayCrossSections-Tuple{IO, Vector{JAC.PhotoExcitation.Line}, JAC.PhotoExcitation.Settings}","page":"API Atomic processes","title":"JAC.PhotoExcitation.displayCrossSections","text":"PhotoExcitation.displayCrossSections(stream::IO, lines::Array{PhotoExcitation.Line,1}, settings::PhotoExcitation.Settings)       ... to list all results, energies, cross sections, etc. of the selected lines. A neat table is printed but nothing          is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.displayLineData-Tuple{IO, Vector{JAC.PhotoExcitation.Line}}","page":"API Atomic processes","title":"JAC.PhotoExcitation.displayLineData","text":"PhotoExcitation.displayLineData(stream::IO, lines::Array{PhotoExcitation.Line,1})       ... to display the calculated data, ordered by the initial levels and the photon energies involved.         Neat tables of all initial levels and photon energies as well as all associated total cross sections are printed         but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.displayLines-Tuple{IO, Vector{JAC.PhotoExcitation.Line}}","page":"API Atomic processes","title":"JAC.PhotoExcitation.displayLines","text":"PhotoExcitation.displayLines(stream::IO, lines::Array{PhotoExcitation.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all          selected transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoExcitation.estimateCrossSection-Tuple{Vector{JAC.PhotoExcitation.Line}, Float64, Float64, Any}","page":"API Atomic processes","title":"JAC.PhotoExcitation.estimateCrossSection","text":"PhotoExcitation.estimateCrossSection(lines::Array{PhotoExcitation.Line,1}, omega::Float64, gamma::Float64, initialLevel)       ... to estimate from lines the total PE cross section for any omega and for initial level.          The procedure assumes a Gaussian line shape for each PhotoExcitation.Line with widths gamma and distributes         the (total cross section according to the line shape within [Er - 10*gamma, Er + 10*gamma].         Other line shapes can be readily implemented; a cross section cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#Photoionization","page":"API Atomic processes","title":"Photoionization","text":"","category":"section"},{"location":"api-processes.html","page":"API Atomic processes","title":"API Atomic processes","text":"Modules = [PhotoIonization]\nOrder   = [:type, :function]","category":"page"},{"location":"api-processes.html#JAC.PhotoIonization.Channel","page":"API Atomic processes","title":"JAC.PhotoIonization.Channel","text":"struct  PhotoIonization.Channel       ... defines a type for a photoionization channel to help characterize a single multipole and scattering (continuum) state          of many electron-states with a single free electron.\n\n+ multipole      ::EmMultipole          ... Multipole of the photon absorption.\n+ gauge          ::EmGauge              ... Gauge for dealing with the (coupled) radiation field.\n+ kappa          ::Int64                ... partial-wave of the free electron\n+ symmetry       ::LevelSymmetry        ... total angular momentum and parity of the scattering state\n+ phase          ::Float64              ... phase of the partial wave\n+ amplitude      ::Complex{Float64}     ... Photoionization amplitude associated with the given channel.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoIonization.Line","page":"API Atomic processes","title":"JAC.PhotoIonization.Line","text":"struct  Line  ... defines a type for a photoionization line that may include the definition of channels.\n\n+ initialLevel   ::Level                  ... initial-(state) level\n+ finalLevel     ::Level                  ... final-(state) level\n+ electronEnergy ::Float64                ... Energy of the (outgoing free) electron.\n+ photonEnergy   ::Float64                ... Energy of the absorbed photon.\n+ crossSection   ::EmProperty             ... Cross section for this photoionization.\n+ angularBeta    ::EmProperty             ... beta -parameter for unpolarized targets with J=0, 1/2, 1\n+ coherentDelay  ::EmProperty             ... coherent time-delay due to the selected averaging of phases.\n+ incoherentDelay::EmProperty             ... incoherent time-delay due to the selected averaging of phases.\n+ channels       ::Array{PhotoIonization.Channel,1}  ... List of PhotoIonization.Channels of this line.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoIonization.Line-Tuple{Level, Level, JAC.Basics.EmProperty}","page":"API Atomic processes","title":"JAC.PhotoIonization.Line","text":"PhotoIonization.Line(initialLevel::Level, finalLevel::Level, crossSection::Float64)       ... constructor for an photoionization line between a specified initial and final level.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.PlasmaSettings","page":"API Atomic processes","title":"JAC.PhotoIonization.PlasmaSettings","text":"struct  PhotoIonization.PlasmaSettings  <:  Basics.AbstractLineShiftSettings       ... defines a type for the details and parameters of computing photoionization rates with plasma interactions.\n\n+ multipoles             ::Array{Basics.EmMultipole}     ... Specifies the multipoles of the radiation field that are to be included.\n+ gauges                 ::Array{Basics.UseGauge}        ... Specifies the gauges to be included into the computations.\n+ photonEnergies         ::Array{Float64,1}              ... List of photon energies.  \n+ printBefore            ::Bool                          ... True, if all energies and lines are printed before their evaluation.\n+ lineSelection          ::LineSelection                 ... Specifies the selected levels, if any.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoIonization.PlasmaSettings-Tuple{}","page":"API Atomic processes","title":"JAC.PhotoIonization.PlasmaSettings","text":"PhotoIonization.PlasmaSettings()  ... constructor for a standard instance of PhotoIonization.PlasmaSettings.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.Settings","page":"API Atomic processes","title":"JAC.PhotoIonization.Settings","text":"struct  PhotoIonization.Settings  <:  AbstractProcessSettings  ... defines a type for the details and parameters of computing photoionization lines.\n\n+ multipoles                    ::Array{EmMultipole}  ... Specifies the multipoles of the radiation field that are to be included.\n+ gauges                        ::Array{UseGauge}     ... Specifies the gauges to be included into the computations.\n+ photonEnergies                ::Array{Float64,1}    ... List of photon energies [in user-selected units].  \n+ electronEnergies              ::Array{Float64,1}    ... List of electron energies; usually only one of these lists are utilized. \n+ thetas                        ::Array{Float64,1}    ... List of theta-values if angle-differential CS are calculated explicitly. \n+ calcAnisotropy                ::Bool                ... True, if the beta anisotropy parameters are to be calculated and false otherwise (o/w). \n+ calcPartialCs                 ::Bool                ... True, if partial cross sections are to be calculated and false otherwise.  \n+ calcTimeDelay                 ::Bool                ... True, if time-delays are to be calculated and false otherwise.  \n+ calcNonE1AngleDifferentialCS  ::Bool                ... True, if non-E1 angle-differential CS are be calculated and false otherwise.  \n+ calcTensors                   ::Bool                ... True, if statistical tensors of the excited atom are to be calculated and false o/w. \n+ printBefore                   ::Bool                ... True, if all energies and lines are printed before their evaluation.\n+ lineSelection                 ::LineSelection       ... Specifies the selected levels, if any.\n+ stokes                        ::ExpStokes           ... Stokes parameters of the incident radiation.\n+ freeElectronShift             ::Float64             ... An overall energy shift of all free-electron energies [user-specified units].\n+ lValues                       ::Array{Int64,1}      ... Orbital angular momentum of free-electrons, for which partial waves are considered.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoIonization.Settings-Tuple{JAC.PhotoIonization.Settings}","page":"API Atomic processes","title":"JAC.PhotoIonization.Settings","text":"PhotoIonization.Settings(set::PhotoIonization.Settings;\n\n    multipoles=..,                      gauges=..,                  photonEnergies=..,          electronEnergies=..,     \n    thetas=..,                          calcAnisotropy=..,          calcPartialCs..,            calcTimeDelay=..,           \n    calcNonE1AngleDifferentialCS=..,    calcTensors=..,             printBefore=..,             lineSelection=..,           \n    stokes=..,                          freeElectronShift=..,       lValues=.. )\n                \n... constructor for modifying the given PhotoIonization.Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.Settings-Tuple{}","page":"API Atomic processes","title":"JAC.PhotoIonization.Settings","text":"PhotoIonization.Settings()  ... constructor for the default values of photoionization line computations\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.amplitude-Tuple{String, JAC.PhotoIonization.Channel, Float64, Level, Level, JAC.Radial.Grid}","page":"API Atomic processes","title":"JAC.PhotoIonization.amplitude","text":"PhotoIonization.amplitude(kind::String, channel::PhotoIonization.Channel, omega::Float64, continuumLevel::Level,                                  initialLevel::Level, grid::Radial.Grid)       ... to compute the kind = (photoionization) amplitude  <(alphaf Jf, epsilon kappa) Jt || O^(photoionization) || alphai J_i>           due to the electron-photon interaction for the given final and initial level, the partial wave of the outgoing          electron as well as the given multipole and gauge. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.angularFunctionK-Tuple{Int64, Int64, Int64, AngularJ64, AngularJ64, Int64, AngularJ64, Int64, AngularJ64}","page":"API Atomic processes","title":"JAC.PhotoIonization.angularFunctionK","text":"PhotoIonization.angularFunctionK(L1::Int64, L2::Int64, X::Int64, Ji::AngularJ64, Jf::AngularJ64,                                    kappa1::Int64, J1::AngularJ64, kappa2::Int64, J2::AngularJ64)       ... to compute angular function K(...) as defined for the non-E1 angle-differential cross sections by         Nishita Hosea (2025). No tests are made that the triangular conditions of the quantum numbers         are fulfilled. A wa::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.angularFunctionW-Tuple{Float64, Int64, Int64, Int64, Int64, Int64, Int64, Rational{Int64}, Int64, Rational{Int64}}","page":"API Atomic processes","title":"JAC.PhotoIonization.angularFunctionW","text":"PhotoIonization.angularFunctionW(theta::Float64, L1::Int64, L2::Int64, X::Int64, lambda1::Int64, lambda2::Int64,                                   kappa1::Int64, mu1::Rational{Int64}, kappa2::Int64, mu2::Rational{Int64})       ... to compute angular function W(theta; ...) as defined for the non-E1 angle-differential cross sections by         Nishita Hosea (2025). No tests are made that the triangular conditions of the quantum numbers         are fulfilled. A  wa::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.computeAmplitudesProperties-Tuple{JAC.PhotoIonization.Line, Model, JAC.Radial.Grid, Int64, JAC.PhotoIonization.Settings}","page":"API Atomic processes","title":"JAC.PhotoIonization.computeAmplitudesProperties","text":"PhotoIonization.computeAmplitudesProperties(line::PhotoIonization.Line, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,                                                      settings::PhotoIonization.Settings; printout::Bool=false)       ... to compute all amplitudes and properties of the given line; a line::PhotoIonization.Line is returned for which the amplitudes and          properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.computeAmplitudesPropertiesPlasma-Tuple{JAC.PhotoIonization.Line, Model, JAC.Radial.Grid, JAC.PhotoIonization.PlasmaSettings}","page":"API Atomic processes","title":"JAC.PhotoIonization.computeAmplitudesPropertiesPlasma","text":"PhotoIonization.computeAmplitudesPropertiesPlasma(line::PhotoIonization.Line, nm::Nuclear.Model, grid::Radial.Grid,                                                     settings::PhotoIonization.PlasmaSettings)       ... to compute all amplitudes and properties of the given line but for the given plasma model;          a line::PhotoIonization.Line is returned for which the amplitudes and properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.computeAngularBeta-Tuple{Level, Level, Vector{JAC.PhotoIonization.Channel}}","page":"API Atomic processes","title":"JAC.PhotoIonization.computeAngularBeta","text":"PhotoIonization.computeAngularBeta(iLevel::Level, fLevel::Level, channels::Array{PhotoIonization.Channel,1})       ... to compute the beta anisotropy parameter for the photoionization transition i -> f with the given channels;         here, the formula from Balashov (1994, Eq. 2.135) has been utilized. A beta::EmProperty parameter is returned.         These (gauge-dependent) beta parameters are set to -9., if no amplitudes are calculated for the given gauge.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.computeDisplayNonE1AngleDifferentialCS-Tuple{IO, Vector{JAC.PhotoIonization.Line}, JAC.PhotoIonization.Settings}","page":"API Atomic processes","title":"JAC.PhotoIonization.computeDisplayNonE1AngleDifferentialCS","text":"PhotoIonization.computeDisplayNonE1AngleDifferentialCS(stream::IO, lines::Array{PhotoIonization.Line,1},                                                          settings::PhotoIonization.Settings)       ... to compute & display the non-E1 angle-differential photoionization cross sections for all PhotoIonization.Line's          and at all angles theta as defined in the settings. The general formula by Nishita Hosea (2025) is applied here.         A neat table is printed for each line but nothing is returned otherwise. \n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.computeLines-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.PhotoIonization.Settings}","page":"API Atomic processes","title":"JAC.PhotoIonization.computeLines","text":"PhotoIonization.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                      settings::PhotoIonization.Settings; output::Bool=true)       ... to compute the photoIonization transition amplitudes and all properties as requested by the given settings.          A list of lines::Array{PhotoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.computeLinesCascade-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.PhotoIonization.Settings, LevelSelection}","page":"API Atomic processes","title":"JAC.PhotoIonization.computeLinesCascade","text":"PhotoIonization.computeLinesCascade(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                       settings::PhotoIonization.Settings, initialLevelSelection::LevelSelection;                                       output=true, printout::Bool=true)       ... to compute the photoionization transition amplitudes and all properties as requested by the given settings. The computations         and printout is adapted for large cascade computations by including only lines with at least one channel and by sending         all printout to a summary file only. A list of lines::Array{PhotoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.computeLinesPlasma-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.PhotoIonization.PlasmaSettings}","page":"API Atomic processes","title":"JAC.PhotoIonization.computeLinesPlasma","text":"PhotoIonization.computeLinesPlasma(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                      settings::PhotoIonization.PlasmaSettings; output::Bool=true)       ... to compute the photoIonization transition amplitudes and all properties as requested by the given settings.          A list of lines::Array{PhotoIonization.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.computePartialCrossSectionUnpolarized-Tuple{JAC.Basics.EmGauge, AngularM64, JAC.PhotoIonization.Line}","page":"API Atomic processes","title":"JAC.PhotoIonization.computePartialCrossSectionUnpolarized","text":"PhotoIonization.computePartialCrossSectionUnpolarized(gauge::EmGauge, Mf::AngularM64, line::PhotoIonization.Line)       ... to compute the partial photoionization cross section for initially unpolarized atoms by unpolarized plane-wave photons.         A value::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.computeStatisticalTensorUnpolarized-Tuple{Int64, Int64, JAC.Basics.EmGauge, JAC.PhotoIonization.Line, JAC.PhotoIonization.Settings}","page":"API Atomic processes","title":"JAC.PhotoIonization.computeStatisticalTensorUnpolarized","text":"PhotoIonization.computeStatisticalTensorUnpolarized(k::Int64, q::Int64, gauge::EmGauge, line::PhotoIonization.Line,                                                              settings::PhotoIonization.Settings)       ... to compute the statistical tensor of the photoion in its final level after the photoionization of initially unpolarized atoms          by plane-wave photons with given Stokes parameters (density matrix). A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.computeTimeDelays-Tuple{Vector{JAC.PhotoIonization.Channel}, Vector{JAC.PhotoIonization.Channel}, Float64, AngularJ64}","page":"API Atomic processes","title":"JAC.PhotoIonization.computeTimeDelays","text":"PhotoIonization.computeTimeDelays(channels::Array{PhotoIonization.Channel,1}, xchannels::Array{PhotoIonization.Channel,1},                                      deltaE::Float64, Jf::AngularJ64)       ... to compute the – coherent and incoherent – time delay from the channels as calculated for two neighboured photon          energies (deltaE = xE - E). Two tuple of two time delays (coherentDelay::EmProperty, incoherentDelay::EmProperty)         is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.determineChannels-Tuple{Level, Level, JAC.PhotoIonization.Settings}","page":"API Atomic processes","title":"JAC.PhotoIonization.determineChannels","text":"PhotoIonization.determineChannels(finalLevel::Level, initialLevel::Level, settings::PhotoIonization.Settings)       ... to determine a list of photoionization Channel for a transitions from the initial to final level and by taking into account          the particular settings of for this computation; an Array{PhotoIonization.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.determineLines-Tuple{Multiplet, Multiplet, JAC.PhotoIonization.Settings}","page":"API Atomic processes","title":"JAC.PhotoIonization.determineLines","text":"PhotoIonization.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::PhotoIonization.Settings)       ... to determine a list of PhotoIonization.Line's for transitions between levels from the initial- and final-state multiplets,          and  by taking into account the particular selections and settings for this computation; an Array{PhotoIonization.Line,1}          is returned. Apart from the level specification, all physical properties are set to zero during the initialization process.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.displayLineData-Tuple{IO, Vector{JAC.PhotoIonization.Line}}","page":"API Atomic processes","title":"JAC.PhotoIonization.displayLineData","text":"PhotoIonization.displayLineData(stream::IO, lines::Array{PhotoIonization.Line,1})       ... to display the calculated data, ordered by the initial levels and the photon energies involved.         Neat tables of all initial levels and photon energies as well as all associated cross sections are printed         but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.displayLines-Tuple{IO, Vector{JAC.PhotoIonization.Line}}","page":"API Atomic processes","title":"JAC.PhotoIonization.displayLines","text":"PhotoIonization.displayLines(stream::IO, lines::Array{PhotoIonization.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all selected          transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.displayPhases-Tuple{Vector{JAC.PhotoIonization.Line}}","page":"API Atomic processes","title":"JAC.PhotoIonization.displayPhases","text":"PhotoIonization.displayPhases(lines::Array{PhotoIonization.Line,1})       ... to display a list of lines, channels and phases of the continuum wave that have been selected due to the prior settings.         A neat table of all selected transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.displayResults-Tuple{IO, Vector{JAC.PhotoIonization.Line}, JAC.PhotoIonization.Settings}","page":"API Atomic processes","title":"JAC.PhotoIonization.displayResults","text":"PhotoIonization.displayResults(stream::IO, lines::Array{PhotoIonization.Line,1}, settings::PhotoIonization.Settings)       ... to list all results, energies, cross sections, etc. of the selected lines. A neat table is printed but nothing          is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.extractCrossSection-Tuple{Vector{JAC.PhotoIonization.Line}, Float64, Any}","page":"API Atomic processes","title":"JAC.PhotoIonization.extractCrossSection","text":"PhotoIonization.extractCrossSection(lines::Array{PhotoIonization.Line,1}, omega::Float64, initialLevel)       ... to extract from lines the total PI cross section that refer to the given omega and initial level;         a cross section cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.extractCrossSection-Tuple{Vector{JAC.PhotoIonization.Line}, Float64, Shell, Any}","page":"API Atomic processes","title":"JAC.PhotoIonization.extractCrossSection","text":"PhotoIonization.extractCrossSection(lines::Array{PhotoIonization.Line,1}, omega::Float64, shell::Shell, initialLevel)       ... to extract from lines the total PI cross section that refer to the given omega and initial level and to          to the ionization of an electron from shell; a cross section cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.extractLines-Tuple{Vector{JAC.PhotoIonization.Line}, Float64}","page":"API Atomic processes","title":"JAC.PhotoIonization.extractLines","text":"PhotoIonization.extractLines(lines::Array{PhotoIonization.Line,1}, omega::Float64)       ... to extract from lines all those that refer to the given omega;         a reduced list rLines::Array{PhotoIonization.Line,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.extractPhotonEnergies-Tuple{Vector{JAC.PhotoIonization.Line}}","page":"API Atomic processes","title":"JAC.PhotoIonization.extractPhotonEnergies","text":"PhotoIonization.extractPhotonEnergies(lines::Array{PhotoIonization.Line,1})       ... to extract all photon energies for which photoionization data and cross sections are provided by lines;         an list of energies::Array{Float64,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.getLineKappas-Tuple{JAC.PhotoIonization.Line}","page":"API Atomic processes","title":"JAC.PhotoIonization.getLineKappas","text":"PhotoIonization.getLineKappas(line::PhotoIonization.Line)       ... returns a list of kappa-values (partial waves) which contribute to the given line, to which one or several channels are          assigned. An kappaList::Array{Int64,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoIonization.interpolateCrossSection-Tuple{Vector{JAC.PhotoIonization.Line}, Float64, Any}","page":"API Atomic processes","title":"JAC.PhotoIonization.interpolateCrossSection","text":"PhotoIonization.interpolateCrossSection(lines::Array{PhotoIonization.Line,1}, omega::Float64, initialLevel)       ... to interpolate (or extrapolate) from lines the total PI cross section for any given omega and          initial level. The procedure applies a linear interpolation/extrapolation by just using the          cross sections from the two nearest (given) omega points; a cross section cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#Photorecombination","page":"API Atomic processes","title":"Photorecombination","text":"","category":"section"},{"location":"api-processes.html","page":"API Atomic processes","title":"API Atomic processes","text":"Modules = [PhotoRecombination]\nOrder   = [:type, :function]","category":"page"},{"location":"api-processes.html#JAC.PhotoRecombination.Channel","page":"API Atomic processes","title":"JAC.PhotoRecombination.Channel","text":"struct  PhotoRecombination.Channel       ... defines a type for a photorecombination channel to help characterize a single multipole and scattering          (continuum) state of many electron-states with a single free electron.\n\n+ multipole      ::EmMultipole          ... Multipole of the photon emission/absorption.\n+ gauge          ::EmGauge              ... Gauge for dealing with the (coupled) radiation field.\n+ kappa          ::Int64                ... partial-wave of the free electron\n+ symmetry       ::LevelSymmetry        ... total angular momentum and parity of the scattering state\n+ phase          ::Float64              ... phase of the partial wave\n+ amplitude      ::Complex{Float64}     ... Rec amplitude associated with the given channel.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoRecombination.Line","page":"API Atomic processes","title":"JAC.PhotoRecombination.Line","text":"struct  PhotoRecombination.Line       ... defines a type for a Photorecombination line that may include the definition of channels.\n\n+ initialLevel   ::Level                  ... initial-(state) level\n+ finalLevel     ::Level                  ... final-(state) level\n+ electronEnergy ::Float64                ... Energy of the (incoming free) electron.\n+ photonEnergy   ::Float64                ... Energy of the emitted photon.\n+ betaGamma2     ::Float64                ... beta^2 * gamma^2.\n+ weight         ::Float64                ... weight of line in the integration over electron energies.\n+ crossSection   ::EmProperty             ... Cross section for this electron capture.\n+ channels       ::Array{PhotoRecombination.Channel,1}    ... List of photorecombination channels of this line.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoRecombination.Line-Tuple{Level, Level}","page":"API Atomic processes","title":"JAC.PhotoRecombination.Line","text":"PhotoRecombination.Line()       ... constructor for an empty instance of a photorecombination line between a specified initial          and final level.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.Settings","page":"API Atomic processes","title":"JAC.PhotoRecombination.Settings","text":"struct  PhotoRecombination.Settings  <:  AbstractProcessSettings ... defines a type for the details and parameters of computing photo recombination lines.\n\n+ multipoles          ::Array{EmMultipole}  ... Multipoles of the radiation field that are to be included.\n+ gauges              ::Array{UseGauge}     ... Gauges to be included into the computations.\n+ electronEnergies    ::Array{Float64,1}    ... List of electron energies [in default units].\n+ ionEnergies         ::Array{Float64,1}    ... List of ion energies [in MeV/u].\n+ useIonEnergies      ::Bool                ... Make use of ion energies in [MeV/u] to obtain the electron energies.\n+ calcTotalCs         ::Bool                ... True, if the total cross sections is to be calculated/displayed for all initial levels.\n+ calcAnisotropy      ::Bool                ... True, if the overall anisotropy is to be calculated.\n+ calcTensors         ::Bool                ... True, if the statistical tensors are to be calculated and \n                                                false otherwise.\n+ printBefore         ::Bool                ... True, if all energies and lines are printed before their evaluation.\n+ maxKappa            ::Int64               ... Maximum kappa value of partial waves to be included.\n+ lineSelection       ::LineSelection       ... Specifies the selected levels, if any.\n\n\n\n\n\n","category":"type"},{"location":"api-processes.html#JAC.PhotoRecombination.Settings-Tuple{JAC.PhotoRecombination.Settings}","page":"API Atomic processes","title":"JAC.PhotoRecombination.Settings","text":"PhotoRecombination.Settings(set::PhotoRecombination..Settings;\n\n    multipoles=..,          gauges=..,              electronEnergies=..,          ionEnergies=..,     \n    useIonEnergies=..,      calcTotalCs..,          calcAnisotropy=..,            calcTensors=..,             \n    printBefore=..,         maxKappa=..,            lineSelection=..)\n                \n... constructor for modifying the given PhotoRecombination..Settings by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.Settings-Tuple{}","page":"API Atomic processes","title":"JAC.PhotoRecombination.Settings","text":"PhotoRecombination.Settings()  ... constructor for the default values of photo recombination line computations\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.amplitude-Tuple{String, JAC.PhotoRecombination.Channel, Float64, Level, Level, JAC.Radial.Grid}","page":"API Atomic processes","title":"JAC.PhotoRecombination.amplitude","text":"PhotoRecombination.amplitude(kind::String, channel::PhotoRecombination.Channel, energy::Float64, finalLevel::Level,                                  continuumLevel::Level, grid::Radial.Grid)       ... to compute the kind = (photorecombination) amplitude           < alphaf Jf || O^(photorecombination) || (alphai Ji, epsilon kappa) J_t>  due to the electron-photon          interaction for the given final and continuum level, the partial wave of the outgoing electron as well as          the given multipole and gauge. A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.checkConsistentMultiplets-Tuple{Multiplet, Multiplet}","page":"API Atomic processes","title":"JAC.PhotoRecombination.checkConsistentMultiplets","text":"PhotoRecombination.checkConsistentMultiplets(finalMultiplet::Multiplet, initialMultiplet::Multiplet)       ... to check that the given initial- and final-state levels and multiplets are consistent to each other and         to avoid later problems with the computations. An error message is issued if an inconsistency occurs,         and nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.compareCrossSectionEmpirical-Tuple{Vector{Float64}, Float64}","page":"API Atomic processes","title":"JAC.PhotoRecombination.compareCrossSectionEmpirical","text":"PhotoRecombination.compareCrossSectionEmpirical(energies::Array{Float64,1}, Z::Float64)       ... to evaluate and compare different (non-relativistic) shell-resolved and total cross section for the          RR of a free electron with energy into initially bare ions with nuclear charge Z; an cs::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.comparePlasmaRateEmpirical-Tuple{Vector{Float64}, Float64}","page":"API Atomic processes","title":"JAC.PhotoRecombination.comparePlasmaRateEmpirical","text":"PhotoRecombination.comparePlasmaRateEmpirical(temps::Array{Float64,1}, Z::Float64)       ... to evaluate and compare different plasma rate coefficients for the capture of a Maxwellian-distributed         free electron with temperature Te in temps into initially bare ions with nuclear charge Z; nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.computeAmplitudesProperties-Tuple{JAC.PhotoRecombination.Line, Model, JAC.Radial.Grid, Int64, JAC.PhotoRecombination.Settings}","page":"API Atomic processes","title":"JAC.PhotoRecombination.computeAmplitudesProperties","text":"PhotoRecombination.computeAmplitudesProperties(line::PhotoRecombination.Line, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64,                                                  settings::PhotoRecombination.Settings)       ... to compute all amplitudes and properties of the given line; a line::PhotoRecombination.Line is returned for          which the amplitudes and properties are now evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.computeAnisotropyParameter-Tuple{Int64, JAC.Basics.EmGauge, JAC.PhotoRecombination.Line}","page":"API Atomic processes","title":"JAC.PhotoRecombination.computeAnisotropyParameter","text":"PhotoRecombination.computeAnisotropyParameter(nu::Int64, gauge::EmGauge, line::PhotoRecombination.Line)       ... to compute the anisotropy parameter of the emitted photons for the photorecombination of an initially unpolarized ion.          A value::ComplexF64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.computeCrossSectionBareIon-Tuple{Float64, Subshell, Vector{EmMultipole}, JAC.Basics.EmGauge, Model, JAC.Radial.Grid, Int64}","page":"API Atomic processes","title":"JAC.PhotoRecombination.computeCrossSectionBareIon","text":"PhotoRecombination.computeCrossSectionBareIon(energy_eV::Float64, subshell::Subshell, multipoles::Array{EmMultipole,1},                                                  gauge::EmGauge, nm::Nuclear.Model, grid::Radial.Grid, nrContinuum::Int64)       ... to compute the (hydrogenic) RR cross section for the capture of an electron into a single subshell;          only the amplitudes for the given multipoles are taken into account; an cs::Float64 [a.u.] is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.computeCrossSectionForMultipoles-Tuple{Vector{EmMultipole}, JAC.PhotoRecombination.Line}","page":"API Atomic processes","title":"JAC.PhotoRecombination.computeCrossSectionForMultipoles","text":"PhotoRecombination.computeCrossSectionForMultipoles(multipoles::Array{EmMultipole,1}, line::PhotoRecombination.Line)       ... to compute the cross section from the channel amplitudes of a given line; only the amplitudes         for the given multipoles are taken into account; an cs::EmProperty is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.computeLines-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, JAC.PhotoRecombination.Settings}","page":"API Atomic processes","title":"JAC.PhotoRecombination.computeLines","text":"PhotoRecombination.computeLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model, grid::Radial.Grid,                                          settings::PhotoRecombination.Settings; output::Bool=true)      ... to compute the photo recombination transition amplitudes and all properties as requested by the given settings.          A list of lines::Array{PhotoRecombination.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.computeLinesWithContinuumOrbital-Tuple{Multiplet, Multiplet, Model, JAC.Radial.Grid, Dict{Subshell, Orbital}, JAC.Radial.GridGL, JAC.PhotoRecombination.Settings}","page":"API Atomic processes","title":"JAC.PhotoRecombination.computeLinesWithContinuumOrbital","text":"PhotoRecombination.computeLinesWithContinuumOrbital(finalMultiplet::Multiplet, initialMultiplet::Multiplet, nm::Nuclear.Model,                                                          grid::Radial.Grid, cOrbitals::Dict{Subshell, Orbital}, energyGrid::Radial.GridGL,                                                          settings::PhotoRecombination.Settings; output::Bool=true)      ... to compute the photo recombination transition amplitudes and all properties as requested by the given settings but with the         given continuum orbitals cOrbitals and for the (free-) electronEnergies. A error message is issued if these energies are not         the same a given by the settings. The continuum orbital with electronEnergies[i] has the principal quantum number 100+i.         A list of lines::Array{PhotoRecombination.Lines} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.crossSectionBellTotal-Tuple{Float64, Float64}","page":"API Atomic processes","title":"JAC.PhotoRecombination.crossSectionBellTotal","text":"PhotoRecombination.crossSectionBellTotal(energy::Float64, Z::Float64)       ... to evaluate the (non-relativistic) total Bell & Bell cross section for the RR of a free electron with energy          into any shell of initially bare ions with nuclear charge Z; an cs::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.crossSectionKramers-Tuple{Float64, Float64, Tuple{Int64, Int64}}","page":"API Atomic processes","title":"JAC.PhotoRecombination.crossSectionKramers","text":"PhotoRecombination.crossSectionKramers(energy::Float64, Z::Float64, nLowUp::Tuple{Int64,Int64})       ... to evaluate the (non-relativistic) Kramers cross section for the RR of a free electron with energy into all shells with         n = nLow ... nUp of initially bare ions with nuclear charge Z; an cs::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.crossSectionKramersTotal-Tuple{Float64, Float64}","page":"API Atomic processes","title":"JAC.PhotoRecombination.crossSectionKramersTotal","text":"PhotoRecombination.crossSectionKramersTotal(energy::Float64, Z::Float64)       ... to evaluate the (non-relativistic) Kramers cross section for the RR of a free electron with energy into any shell         of initially bare ions with nuclear charge Z; an cs::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.crossSectionStobbe-Tuple{Float64, Float64}","page":"API Atomic processes","title":"JAC.PhotoRecombination.crossSectionStobbe","text":"PhotoRecombination.crossSectionStobbe(energy::Float64, Z::Float64)       ... to evaluate the (non-relativistic) Stobbe cross section for the RR of a free electron with energy into the 1s state of          initially bare ions with nuclear charge Z; an cs::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.determineChannels-Tuple{Level, Level, JAC.PhotoRecombination.Settings}","page":"API Atomic processes","title":"JAC.PhotoRecombination.determineChannels","text":"PhotoRecombination.determineChannels(finalLevel::Level, initialLevel::Level, settings::PhotoRecombination.Settings)       ... to determine a list of RecChannel for a transitions from the initial to final level and by taking into account          the particular settings of for this computation; an Array{PhotoRecombination.Channel,1} is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.determineLines-Tuple{Multiplet, Multiplet, JAC.PhotoRecombination.Settings}","page":"API Atomic processes","title":"JAC.PhotoRecombination.determineLines","text":"PhotoRecombination.determineLines(finalMultiplet::Multiplet, initialMultiplet::Multiplet, settings::PhotoRecombination.Settings)       ... to determine a list of PhotoRecombination.Line's for transitions between levels from the initial- and final-state          multiplets, and by taking into account the particular selections and settings for this computation;          an Array{PhotoRecombination.Line,1} is returned. Apart from the level specification, all physical properties are set          to zero during the initialization process.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.displayLines-Tuple{IO, Vector{JAC.PhotoRecombination.Line}}","page":"API Atomic processes","title":"JAC.PhotoRecombination.displayLines","text":"PhotoRecombination.displayLines(stream::IO, lines::Array{PhotoRecombination.Line,1})       ... to display a list of lines and channels that have been selected due to the prior settings. A neat table of all selected          transitions and energies is printed but nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.displayRateCoefficients-Tuple{IO, LevelSymmetry, Vector{Float64}, Vector{JAC.Basics.EmProperty}}","page":"API Atomic processes","title":"JAC.PhotoRecombination.displayRateCoefficients","text":"PhotoRecombination.displayRateCoefficients(stream::IO, isym::LevelSymmetry, temperatures::Array{Float64,1}, alphaRR::Array{EmProperty,1})       ... to print all rate coefficients for the selected temperatures in neat tables,          though nothing is returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.displayResults-Tuple{IO, Vector{JAC.PhotoRecombination.Line}, JAC.PhotoRecombination.Settings}","page":"API Atomic processes","title":"JAC.PhotoRecombination.displayResults","text":"PhotoRecombination.displayResults(stream::IO, lines::Array{PhotoRecombination.Line,1}, settings::PhotoRecombination.Settings)       ... to list all results, energies, cross sections, etc. of the selected lines. A neat table is printed but nothing is          returned otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.plasmaRateKotelnikov-Tuple{Float64, Float64}","page":"API Atomic processes","title":"JAC.PhotoRecombination.plasmaRateKotelnikov","text":"PhotoRecombination.plasmaRateKotelnikov(Te::Float64, Z::Float64)       ... to evaluate the RR plasma rate coefficient at temperature Te and for a Maxwellian distribution of electron         energies and an initially bare ions with nuclear charge Z; an alpha::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.plasmaRateKotelnikov_1s-Tuple{Float64, Float64}","page":"API Atomic processes","title":"JAC.PhotoRecombination.plasmaRateKotelnikov_1s","text":"PhotoRecombination.plasmaRateKotelnikov_1s(Te::Float64, Z::Float64)       ... to evaluate the RR plasma rate coefficient at temperature Te and for a Maxwellian distribution of electron         energies and an initially bare ions with nuclear charge Z; here only the capture into 1s is taken into account.         An alpha::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.plasmaRatePartialSeaton-Tuple{Float64, Float64, Int64}","page":"API Atomic processes","title":"JAC.PhotoRecombination.plasmaRatePartialSeaton","text":"PhotoRecombination.plasmaRatePartialSeaton(Te::Float64, Z::Float64, n::Int64)       ... to evaluate the RR plasma rate coefficient at temperature Te and for a Maxwellian distribution of electron         energies and an initially bare ions with nuclear charge Z.         An alpha::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-processes.html#JAC.PhotoRecombination.plasmaRateSeaton-Tuple{Float64, Float64}","page":"API Atomic processes","title":"JAC.PhotoRecombination.plasmaRateSeaton","text":"PhotoRecombination.plasmaRateSeaton(Te::Float64, Z::Float64)       ... to evaluate the RR plasma rate coefficient at temperature Te and for a Maxwellian distribution of electron         energies and an initially bare ions with nuclear charge Z; this formula is valid for 2*Te / Z^2 << 1.         An alpha::Float64 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api-atomic.html#Atomic-computations","page":"API Atomic computations","title":"Atomic computations","text":"","category":"section"},{"location":"api-atomic.html","page":"API Atomic computations","title":"API Atomic computations","text":"Modules = [Atomic]\nOrder   = [:type, :function]","category":"page"},{"location":"api-atomic.html#JAC.Atomic.Computation","page":"API Atomic computations","title":"JAC.Atomic.Computation","text":"struct  Computation       ... defines a type for defining  (the model of simple) atomic computation of a single multiplet,          including the SCF and CI as well as level properties and transition property calculations.\n\n+ name                           ::String                          ... A name associated to the computation.\n+ nuclearModel                   ::Nuclear.Model                   ... Model, charge and parameters of the nucleus.\n+ grid                           ::Radial.Grid                     ... The radial grid to be used for the computation.\n+ propertySettings               ::Array{Basics.AbstractPropertySettings,1}  ... List of atomic properties to be calculated.\n+ configs                        ::Array{Configuration,1}          ... A list of non-relativistic configurations.\n+ asfSettings                    ::AsfSettings                     \n    ... Provides the settings for the SCF process and for the CI and QED calculations.\n+ initialConfigs                 ::Array{Configuration,1}        \n    ... A list of initial-state configurations for some transition property calculation, such as radiative transition, Auger, etc. \n+ initialAsfSettings             ::AsfSettings                     ... Provides the SCF and CI settings for the initial-state multiplet.\n+ intermediateConfigs            ::Array{Configuration,1}          ... A list of initial-state configurations.\n+ intermediateAsfSettings        ::AsfSettings                     ... Provides the SCF settings for the intermediate-state multiplet.\n+ finalConfigs                   ::Array{Configuration,1}          ... A list of final-state configurations.\n+ finalAsfSettings               ::AsfSettings                     ... Provides the SCF and CI settings for the final-state multiplet.\n+ processSettings                ::Basics.AbstractProcessSettings  ... Provides the settings for the selected process.\n\n\n\n\n\n","category":"type"},{"location":"api-atomic.html#JAC.Atomic.Computation-Tuple{Bool}","page":"API Atomic computations","title":"JAC.Atomic.Computation","text":"Atomic.Computation( ... example for SCF computations)  \n\n    grid     = Radial.Grid(true)\n    nuclearM = Nuclear.Model(18., \"Fermi\")\n    settings = AsfSettings(AsfSettings(), selectLevelsCI = true, selectedLevelsCI = [1,2, 4,5, 7,8], jjLS = LSjjSettings(false) )\n    configs  = [Configuration(\"[Ne] 3s^2 3p^5\"), Configuration(\"[Ne] 3s 3p^6\")]\n    Atomic.Computation(Atomic.Computation(), name=\"Example\", grid=grid, nuclearModel=nuclearM, configs=configs, asfSettings=settings )\n\nAtomic.Computation( ... example for the computation of atomic properties)  \n\n    grid        = Radial.Grid(true)\n    nuclearM    = Nuclear.Model(26., \"Fermi\", 58., 3.81, AngularJ64(5//2), 1.0, 1.0)\n    hfsSettings = Hfs.Settings(true, true, false, false, false, false, false, Int64[] )\n    configs     = [Configuration(\"[Ne] 3s\"), Configuration(\"[Ne] 3p\"), Configuration(\"[Ne] 3d\")]\n    Atomic.Computation(Atomic.Computation(), name=\"Example\", grid=grid, nuclearModel=nuclearM, configs=configs, properties=[HFS()],\n                        hfsSettings=hfsSettings )\n\nAtomic.Computation( ... example for the computation of one atomic process)  \n\n    grid           = Radial.Grid(true)\n    initialConfigs = [Configuration(\"[Ne] 3s 3p^6\"), Configuration(\"[Ne] 3s^2 3p^4 3d\")]\n    finalConfigs   = [Configuration(\"[Ne] 3s^2 3p^5\")] \n    photoSettings  = PhotoEmission.Settings(PhotoEmission.Settings(), multipoles=[E1, M1], gauges=[UseCoulomb], printBefore=true)\n    Atomic.Computation(Atomic.Computation(), name=\"Example\", grid=grid, nuclearModel=nuclearM;\n                        initialConfigs=initialConfigs, finalConfigs=finalConfigs, \n                        process = Radiative(), processSettings=photoSettings ); \n\n... These simple examples can be further improved by overwriting the corresponding parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-atomic.html#JAC.Atomic.Computation-Tuple{JAC.Atomic.Computation}","page":"API Atomic computations","title":"JAC.Atomic.Computation","text":"Atomic.Computation(comp::Atomic.Computation;\n\nname=..,                nuclearModel=..,            grid=..,                    configs=..,                   asfSettings=..,     \ninitialConfigs=..,      initialAsfSettings=..,      intermediateConfigs=..,     intermediateAsfSettings=.., \nfinalConfigs=..,        finalAsfSettings=..,        alphaSettings=..,           einsteinSettings=.., \nformSettings=..,        hfsSettings=..,             isotopeSettings=..,         plasmaSettings=..,\npolaritySettings=..,    yieldSettings::=..,         zeemanSettings=..,\nprocess=..,             processSettings=..,         printout::Bool=false)\n                \n... constructor for modifying the given Atomic.Computation by 'overwriting' the previously selected parameters.\n\n\n\n\n\n","category":"method"},{"location":"api-atomic.html#JAC.Atomic.Computation-Tuple{}","page":"API Atomic computations","title":"JAC.Atomic.Computation","text":"Atomic.Computation()  ... constructor for an 'empty' instance::Atomic.Computation.\n\n\n\n\n\n","category":"method"},{"location":"examples.html#Hydrogenic-Computation","page":"Examples","title":"Hydrogenic Computation","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using JAC","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Perhaps, the simplest atomic computations can be made for hydrogenic ions. If we consider, for example, hydrogen-like  argon (Z=18), we can first determine and compare the energies of the 1s and 2p levels from the (non-relativistic)  Schroedinger equation with those from Dirac's relativistic equation by","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Z     = 18.0\ne1s   = HydrogenicIon.energy(Shell(\"1s\"), Z)   ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"e2p   = HydrogenicIon.energy(Shell(\"2p\"), Z)\ne2p_1 = HydrogenicIon.energy(Subshell(\"2p_1/2\"), Z)   \ne2p_3 = HydrogenicIon.energy(Subshell(\"2p_3/2\"), Z)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"While the (one-electron) energies are displayed by the function  HydrogenicIon.energy() in the default units  (presently eV here and as could be overwritten by the user), all computations are internally performed and  returned always in atomic units. This applies to all computations if not stated otherwise in the description of  some particular function; indeed, the user-defined units mainly in the tabulation of results but are not returned.  Most of these tabulations are generated by display method which print some table to screen but return nothing  otherwise.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This clear distinction between the use of atomic and (user-specified) default units can be seen  easily  from the output of the variables e2p, e2p_1, e2p_3 above: ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(e2p, e2p_1, e2p_3) ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The units of energies, rates and several other physical properties can be however quite easily converted among each  other, for instance, by:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"e1s_eV = convertUnits(\"energy: from atomic to eV\", e1s)\ne1s_au = convertUnits(\"energy: from eV to atomic\", e1s_eV)\n(e1s, e1s_eV, e1s_au)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"... and similarly also for other energy units as well as for other physical entities; cf. ? convertUnits().","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"From these energies, we can easily compute the fine-structure splitting of the 2p level into the 2p_12 and  2p_32 (fine-structure) levels for hydrogen-like argon from above:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"e13 = e2p_1 - e2p_3\ne13_eV = convertUnits(\"energy: from atomic to eV\", e13)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Apart from the (single-electron) energies, we can generate also the radial orbitals, i.e. the P(r) in the  non-relativistic theory or  P(r) and Q(r)  in the relativistic theory. Both, the relativistic and non-relativistic  orbitals, can be calculated by using the general (and analytically well-known) solutions of either the Dirac's  or Schrödinger's equation. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"However, since all (radial) orbital functions are represented on some Radial.Grid, special care has to be taken  in order to define a proper grid, and which affects also all subsequent numerical computations as well as the  accuracy that can be obtained. To better understand the definition of the grid, let us ask for:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"? Radial.Grid","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Radial.Grid","category":"page"},{"location":"examples.html#JAC.Radial.Grid-examples","page":"Examples","title":"JAC.Radial.Grid","text":"struct  Radial.Grid  ... defines a type for the radial grid which contains all information about the grid parameters, the genration                              of the B-spline basis as well as for performing radial integrations.\n\n** Physical grid parameter **\n+ rnt        ::Float64           ... smalles grid point > 0.\n+ h          ::Float64           ... stepsize in the construction of the exponential grid.\n+ hp         ::Float64           ... asymptotic stepsize of the log-lin grid.\n+ NoPoints   ::Int64             ... No. of grid points so that r[NoPoints] coincides also \n                                        with the largest break point of the B-spline knot.\n** B-spline grid parameters and break points **\n+ tL         ::Array{Float64,1}  ... radial break points for the B-splines of the large c.\n+ tS         ::Array{Float64,1}  ... radial break points for the B-splines of the small c.\n+ ntL        ::Int64             ... number of break points in the t-grid of the large c.\n+ ntS        ::Int64             ... number of break points in the t-grid of the small c.\n+ orderL     ::Int64             ... B-spline order of large components.\n+ orderS     ::Int64             ... B-spline order of small components.\n+ nsL        ::Int64             ... number of B-splines for large components.\n+ nsS        ::Int64             ... number of B-splines for small components.\n+ orderGL    ::Int64             \n    ... order of the Gauss-Lengedre integration if mesh == Radial.MeshGL(); this order also determines\n        the (number of) break points by taking the orderGL-th point from the physical grid points.\n** Radial mesh points **\n+ meshType   ::Radial.AbstractMesh\n+ r          ::Array{Float64,1}  ... radial grid points\n+ rp         ::Array{Float64,1}  ... derivative of the radial grid at the grid points\n+ rpor       ::Array{Float64,1}  ... rp over r\n+ wr         ::Array{Float64,1}  \n    ... integration weights for all grid points, for instance, GL weights.\n\n\n\n\n\n","category":"type"},{"location":"examples.html","page":"Examples","title":"Examples","text":"which shows the internal definition and the constructors to define such a grid. In practice, there are three (logical) levels that are considered and realized for each grid: ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(i) The phenomenological grid definition that is based on our physics understanding and intuition of which grid is  appropriate to decribe a particular atomic property or process. Two currently implemented grid refers to an exponential  grid (with exponentially increasing stepsize) as appropriate for many bound-state computations and a linear-logarithmic grid that start exponentially but becomes linear in its stepsize for large values of r. Such a linear-logarithmic  grid is typically needed to describe electron ionization and capture processes as the incoming or outgoing electron waves  are sinusoidal and should be represented with a proper number of grid points, say 20-30, per period of the electron wave.  In JAC, the phenomenologically part of the grid is chosen (analogue as in GRASP) by the parameters rnt, h, hp  and NoPoints in the definition above. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(ii) The phenomenological definition of the grid is internally translated into a sequence of knots upon which the  B-spline primitives are defined. Here, each nth mesh point from the phenomenological is chosen to keep the number of  B-splines and the corresponding size of matrices (that need to be diagonalized) moderate. These knots are used to  define the B-splines and to determine the eigenvectors of all orbitals (within some given potential) but they are not  applied in order evaluate matrix elements or radial integrals.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(iii) The phenomenological grid and the definition of the B-splines (knots) are eventually combined into a  physical grid upon which all radial functions are represented. This physical grid resembles the phenomenological grid  but with modified grid points in between the knots of the B-spline grid (t-grid). Here the radial points and corresponding  weights are chosen due to a Gauss-Legendre distribution and goal to determine all radial integrals exact up to a  given Gauss-Legendre order.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The physical grid is thus defined by the three arrays r (the mesh points along r), rp (the derivatives d r/ dr),  rpor (the values rp / r) as well as w (the corresponding weights). All these arrays are of length  nr approx NoPoints but not necessarely equal as the grid points nr are coupled to the underlying integration,  respectively, interpolation scheme. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In principle, this physical grid could chosen also on other interpolation/integration formulas, such as Gauss-Laguerre  or others, that have been utilized in atomic physics. All what is needed would be to adapt the intermediate grid point  and weights accordingly.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The clear distinction between the phenomenological grid and the physical grid help avoid that every new (radial)  operator as well as particular boundary condition of the radial orbital functions need to be treated independently within  the B-spline basis. Instead, a proper interpolation/integration formula should guarantee that all results are integrated  sufficiently accurate, and this is first of all tested by enlarging the number of grid point NoPoint –> nr","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Here, we first apply an exponential grid, and which is appropriate below in order to compute various expectation values:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"grid   = Radial.Grid(true, printout= true)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"With this grid, the non-relativistic radial orbitals P(r) can be obtained either for a single r-value, for a list of  r-values as well as for all r-values on a given radial grid:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Pnr_1s = HydrogenicIon.radialOrbital(Shell(\"1s\"), Z, grid)\nPnr_2p = HydrogenicIon.radialOrbital(Shell(\"2p\"), Z, grid)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Here, the exponential tails of the radial orbitals are simply set to zero if P  10e-15 (and similarly for Q).","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Of course, we could plot the two functions Pnr_1s and Pnr_2p directly by some proper call of PyPlot, and if we give  the correct arrays of radial mesh points from above.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Plots \nplot(grid.r, [Pnr_1s, Pnr_2p],xlims=(0,1), xlabel = \"r (a.u.)\", ylabel=\"Amplitude (a.u.)\", label=[\"1s\" \"2p\"])\nsavefig(\"hdy-1.svg\"); nothing # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We can also make use of this function to visualise the relativistic orbitals if we specify the total angular momentum  and generate the relativistic orbitals, which contain both the large and the small component.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"setDefaults(\"standard grid\", grid)\nPQr_1s = HydrogenicIon.radialOrbital(Subshell(\"1s_1/2\"), Z, grid)\nPQr_2p1 = HydrogenicIon.radialOrbital(Subshell(\"2p_1/2\"), Z, grid)\nPQr_2p3 = HydrogenicIon.radialOrbital(Subshell(\"2p_3/2\"), Z, grid)\nplot(grid.r, [PQr_1s,PQr_2p1, PQr_2p3],xlims=(0,1), xlabel = \"r (a.u.)\", ylabel=\"Amplitude (a.u.)\", \n     label=[\"1s - Large component\" \"1s - Small component\" \"2p_1/2 - Large component\" \"2p_1/2 - Small component\" \"2p_3/2 - Large component\" \"2p_3/2 - Small component\"])\nsavefig(\"hdy-2.svg\"); nothing # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In practice, using Pyplot is often quite tedious since all the specification of arrays, axes, labels, etc. need to  be given explicitly. To display the shape of such orbitals, a special plotting method is prepared in JAC that displays  one or several orbitals together. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"? Basics.plot","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Basics.plot","category":"page"},{"location":"examples.html#JAC.Basics.plot-examples","page":"Examples","title":"JAC.Basics.plot","text":"Basics.plot()  ... plots various quantities, often in a new window.\n\n(\"radial potentials\", potentials::Array{Radial.Potential,1}, grid::Radial.Grid; N::Int64 = 0)     ... to plot one or more radial potentials, and where N::Int64 describes the number of grid points to be considered.       call:  using Plots; pyplot()    ... to access this method by plot(...)\n\n\n\n\n\n(\"radial orbitals: large\", orbitals::Array{Radial.Orbital,1}, grid::Radial.Grid; N::Int64 = 0)     ... to plot the large component of one or more radial orbitals, and where N::Int64 describes the number of grid        points to be considered.\n(\"radial orbitals: small\", orbitals::Array{Radial.Orbital,1}, grid::Radial.Grid; N::Int64 = 0)     ... to plot the small component of one or more radial orbitals.\n(\"radial orbitals: both\",  orbitals::Array{Radial.Orbital,1}, grid::Radial.Grid; N::Int64 = 0)     ... to plot the large and small component of one or more radial orbitals.\ncall:  using Plots; pyplot()    ... to access this method by plot(...)\n\n\n\n\n\n(\"spectrum: transition rates over energy\", lines::Array{PhotoEmission.Line,1})     ... to plot the transition rates of all lines as function of their transition energies. The plot is shown in a new        window but nothing is returned otherwise. Not yet implemented !\n(\"spectrum: oscillator strength over energy, emission\", lines::Array{PhotoEmission.Line,1}) or   (\"spectrum: oscillator strength over energy, absorption\", lines::Array{PhotoEmission.Line,1})    ... to plot the absorption oscillator strength of all lines as function of their transition energies. Again, a new        window is opened but nothing returned by this method. Not yet implemented !\n\n\n\n\n\n(\"spectrum: transition rates over energy, Gaussian\", lines::Array{PhotoEmission.Line,1}; widths=value::Float64) or   (\"spectrum: transition rates over energy, Lorentzian\", lines::Array{PhotoEmission.Line,1}; widths=value::Float64)   ... to plot the transition rates of all lines as function of their transition energies but with a Gaussian or Lorentzian        distribution. Again, a new window is opened but nothing returned by this method. It still need to be decided how        the widths (and, perhaps, other parameters) will be communicated to the method. Not yet implemented !\n\n\n\n\n\n","category":"function"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This Basics.plot function (from the Basics module) accepts for instance a list of (relativistic) radial Orbitals:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"? Orbital","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Orbital","category":"page"},{"location":"examples.html#JAC.Radial.Orbital-examples","page":"Examples","title":"JAC.Radial.Orbital","text":"struct  Radial.Orbital       ... defines a type for a single-electron radial orbital function with a large and small component, and which can refer to         either the standard or an explicitly given grid due to the logical flag useStandardGrid. Bound-state orbitals with energy < 0 are          distinguished from free-electron orbitals by the flag isBound.\n\n+ subshell        ::Subshell          ... Relativistic subshell.\n+ isBound         ::Bool              ... Logical flag to distinguish between bound (true) and free-electron orbitals (false).\n+ useStandardGrid ::Bool              ... Logical flag for using the standard grid (true) or an explicitly given grid (false).\n+ energy          ::Float64           ... Single-electron energies of bound orbitals are always negative.\n+ P               ::Array{Float64,1}  ... Large and ..\n+ Q               ::Array{Float64,1}  ... small component of the radial orbital.\n+ Pprime          ::Array{Float64,1}  ... dP/dr.\n+ Qprime          ::Array{Float64,1}  ... dQ/dr.\n+ grid            ::Array{Float64,1}  ... explic. defined radial grid array for P, Q, if StandardGrid = false.\n\n\n\n\n\n","category":"type"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Of course, the main purpose of this plot method is to display and compare a number of generated orbitals, either for  getting physical insight or just for test purposes. We can make use of the same plot method also for the  non-relativistic  Pnr_1s(r)  orbital if we assign this array as large component of a relativistic orbital and  specify the additional quantum numbers. Moreover, we here first internally to define a standard grid as well as  such an (instance of the) Orbital by using its standard constructor, and by setting the small  Q(r) component  as well as dPdr and dQdr simply to zero:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"setDefaults(\"standard grid\", grid)\nQnr_1s   = Pprime = Qprime = zeros( length(Pnr_1s) )\nnrOrb_1s = Orbital( Subshell(\"1s_1/2\"), true, true, e1s, Pnr_1s, Qnr_1s, Pprime, Qprime, Radial.Grid())\ntypeof(nrOrb_1s)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We could also compute a relativistic 1s_12 orbital on the given grid and plot the two 1s-orbitals together;  while the large components of these orbitals coincide of course, due to its special construction via the non-relativistic  orbitals, the small compoments differ. Note that one need to use the standard REPL in order to display these functions  in some separate window.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Orb_1s = HydrogenicIon.radialOrbital(Subshell(\"1s_1/2\"), Z, grid)\ne1s_1 = HydrogenicIon.energy(Subshell(\"1s_1/2\"), Z)\nrOrb_1s = Orbital( Subshell(\"1s_1/2\"), true, true, e1s_1, Orb_1s[1], Orb_1s[2], Pprime, Qprime, Radial.Grid())","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"plot(\"radial orbitals: both\", Orbital[nrOrb_1s, rOrb_1s], grid; N = 230)\nsavefig(\"hdy-3.svg\"); nothing # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We can use these orbitals to quickly evaluate some overlap integrals and langle r^k rangle expectation values;  for this, we make use of the non-relativistic 2p radial orbital Pnr_2p from above and compute the normalization   and langle r rangle expectation values:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"N_1s = RadialIntegrals.overlap(Pnr_1s, Pnr_1s, grid)\nN_2p = RadialIntegrals.overlap(Pnr_2p, Pnr_2p, grid)\nr_exp_1s = RadialIntegrals.rkDiagonal(1, Pnr_1s, Pnr_1s,grid)\nr_exp_2p = RadialIntegrals.rkDiagonal(1, Pnr_2p, Pnr_2p,grid)\nprintln(\"N_1s = $(N_1s)\",\"\\n\",\"N_2p = $(N_2p)\",\"\\n\",\"r_exp_1s = $(r_exp_1s)\",\"\\n\",\"r_exp_2p = $(r_exp_2p)\")","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"As we can see the radial orbitals are already normalized by construction and the expectation values match with the  analytic values of langle r rangle_nl = frac12Z3n²-l(l+1). ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"For the sake of simplicity, all hydrogenic computations are performed for a point-like nucleus. For many-electron  computations, in constrast, a more realistic nucleus can be taken into accout by selecting a proper nuclear model.  See the tutorial: Define the nuclear model parameters   or   ? Nuclear.Model  ... for further details.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":" ? Nuclear.Model","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Nuclear.Model","category":"page"},{"location":"examples.html#JAC.Nuclear.Model","page":"Examples","title":"JAC.Nuclear.Model","text":"struct  Nuclear.Model  ... defines a type for the nuclear model, i.e. for its form and parameters.\n\n+ Z        ::Float64         ... nuclear charge\n+ model    ::String          ... identifier of the nuclear model: {\"Fermi\", \"Point\", \"Uniform\"}\n+ mass     ::Float64         ... atomic mass\n+ radius   ::Float64         ... (root-mean square) radius of a uniform or Fermi-distributed nucleus\n+ spinI    ::AngularJ64      ... nuclear spin I, must be >= 0\n+ mu       ::Float64         ... magnetic dipole moment in Bohr magnetons\n+ Q        ::Float64         ... electric quadrupole moment\n\n\n\n\n\n","category":"type"},{"location":"examples.html","page":"Examples","title":"Examples","text":"If we would like to compute a relativistic orbital by taking into account the type of the nucleus, we can simply  define a nuclear model: ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Nucleus = Model(Z, \"Fermi\")","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"and set it as an argument value of the radialOrbital-function. By comparing the analytic orbitals which are based on a  point like nucleus and the orbitals taking into account a fermi distributed nucleus one can see, that the influence of  the nucleus is negligible for large r. However by looking at the functions at a closer angle the influence of the nucleus  is well visible for small r. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"nuc_orb_1s = HydrogenicIon.radialOrbital(Subshell(\"1s_1/2\"),Nucleus, grid)\nplot(\"radial orbitals: both\", [nuc_orb_1s,rOrb_1s], grid; N = 230)\nsavefig(\"hdy-4.svg\"); nothing # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"plot(\"radial orbitals: both\", [nuc_orb_1s,rOrb_1s], grid; N = 75)\nsavefig(\"hdy-2.svg\"); nothing # hide","category":"page"},{"location":"examples.html#Compute-the-low-lying-levels-of-C{2}-1s2-(2s2-2s2p-2p2):-\\;-SCF-and-configuration-interaction-calculations","page":"Examples","title":"Compute the low-lying levels of C^2+ 1s^2 (2s^2 + 2s2p + 2p^2):  SCF and configuration interaction calculations","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using JAC","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The low-lying levels (level structure) of beryllium-like ions, and especially of C^2+, has been calculated in  many case studies in the literature. While the level structure of these ions is still quite simple, it exhibits a  considerable admixture of the 2s^22p^2 configuration already for the 1s^22s^2 ^1S_0 ground level.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We here show how the low-lying levels of C^2+ can be readily calculated in JAC by either following the default  settings or by specifying further details for both, the SCF and configuration-interaction (CI) computations. As usual,  we first need to specify a radial grid as well as the nuclear model for the subsequent computations:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"grid     = Radial.Grid(true)\nnucModel = Nuclear.Model(6., \"Fermi\")","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"For a quick computation of the ground level of C^2+ ions, we can simply use the standard settings as given  by AsfSettings():","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"multiplet     = SelfConsistent.performSCF([Configuration(\"1s^2 2s^2\")], nucModel, grid, AsfSettings());\nBasics.tabulate(stdout, \"multiplet: energies\", multiplet, Array(1:length(multiplet.levels)) )       # hide\nBasics.tabulate(stdout, \"multiplet: energy of each level relative to lowest level\", multiplet, Array(1:length(multiplet.levels)) )  # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"... and, similarly, also for the 10 lowest levels of C^2+ ions as they arise from the C^2+ 1s^2 (2s^2 + 2s2p + 2p^2) configurations:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"multiplet     = SelfConsistent.performSCF([Configuration(\"1s^2 2s^2\"), Configuration(\"1s^2 2s 2p\"), Configuration(\"1s^2 2p^2\")], \n                              nucModel, grid, AsfSettings());\nBasics.tabulate(stdout, \"multiplet: energies\", multiplet, Array(1:length(multiplet.levels)) )   # hide\nBasics.tabulate(stdout, \"multiplet: energy of each level relative to lowest level\", multiplet, Array(1:length(multiplet.levels)) )  # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"From the comparison of the two ground-state energies, we see that the admixture of the 2p^2 configuration has lowered  the (total) ground state energy by about 1.8 eV, a rather remarkable admixture, as the  ^3P_0 is just 6.6 eV above of the  ground level.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Further control about these electronic computations can be obtained by modifying the (so-called) settings.  In general, all computations of the electronic structure, properties and processes as well as all more advanced computations  can be controlled quite in details by various settings that are associated to the different computational requests.  The SCF and configuration interaction calculations are controlled by AsfSettings that specify all details for the  generation of the ASF. We can first have a look at the internal representation of these settings:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"? AsfSettings","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"AsfSettings","category":"page"},{"location":"examples.html#JAC.ManyElectron.AsfSettings-examples","page":"Examples","title":"JAC.ManyElectron.AsfSettings","text":"struct  ManyElectron.AsfSettings       ... a struct for defining the settings for the atomic state functions, i.e. the self-consistent-field (SCF)          and CI computations\n\n+ generateScf          ::Bool                   ... True, if a SCF need to be generated, and false otherwise \n                                                    (frozen orbitals).\n+ eeInteraction        ::AbstractEeInteraction  ... Specify the e-e interaction to be included into the SCF \n                                                    computations.\n+ scField              ::AbstractScField        ... Specify the self-consistent field, for instance, \n                                                    Basics.ALField(), etc.\n+ startScfFrom         ::AbstractStartOrbitals  ... Specify the orbitals to start the SCF computations\n+ maxIterationsScf     ::Int64                  ... maximum number of SCF iterations\n+ accuracyScf          ::Float64                ... convergence criterion for the SCF field.\n+ shellSequenceScf     ::Array{Subshell,1}      ... Sequence of subshells to be optimized.\n+ frozenSubshells      ::Array{Subshell,1}      ... Sequence of subshells to be kept frozen.\n\n+ eeInteractionCI      ::AbstractEeInteraction  ... Specify the e-e interaction to be included into the \n                                                    CI computations.\n+ qedModel             ::AbstractQedModel       ... model for estimating QED corrections {NoneQed(), \n                                                    QedPetersburg(), QedSydney()}.\n+ jjLS                 ::LSjjSettings           ... settings to control a jj-LS transformation of atomic \n                                                    level, if requested.\n+ levelSelectionCI     ::LevelSelection         ... Specifies the selected levels, if any.\n\n\n\n\n\n","category":"type"},{"location":"examples.html","page":"Examples","title":"Examples","text":"... as well as how the standard settings are presently defined:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"defaultAsfSettings = AsfSettings()","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"From this list, we easily see that the self-consistent field is by default based on a (mean) Dirac-Fock-Slater  potential, a choice which we could overwrite by meanCH or any pre-defined potential. At present, however,  no full treatment of the exchange interaction has yet been implemented in this first release of the program.  The standard settings also show that the SCF is usually based on just the lowest level (cf. levelScf) as well as  on the accuracy 1.0e-6 to terminate the SCF computations. Moreover, the individual orbitals are improved due  to the standard subshell order (cf. shellSequenceScf).","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"For the CI parameters, the treatment of the Breit and QED interaction is of particular interest. At present, the  defaults does not included neither Breit interactions nor QED. Such QED estimates can either be neglected (NoneQed())  or estimated by using an effective Hamiltonian approach due to Shabaev and coworkers  (QedPetersburg()) or  effective potential approach (QedSydney(); Flambaum et al.) However, further tests need to be done to better  understand the reliability of these QED estimates to the level structure and state represetation of the ASF.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"As seen from the settings above, moreover, there are special features in order to select individual levels for  the CI computations, either in terms of their (relative) level No within the given multiplet or in terms of their  level symmetry, i.e. their total angular momentum and parity, respectively. The  levelSelectionCI::LevelSelection  here tells whether (and which) selections were made; apparently, no selection of level numbers of symmetries is  made by default though this can be overwritten. The selection of individual symmetries, in particular, may considerably reduced the computational effort as the Hamiltonian matrix need then to be calculated only for the selected symmetries.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In principle, these standard settings can be easily re-defined within the code by simply modifying the constructor  AsfSetings() with no additional arguments. Alternatively, we can easily overwrite those parameters in some given  (instance of) AsfSetting which we just wish to modify. This is achieved by","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"asfSettings = AsfSettings(defaultAsfSettings; generateScf=true, jjLS=LSjjSettings(true), \n              levelSelectionCI=LevelSelection(true, symmetries=[LevelSymmetry(0,\"+\"), LevelSymmetry(1,\"-\")]) )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"multiplet     = SelfConsistent.performSCF([Configuration(\"1s^2 2s^2\"), Configuration(\"1s^2 2s 2p\"), \n                               Configuration(\"1s^2 2p^2\"), Configuration(\"1s^2 3s^2\"), \n                               Configuration(\"1s^2 3p^2\")],  nucModel, grid, asfSettings);\nBasics.tabulate(stdout, \"multiplet: energies\", multiplet, Array(1:length(multiplet.levels)) )   # hide\nBasics.tabulate(stdout, \"multiplet: energy of each level relative to lowest level\", multiplet, Array(1:length(multiplet.levels)) )  # hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We finish this (simple) tutorial by enlarging the configuration basis for the low-lying levels but by restricting  the CI computations to the level symmetries J^P = 0^+ and 1^-. This is achieved by specifying the settings to:","category":"page"},{"location":"index.html#Jena-Atomic-Calculator-(JAC)-for-the-computation-of-atomic-representations,-processes-and-cascades","page":"Home","title":"Jena Atomic Calculator (JAC) for the computation of atomic representations, processes and cascades","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Last update: April, 25th, 2025","category":"page"},{"location":"index.html#What-is-JAC?","page":"Home","title":"What is JAC?","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"JAC, the Jena Atomic Calculator, provides an open-source Julia package for doing atomic computations of various kind and complexity. In particular, JAC is a (relativistic) electronic structure code for the computation of (atomic many-electron)  interaction amplitudes, properties as well as a good number of excitation and decay processes for open-shell atoms and ions  across the whole periodic table. In recent years, moreover, emphasis has been placed support atomic cascade computations in different physical contexts as well as symbolic analysis (simplifications) of expressions from Racah's algebra. Some further work is done (or planned) to incorporate central features for studying atomic – strong-field – responses to external fields and particles, or the time-evolution of atoms and ions in the framework of (time-dependent) density matrix and Liouville equations.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A primary guiding philosophy of JAC was to develop a general and easy-to-use toolbox for the atomic physics community,  including an interface that is equally accessible for scientists working in astro and plasma physics, atomic spectroscopy, theoretical physics as well as for code developers. Beside of its simple use, however, we wish to provide and support a modern code design, a reasonable detailed documentation of the code and features for integrated testing. Indeed, the JAC toolbox  facilitates many typical computations and the handling of atomic data by providing input interfaces similar to what one  uses in a in spoken or written language. Shortly speaking, JAC aims to provide a powerful platform for daily use and  to extent atomic theory towards new applications or, eventually, a community platform for Just Atomic Computations.","category":"page"},{"location":"index.html#*Kinds*-of-computations","page":"Home","title":"Kinds of computations","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"In some more detail, JAC distinguishes and aims to support different kinds of computations which can be summarized  as follows:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Atomic computations, based on explicitly specified electron configurations: This kind refers to the frequently  applied computation of level energies and atomic state representations. It also supports the computation of either   (one or) several atomic properties for selected atomic levels from a given multiplet or of one selected process   at a time, if atomic levels from two or more multiplets and/or charge states are involved in some atomic transition,  such as the photo or autoionization of atoms.\nAtomic representations: This kind concerns the generation of different representations of atomic wave functions;   in particular, it includes systematically-enlarged restricted active-space (RAS) computations of atomic states   and level energies due to a pre-specified active space of orbitals as well as due to the (number and/or kind of)   virtual excitations to be taken to be into account. Such RAS computations are normally performed stepwise by making   use of the (one-electron) orbital functions from some prior step. Other atomic representations refer to approximate   atomic Green functions and, in the future, could be combined with concepts from close-coupling, (exterior) complex   scaling, DMRG or perturbation theory.\nInteractive computations: In practice, the (large set of) methods of the JAC toolbox can always be applied also   interactively, either directly at Julia's REPL or by using some – more or less – short Julia scripts in order to   compute and evaluate the desired observables (atomic parameters), such as energies, expansion coefficients, transition  matrices and amplitudes, rates, cross sections, etc. An interactive computation typically first prepares and applies   (certain instances of) JAC’s data types, such as orbitals, configuration-state functions (CSF), atomic bases, levels,   multiplets, and others. And like Julia, that is built upon many (high-level) functions and methods, JAC then provides   the required language elements for performing specific atomic computations at different degree of complexity and   sophistication.\nAtomic cascade computations: An atomic cascade typically includes ions (of one element) in three or more   different charge states. These charge states are connected to each other by different atomic processes, such as   photo ionization, radiative and dielectronic recombination, Auger decay, the photo excitation and emission, or various   others. In practice, moreover, the relative level population of these charge states is usually determined by the  specific set-up and geometry of the considered experiment. These cascade computations are usually based on some   predefined (cascade) approach that enables one to automatically select the state-space of the ions, to choose the   atomic processes to be considered for the various steps of the cascade, and to specify perhaps additional limitations  in order to keep the computations feasible. In addition, these cascade computations are generally divided into two  parts, the (cascade) computation for determining all necessary many-electron amplitudes and the (so-called)  simulations to combine the amplitudes due to the experimental scenario of interest.\nEmpirical computations: Not all atomic  properties and processes, such as the – single and multiple –   electron-impact ionization, stopping powers or tunnel ionization rates, can be efficiently described by ab-initio   many-body techniques. If needed, they are often easier computed by using empirical formulas and models.   A number of empirical computations are now supported to deal with such models; are often based on simple  electronic structure calculations, together with empirically obtained parameters. These computations are only   implemented when data are needed but no ab-initio computations of the involved processes appears to be feasible. \nPlasma computations: The notion of atoms and ions in plasma has been frequently applied to analyze the   behaviour of plasma in situations where the level structure and effective single-electron states remain partly   intact. Useful plasma computations refer to shifted photo lines, ionic mixtures in local and non-local   thermodynamic equilibria, or applications of the average-atom model.\nSymbolic evaluation of expressions from Racah's algebra: This kind refers to the algebraic transformation  and simplification of (Racah) expressions, which may generally include any number of Wigner n-j symbols   of different kind as well as (various integrals over) the spherical harmonics, the Wigner rotation matrices  and the Kronecker and triangular deltas. Of course, the complexity of such Racah expressions increases   very rapidly as more Wigner symbols are involved. A symbolic evaluation of these expressions is naturally   based on the knowledge of a large set of special values, orthogonality relations and sum rules that may include   rules with a (multiple) summation over dummy indices, cf. the monography by Varshalovich et al (1988).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Several other different kinds of computations have been prepared and will support the applications of the  JAC toolbox but come with a rather limited implementation so far.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Atomic responses: With this kind, we partly support computations in intense laser field; they also help   analyze the response of atoms to incident beams of light pulses and particles, such as field-induced   ionization processes, high-harmonic generation and several others. For these responses, the detailed   structure of atoms and ions has not been considered much until today. A partial-wave formulation of these   strong-field processes enables one to clearly distinguish between contributions due to the atomic target,  the Volkov states, or the shape and phase of the incident light.\nAtomic time-evolution of statistical tensors: We here wish to simulate the population and coherences  of (atomic) levels using the Liouville equation, when atoms and ions are irradiated by (intense) light  pulses. For these computations, however, we shall assume always that the level structure of the atoms is kept   intact. Further (decay) processes of the excited atoms and ions can be taken into account by some loss   rate, but without that the atoms can leave the pre-specified space of sublevels. In particular, we here   plan to consider the interaction of atoms and ions with pulses of different shape, polarization strength   and duration.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The development version of JAC can installed installed directly in the interactive Julia REPL (Read-Eval-Print-Loop) Press ] to enter the Julia package mode and type add https://github.com/OpenJAC/JAC.jl to install JAC.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]\n(@v1.10) pkg> add https://github.com/OpenJAC/JAC.jl","category":"page"},{"location":"index.html#Development","page":"Home","title":"Development","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"As a Scientific package users are encouraged to explore the capabilities of JAC, and modify the package as per their  requirement. JAC comes with an MIT 'Expat' License.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For development purpose, user can install JAC from GitHub to their desired direcory using git clone in the  terminal. This will download a copy of JAC from the development branch of GitHub repository.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"git clone https://github.com/OpenJAC/JAC.jl.git","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Next cd to the JAC.jl directory and start a new Julia session","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"shell> cd JAC.jl\nshell> julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Then activate the JAC.jl environment and install the dependancy packages of JAC.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]                   # Change to the Julia package mode\n(@v1.10) pkg> activate .\n(JAC) pkg> instantiate     # Installs the dependancy packages of JAC\n(JAC) pkg> resolve         # Required **Only if** there is a cinflict in the dependancies\n(JAC) pkg> develop .       # Adds the current directory path to Julia local Registry","category":"page"},{"location":"index.html#User-Guide-and-Manual","page":"Home","title":"User Guide and Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A detailed  User Guide, Compendium & Theoretical Background to JAC   is available that describes the use and underlying atomic theory of the JAC code.","category":"page"},{"location":"index.html#Dependencies","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Dependencies and external code used in JAC","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The JAC code makes use of:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"standard Julia packages, such as BSplineKit, SpecialFunctions, GaussQuadrature, GSL and QuadGK.\nMatrix elements from G. Gaigalas and S. Fritzsche, Comp. Phys. Commun. 267, 108086 (2021).","category":"page"},{"location":"index.html#Current-limitations-of-JAC","page":"Home","title":"Current limitations of JAC","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Although JAC has been designed for all atoms and ions across the periodic table, a number of limitations occur:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"All self-consistent-field computations are based so far on a local potential (e.g. core-Hartree, Kohn-Sham,  Dirac-Hartree-Slater, ...) that can be controlled by the user.\nUntil the present, no serious optimization has been done for the code; this restricts most computations to CSF expansion with several hundred CSF.\nAll continuum orbitals are generated in a local potential (Dirac-Hartree-Slater or others, as above) of the ionic core,  and without the explicit treatment of the exchange interaction.","category":"page"}]
}
